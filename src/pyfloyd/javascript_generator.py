# Copyright 2024 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 as found in the LICENSE file.
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-lines

from typing import Dict, List

from pyfloyd.ast import Not, Count
from pyfloyd.analyzer import Grammar
from pyfloyd.formatter import (
    Comma,
    ElList,
    HList,
    Indent,
    VList,
    Saw,
)
from pyfloyd.generator import Generator, GeneratorOptions


class JavaScriptGenerator(Generator):
    def __init__(self, grammar: Grammar, options: GeneratorOptions):
        super().__init__(grammar, options)
        self._indent = '  '
        self._map: Dict[str, str] = {
            'end': ';',
            'false': 'false',
            'indent': '  ',
            'Infinity': 'Infinity',
            'NaN': 'NaN',
            'not': '!',
            'null': 'null',
            'true': 'true',
        }

        self._builtin_methods = {}
        for k, v in _BUILTINS.items():
            self._builtin_methods[k] = v

        # Keep this updated and in sync with the text of each node type.
        self._local_vars: Dict[str, List[str]] = {
            'choice': ['pos'],
            'count': ['cmin', 'cmax', 'i', 'vs'],
            'not': ['errpos', 'pos'],
            'not_one': ['errpos', 'pos'],
            'opt': ['pos'],
            'plus': ['pos', 'vs'],
            'pred': ['v'],
            'regexp': ['found', 'r'],
            'run': ['end', 'start'],
            'set': ['found', 'r'],
            'star': ['pos', 'vs'],
        }
        self._derive_local_vars()

    def generate(self) -> str:
        if self._options.main:
            vl = self._gen_main_header(
                self._options.version, self._options.args
            )
        else:
            vl = self._gen_default_header(
                self._options.version, self._options.args
            )

        if self._grammar.exception_needed:
            vl += self._gen_parsing_runtime_exception_class()

        if self._grammar.operators:
            vl += self._gen_operator_state_class()

        vl += self._gen_result_class()
        vl += self._gen_parse_fn()
        vl += ''
        vl += self._gen_parser_class()
        vl += ''

        if self._options.main:
            vl += self._gen_main_footer()
        else:
            vl += self._gen_default_footer()
        return self._fmt(vl)

    def _gen_main_header(self, version, args) -> VList:
        return self._defmt(f"""\
            #!/usr/bin/env node
            //
            // Generated by pyfloyd version {version}
            //    https://github.com/dpranke/pyfloyd
            //    `pyfloyd {args}`
            """)

    def _gen_default_header(self, version, args) -> VList:
        return self._defmt(f"""\
            // Generated by pyfloyd version {version}
            //    https://github.com/dpranke/pyfloyd
            //    `pyfloyd {args}`
            """)

    def _gen_parsing_runtime_exception_class(self) -> VList:
        return self._defmt("""
            class ParsingRuntimeError extends Error {
              toString() {
                return this.message.toString();
              }
            }
            """)

    def _gen_operator_state_class(self) -> VList:
        return self._defmt("""\
            class OperatorState {
                constructor() {
                    this.currentDepth = 0
                    this.currentPrec = 0
                    this.precOps = {}  // Map[int, [str]]
                    this.precs = []    // List[int]
                    this.rassoc = new Set()
                    this.choices = {}  // Map[str, rule]
                }
            }
            """)

    def _gen_result_class(self) -> VList:
        return self._defmt("""\
            class Result {
              constructor(val, err, pos) {
                this.val = val;
                this.err = err;
                this.pos = pos;
              }
            }

            """)

    def _gen_parse_fn(self) -> VList:
        return self._defmt("""\
            function parse(text, path = '<string>', externs = null) {
              externs = externs || new Map();
              const p = new Parser(text, path);
              return p.parse(externs);
            }
            """)

    def _gen_parser_class(self) -> VList:
        vl = self._defmt("""\
            class Parser {
            """)

        svl = self._gen_constructor()
        svl += ''
        svl += self._gen_methods()
        vl += Indent(svl)
        vl += '}'

        return vl

    def _gen_constructor(self) -> VList:
        vl = self._defmt("""\
            constructor(text, path) {
              this.text = text;
              this.end = text.length;
              this.errpos = 0;
              this.failed = false;
              this.path = path;
              this.pos = 0;
              this.val = undefined;
              this.externs = new Map();
            """)

        if self._grammar.externs:
            for k, v in self._grammar.externs.items():
                val = 'true' if v else 'false'
                vl += f"  this.externs.set('{k}', {val});"

        if self._options.memoize:
            vl += '  this.cache = new Map();'
        if self._grammar.leftrec_needed or self._grammar.operator_needed:
            vl += '  this.seeds = {};'
        if self._grammar.leftrec_needed:
            vl += '  this.blocked = new Set();'
        if self._grammar.operator_needed:
            vl += self._gen_operator_state()
        if self._grammar.lookup_needed:
            vl += '  this.scopes = [];'

        vl += '}'

        return vl

    def _gen_operator_state(self) -> VList:
        vl = VList(['this.operators = {};'])
        vl += 'let o;'
        for rule, o in self._grammar.operators.items():
            vl += 'o = new OperatorState();'
            vl += 'o.precOps = new Map();'
            for prec in o.prec_ops:
                vl += 'o.precOps.set(%d, [' % prec
                vl += ', '.join("'%s'" % op for op in o.prec_ops[prec])
                vl += ']);'
            vl += 'o.precs = [...o.precOps.keys()].sort('
            vl += '(a, b) => b - a);'
            vl += 'o.rassoc = new Set(['
            vl += ', '.join("'%s'" % op for op in o.rassoc)
            vl += ']);'
            vl += 'o.choices = new Map();'
            for op in o.choices:
                vl += "o.choices.set('%s', this.%s);" % (
                    op,
                    o.choices[op],
                )
            vl += "this.operators['%s'] = o;" % rule
        return vl

    def _gen_parse_method(self, exception_needed, starting_rule) -> VList:
        if exception_needed:
            return self._defmt(f"""\
                parse(externs = null) {{
                  externs = externs || new Map();
                  let errors = '';
                  for (let key of externs.keys()) {{
                    if (!this.externs.has(key)) {{
                      errors += `Unexpected extern "${{key}}"\\n`;
                    }} else {{
                      this.externs[key] = externs[key];
                    }}
                  }}
                  if (errors != '') {{
                    return new Result(null, errors.trim(), 0);
                  }}

                  try {{
                    this.r_{starting_rule}();

                    if (this.failed) {{
                      return new Result(null, this.error(), this.errpos);
                    }} else {{
                      return new Result(this.val, null, this.pos);
                    }}
                  }} catch (e) {{
                    if (e instanceof ParsingRuntimeError) {{
                      let [lineno, _] = this.offsets(this.errpos);
                      return new Result(null, this.path + ':' + lineno + ' ' + e.toString());
                    }} else {{
                      throw e;
                    }}
                  }}
                }}
                """)
        return self._defmt(f"""\
            parse(externs = null) {{
              externs = externs || new Map();
              let errors = '';
              for (let key of externs.keys()) {{
                if (!this.externs.has(key)) {{
                    errors += `Unexpected extern "${{key}}"\\n`;
                }} else {{
                    this.externs[key] = externs[key];
                }}
              }}

              if (errors != '') {{
                return new Result(null, errors.trim(), 0);
              }}

              this.r_{starting_rule}();

              if (this.failed) {{
                return new Result(null, this.error(), this.errpos);
              }} else {{
                return new Result(this.val, null, this.pos);
              }}
            }}
            """)

    def _gen_methods(self) -> VList:
        vl = self._gen_parse_method(
            exception_needed=self._grammar.exception_needed,
            starting_rule=self._grammar.starting_rule,
        )
        vl += self._gen_rule_methods()
        vl += self._gen_needed_methods()

        if self._grammar.needed_builtin_functions:
            for name in self._grammar.needed_builtin_functions:
                vl += ''
                vl += self._builtin_methods[f'fn_{name}']

        return vl

    def _gen_rule_methods(self):
        vl = VList()
        for rule, node in self._grammar.rules.items():
            vl += ''
            vl += f'{rule}() {{'
            svl = VList()
            for v in node.local_vars:
                svl += f'let {v};'
            svl += self._gen_stmts(node)
            vl += Indent(svl)
            vl += '}'

        if self._grammar.needed_builtin_rules:
            vl += ''
            for name in self._grammar.needed_builtin_rules:
                vl += self._defmt(self._builtin_methods[f'r_{name}'])

        return vl

    def _gen_thisvar(self, name: str) -> str:
        return 'this.' + name

    def _gen_rulename(self, name: str) -> str:
        return 'this.' + name

    def _gen_extern(self, name: str) -> str:
        return "this.externs.get('" + name + "');"

    def _gen_invoke(self, fn: str, *args) -> Saw:
        return Saw('this.' + fn + '(', Comma(args), ')')

    #
    # Handlers for each non-host node in the glop AST follow.
    #

    def _ty_choice(self, node) -> VList:
        lines: FormatObjList = ['pos = this.pos;']
        for subnode in node.ch[:-1]:
            lines.append(self._gen_stmts(subnode))
            lines.append('if (!this.failed) {')
            lines.append('  return;')
            lines.append('}')
            lines.append('this.rewind(pos);')
        lines.append(self._gen_stmts(node.ch[-1]))
        return VList(lines)

    def _ty_count(self, node) -> VList:
        assert isinstance(node, Count)
        lines: FormatObjList = [
            'vs = [];',
            'i = 0;',
            f'cmin = {node.start};',
            f'cmax = {node.stop};',
            'while (i < cmax) {',
        ]
        lines.append(Indent(self._gen_stmts(node.child)))
        lines.extend(
            [
                '  if (this.failed) {',
                '    if (i >= cmin) {',
                '      this.succeed(vs);',
                '      return;',
                '    }',
                '    return;',
                '  }',
                '  vs.push(this.val);',
                '  i += 1;',
                '}',
                'this.succeed(vs);',
            ]
        )
        return VList(lines)

    def _ty_ends_in(self, node) -> VList:
        sublines = self._gen_stmts(node.child)
        return VList(
            [
                'while (true) {',
            ]
            + [Indent(sublines)]
            + [
                '  if (!this.failed) {',
                '    break;',
                '  }',
                '  this.r_any();',
                '  if (this.failed) {',
                '    break;',
                '  }',
                '}',
            ]
        )

    def _ty_label(self, node) -> VList:
        lines = [self._gen_stmts(node.child)]
        varname = self._gen_varname(node.v)
        if node.outer_scope:
            lines.append(
                VList(
                    [
                        'if (!this.failed) {',
                        f"  this.scopes[this.scopes.length-1].set('{node.v}', this.val);"
                        '}',
                    ]
                )
            )
        else:
            lines.append(
                VList(
                    [
                        'if (!this.failed) {',
                        f'  {varname} = this.val;',
                        '}',
                    ]
                )
            )
        return VList(lines)

    def _ty_not(self, node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'pos = this.pos;',
                'errpos = this.errpos;',
            ]
            + [sublines]
            + [
                'if (this.failed) {',
                '  this.succeed(null, pos);',
                '} else {',
                '  this.rewind(pos);',
                '  this.errpos = errpos;',
                '  this.fail();',
                '}',
            ]
        )
        return VList(lines)

    def _ty_not_one(self, node) -> VList:
        sublines = self._gen_stmts(self._grammar.node(Not, node.child))
        return VList(
            [sublines]
            + [
                'if (!this.failed) {',
                '  this.r_any(pos);',
                '}',
            ]
        )

    def _ty_opt(self, node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'pos = this.pos;',
            ]
            + [sublines]
            + [
                'if (this.failed) {',
                '  this.succeed([], pos);',
                '} else {',
                '  this.succeed([this.val]);',
                '}',
            ]
        )
        return VList(lines)

    def _ty_paren(self, node) -> VList:
        return self._gen_stmts(node.child)

    def _ty_plus(self, node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = VList(
            ['vs = [];']
            + [sublines]
            + [
                'vs.push(this.val);',
                'if (this.failed) {',
                '  return;',
                '}',
                'while (true) {',
                '  pos = this.pos;',
            ]
            + [Indent(sublines)]
            + [
                '  if (this.failed || this.pos === pos) {',
                '    this.rewind(pos);',
                '    break;',
                '  }',
                '  vs.push(this.val);',
                '}',
                'this.succeed(vs);',
            ]
        )
        return lines

    def _ty_pred(self, node) -> VList:
        arg = self._gen_expr(node.child)
        return VList(
            [
                HList(['v = ', arg]),
                'if (v === true) {',
                '  this.succeed(v);',
                '} else if (v === false) {',
                '  this.fail();',
                '} else {',
                "  throw new ParsingRuntimeError('Bad predicate value');",
                '}',
            ]
        )

    def _ty_regexp(self, node) -> VList:
        return VList(
            [
                f"r = new RegExp({self._gen_lit(node.v)}, 'gy');"
                'r.lastIndex = this.pos;',
                'found = r.exec(this.text);',
                'if (found) {',
                '  this.succeed(found[0], this.pos + found[0].length);',
                '  return;',
                '}',
                'this.fail();',
            ]
        )

    def _ty_run(self, node) -> VList:
        lines = self._gen_stmts(node.child)
        return VList(
            ['start = this.pos;']
            + [lines]
            + [
                'if (this.failed) {',
                '  return;',
                '}',
                'end = this.pos;',
                'this.val = this.text.substr(start, end);',
            ]
        )

    def _ty_scope(self, node) -> VList:
        return VList(
            [
                'this.scopes.push(new Map());',
            ]
            + [self._gen_stmts(node.child)]
            + [
                'this.scopes.pop();',
            ]
        )

    def _ty_seq(self, node) -> VList:
        vl = VList()
        for v in node.vars:
            vl += f'let {self._gen_varname(v)};'

        vl += self._gen_stmts(node.ch[0])
        for subnode in node.ch[1:]:
            vl += 'if (!this.failed) {'
            vl += Indent(self._gen_stmts(subnode))
            vl += '}'
        return vl

    def _ty_star(self, node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'vs = [];',
                'while (true) {',
                '  pos = this.pos;',
            ]
            + [Indent(sublines)]
            + [
                '  if (this.failed || this.pos === pos) {',
                '    this.rewind(pos);',
                '    break;',
                '  }',
                '  vs.push(this.val);',
                '}',
                'this.succeed(vs);',
            ]
        )
        return VList(lines)

    def _gen_main_footer(self) -> VList:
        return self._defmt("""\
            async function main() {
              const fs = require('fs');
              const path = require('path');

              let s = "";
              let externs = new Map();
              let i = 2;
              while (i < process.argv.length) {
                if (process.argv[i] == '-h' || process.argv[i] == '--help') {
                  console.log(`\
            usage: ${path.basename(process.argv[1])} [-h] [-D var=val] [file]

            positional arguments:
              file

            options:
              -h, --help            show this help message and exit
              -D, --define var=val  define an external var=value (may use multiple times)`);
                  process.exit(0);
                }

                if (process.argv[i] == '-D' || process.argv[i] == '--define') {
                  let [k, v] = process.argv[i+1].split('=', 2);
                  externs.set(k, JSON.parse(v))
                  i += 2;
                } else {
                  break;
                }
              }
              let filename;
              if (process.argv.length == i || process.argv[i] == "-") {
                filename = '<stdin>';
                function readStream(stream) {
                  stream.setEncoding("utf8");
                  return new Promise((resolve, reject) => {
                    let data = "";

                    stream.on("data", (chunk) => (data += chunk));
                    stream.on("end", () => resolve(data));
                    stream.on("error", (error) => reject(error));
                  });
                }
                s = await readStream(process.stdin);
              } else {
                filename = process.argv[i];
                s = await fs.promises.readFile(filename);
              }

              let result = parse(s.toString(), filename, externs);

              let txt, stream, ret;
              if (result.err != undefined) {
                txt = result.err;
                stream = process.stderr;
                ret = 1;
              } else {
                txt = JSON.stringify(result.val, null, 2);
                stream = process.stdout;
                ret = 0;
              }
              await new Promise(function(resolve, reject) {
                stream.write(txt + '\\n', 'utf8', function(err, data) {
                  if (err != null) {
                    reject(err);
                  } else {
                    resolve(data);
                  }
                });
              });
              process.exit(ret);
            }

            if (typeof process !== "undefined" && process.release.name === "node") {
              (async () => {
                main();
              })();
            }
            """)

    def _gen_default_footer(self) -> VList:
        return VList()


_BUILTINS = {
    'r_any': """\
        r_any() {
          if (this.pos < this.end) {
            this.succeed(this.text[this.pos], this.pos + 1);
          } else {
            this.fail();
          }
        }
        """,
    'r_end': """\
        r_end() {
          if (this.pos === this.end) {
            this.succeed(null);
          } else {
            this.fail();
          }
        }
        """,
    'ch': """\
        ch(c) {
          let pos = this.pos;
          if (pos < this.end && this.text[pos] === c) {
            this.succeed(c, this.pos + 1);
          } else {
            this.fail();
          }
        }
        """,
    'offsets': """\
        offsets(pos) {
          let lineno = 1;
          let colno = 1;
          for (let i = 0; i < pos; i++) {
            if (this.text[i] === '\\n') {
              lineno += 1;
              colno = 1;
            } else {
              colno += 1;
            }
          }
          return [lineno, colno];
        }
        """,
    'error': """\
        error() {
          let [lineno, colno] = this.offsets(this.errpos);
          let thing;
          if (this.errpos === this.end) {
            thing = 'end of input';
          } else {
            thing = JSON.stringify(this.text[this.errpos]);
          }
          return `${this.path}:${lineno} Unexpected ${thing} at column ${colno}`;
        }
        """,
    'fail': """\
        fail() {
          this.val = undefined;
          this.failed = true;
          this.errpos = Math.max(this.errpos, this.pos);
        }
        """,
    'leftrec': """\
        leftrec(rule, rule_name, left_assoc) {
          let pos = this.pos;
          let key = [rule_name, pos];
          let seed = this.seeds[key];
          if (seed) {
            [this.val, this.failed, this.pos] = seed;
            return;
          }
          if (this.blocked.has(rule_name)) {
            this.val = undefined;
            this.failed = true;
            return;
          }
          let current = [undefined, true, this.pos];
          this.seeds[key] = current;
          if (left_assoc) {
            this.blocked.add(rule_name);
          }
          while (true) {
            rule.call(this);
            if (this.pos > current[2]) {
              current = [this.val, this.failed, this.pos];
              this.seeds[key] = current;
              this.pos = pos;
            } else {
              delete this.seeds[key];
              [this.val, this.failed, this.pos] = current;
              if (left_assoc) {
                this.blocked.delete(rule_name);
              }
              return;
            }
          }
        }
        """,
    'lookup': """\
        lookup(v) {
          let l = this.scopes.length - 1;
          while (l >= 0) {
            if (this.scopes[l].has(v)) {
              return this.scopes[l].get(v);
            }
            l -= 1;
          }
          if (this.externs.has(v)) {
            return this.externs.get(v);
          }
          throw new ParsingRuntimeError(`Unknown var "${v}"`);
        }
        """,
    'memoize': """\
        memoize(rule_name, fn) {
          let pos = this.pos;
          if (!this.cache.has(pos)) {
            this.cache.set(pos, new Map());
          }
          if (this.cache.get(pos).has(rule_name)) {
            [this.val, this.failed, this.pos] = this.cache.get(pos).get(rule_name);
            return;
          }
          fn.call(this);
          this.cache.get(pos).set(rule_name, [this.val, this.failed, this.pos]);
        }
        """,
    'operator': """\
        operator(rule_name) {
          let o = this.operators[rule_name];
          let pos = this.pos;
          let key = [rule_name, pos];
          let seed = this.seeds[key];
          if (seed) {
            [this.val, this.failed, this.pos] = seed;
            return;
          }
          o.currentDepth += 1;
          let current = [null, true, pos];
          this.seeds[key] = current;
          let minPrec = o.currentPrec;
          let i = 0;
          while (i < o.precs.length) {
            let repeat = false;
            let prec = o.precs[i];
            let precOps = o.precOps.get(prec);
            if (prec < minPrec) {
              break;
            }
            o.currentPrec = prec;
            if (!o.rassoc.has(precOps[0])) {
              o.currentPrec += 1;
            }
            for (let j = 0; j < precOps.length; j += 1) {
              let op = precOps[j];
              o.choices.get(op).call(this);
              if (!this.failed && this.pos > pos) {
                current = [this.val, this.failed, this.pos];
                this.seeds[key] = current;
                repeat = true;
                break;
              }
              this.rewind(pos);
            }
            if (!repeat) {
              i += 1;
            }
          }

          delete this.seeds[key];
          o.currentDepth -= 1;
          if (o.currentDepth === 0) {
            o.currentPrec = 0;
          }
          [this.val, this.failed, this.pos] = current;
        }
        """,
    'range': """\
        range(i, j) {
          let pos = this.pos;
          if (pos == this.end) {
            this.fail();
            return;
          }
          let c = this.text[pos];
          if (i <= c && c <= j) {
            this.succeed(this.text[pos], this.pos + 1);
          } else {
            this.fail();
          }
        }
        """,
    'rewind': """\
        rewind(newpos) {
          this.succeed(null, newpos);
        }
        """,
    'str': """\
        str(s) {
          for (let ch of s) {
            this.ch(ch);
            if (this.failed) {
              return;
            }
              this.val = s;
            }
        }
        """,
    'succeed': """\
        succeed(v, newpos = null) {
          this.val = v;
          this.failed = false;
          if (newpos !== null) {
            this.pos = newpos;
          }
        }
        """,
    'unicat': """\
        unicat(cat) {
          if (this.pos == this.end) {
            this.fail();
            return
          }
          let c = this.text[this.pos];
          let re = new RegExp(`\\\\p{${cat}}`, 'u');
          if (c.match(re)) {
            this.succeed(c, this.pos + 1);
          } else {
            this.fail();
          }
        }
        """,
    'fn_atof': """\
        fn_atof(a) {
          return parseFloat(a)
        }
        """,
    'fn_atoi': """\
        fn_atoi(a, base) {
          return parseInt(a, base);
        }
        """,
    'fn_atou': """\
        fn_atou(a, base) {
          return String.fromCharCode(Number.parseInt(a, base));
        }
        """,
    'fn_cat': """\
        fn_cat(ss) {
          return ss.join('');
        }
        """,
    'fn_concat': """\
        fn_concat(xs, ys) {
          return xs.concat(ys);
        }
        """,
    'fn_cons': """\
        fn_cons(hd, tl) {
          return [hd].concat(tl);
        }
        """,
    'fn_dedent': """\
        fn_dedent(s) {
          return s;
        }
        """,
    'fn_dict': """\
        fn_dict(pairs) {
          let m = new Map();
          for (let [k, v] of pairs) {
            m[k] = v;
          }
          return m;
        }
        """,
    'fn_itou': """\
        fn_itou(n) {
          return String.fromCharCode(n);
        }
        """,
    'fn_join': """\
        fn_join(s, vs) {
          return vs.join(s);
        }
        """,
    'fn_scat': """\
        fn_scat(ss) {
          return ss.join('');
        }
        """,
    'fn_scons': """\
        fn_scons(hd, tl) {
          return [hd].concat(tl);
        }
        """,
    'fn_strcat': """\
        fn_strcat(a, b) {
          return a.concat(b);
        }
        """,
    'fn_unicode_lookup': """\
        fn_unicode_lookup(s) {
          throw new ParsingRuntimeError('Unsupported function "unicode_lookup"');
        }
        """,
    'fn_utoi': """\
        fn_utoi(s) {
          return s.charCodeAt(0);
        }
        """,
    'fn_xtoi': """\
        fn_xtoi(s) {
          return Number.parseInt(s, 16);
        }
        """,
    'fn_xtou': """\
        fn_xtou(s) {
          return String.fromCharCode(Number.parseInt(s, 16));
        }
        """,
}
