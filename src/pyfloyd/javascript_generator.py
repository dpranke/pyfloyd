# Copyright 2024 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 as found in the LICENSE file.
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-lines

from typing import Any, Optional, Union

from pyfloyd import datafile
from pyfloyd import formatter
from pyfloyd import grammar as gram
from pyfloyd import generator
from pyfloyd import hard_coded_generator
from pyfloyd import support


class JavaScriptGenerator(hard_coded_generator.HardCodedGenerator):
    name: str = 'JavaScript'
    ext: str = '.js'
    indent: Union[int, str] = 2
    line_length: Optional[int] = 79

    def __init__(
        self,
        host: support.Host,
        data: dict[str, Any],
        options: generator.GeneratorOptions,
    ):
        assert 'grammar' in data
        super().__init__(host, data, options)
        self._map: dict[str, str] = {
            'end': ';',
            'false': 'false',
            'indent': '  ',
            'Infinity': 'Infinity',
            'NaN': 'NaN',
            'not': '!',
            'null': 'null',
            'true': 'true',
        }

        self._builtin_methods = {}
        for k, v in _BUILTINS.items():
            self._builtin_methods[k] = datafile.dedent(v)

        # Keep this updated and in sync with the text of each node type.
        local_var_map: dict[str, list[str]] = {
            'choice': ['pos'],
            'count': ['cmin', 'cmax', 'i', 'vs'],
            'not': ['errpos', 'pos'],
            'not_one': ['errpos', 'pos'],
            'opt': ['pos'],
            'plus': ['pos', 'vs'],
            'pred': ['v'],
            'regexp': ['found', 'r'],
            'run': ['end', 'start'],
            'set': ['found', 'r'],
            'star': ['pos', 'vs'],
        }
        self._process_grammar(local_var_map)

    def generate(self) -> str:
        if self.options.main:
            vl = self._gen_main_header(
                self.options.version, self.options.command_line
            )
        else:
            vl = self._gen_default_header(
                self.options.version, self.options.command_line
            )

        if self.grammar.exception_needed:
            vl += self._gen_parsing_runtime_exception_class()

        if self.grammar.operators:
            vl += self._gen_operator_state_class()

        vl += self._gen_result_class()
        vl += self._gen_parse_fn()
        vl += ''
        vl += self._gen_parser_class()
        vl += ''

        if self.options.main:
            vl += self._gen_main_footer()
        else:
            vl += self._gen_default_footer()
        return self._fmt(vl)

    def _gen_main_header(self, version, args) -> formatter.VList:
        return self._defmt(f"""
            #!/usr/bin/env node
            //
            // Generated by pyfloyd version {version}
            //    https://github.com/dpranke/pyfloyd
            //    `pyfloyd {args}`
            """)

    def _gen_default_header(self, version, args) -> formatter.VList:
        return self._defmt(f"""
            // Generated by pyfloyd version {version}
            //    https://github.com/dpranke/pyfloyd
            //    `pyfloyd {args}`
            """)

    def _gen_parsing_runtime_exception_class(self) -> formatter.VList:
        return self._defmt("""
            class ParsingRuntimeError extends Error {
              toString() {
                return this.message.toString();
              }
            }
            """)

    def _gen_operator_state_class(self) -> formatter.VList:
        return self._defmt("""
            class OperatorState {
                constructor() {
                    this.currentDepth = 0
                    this.currentPrec = 0
                    this.precOps = {}  // dict[int, [str]]
                    this.precs = []    // list[int]
                    this.rassoc = new Set()
                    this.choices = {}  // dict[str, Rule]
                }
            }
            """)

    def _gen_result_class(self) -> formatter.VList:
        return self._defmt("""
            class Result {
              constructor(val, err, pos) {
                this.val = val;
                this.err = err;
                this.pos = pos;
              }
            }

            """)

    def _gen_parse_fn(self) -> formatter.VList:
        return self._defmt("""
            function parse(text, path = '<string>', externs = null) {
              externs = externs || new Map();
              const p = new Parser(text, path);
              return p.parse(externs);
            }
            """)

    def _gen_parser_class(self) -> formatter.VList:
        vl = self._defmt("""
            class Parser {
            """)

        svl = self._gen_constructor()
        svl += ''
        svl += self._gen_methods()
        vl += formatter.Indent(svl)
        vl += '}'

        return vl

    def _gen_constructor(self) -> formatter.VList:
        vl = self._defmt("""
            constructor(text, path) {
              this.text = text;
              this.end = text.length;
              this.errpos = 0;
              this.failed = false;
              this.path = path;
              this.pos = 0;
              this.val = undefined;
              this.externs = new Map();
            """)

        if self.grammar.externs:
            for k, v in self.grammar.externs.items():
                val = 'true' if v else 'false'
                vl += f"  this.externs.set('{k}', {val});"

        if self.options.memoize:
            vl += '  this.cache = new Map();'
        if self.grammar.leftrec_needed or self.grammar.operator_needed:
            vl += '  this.seeds = {};'
        if self.grammar.leftrec_needed:
            vl += '  this.blocked = new Set();'
        if self.grammar.operator_needed:
            vl += self._gen_operator_state()
        if self.grammar.lookup_needed:
            vl += '  this.scopes = [];'

        vl += '}'

        return vl

    def _gen_operator_state(self) -> formatter.VList:
        vl = formatter.VList('this.operators = {};')
        vl += 'let o;'
        for rule, o in self.grammar.operators.items():
            vl += 'o = new OperatorState();'
            vl += 'o.precOps = new Map();'
            for prec in o.prec_ops:
                vl += 'o.precOps.set(' + str(prec) + ', ['
                vl += ', '.join("'" + op + "'" for op in o.prec_ops[prec])
                vl += ']);'
            vl += 'o.precs = [...o.precOps.keys()].sort('
            vl += '(a, b) => b - a);'
            vl += 'o.rassoc = new Set(['
            vl += ', '.join("'" + op + "'" for op in o.rassoc)
            vl += ']);'
            vl += 'o.choices = new Map();'
            for op in o.choices:
                vl += "o.choices.set('" + op + "', "
                vl += 'this.' + o.choices[op] + ');'
            vl += "this.operators['" + rule + "'] = o;"
        return vl

    def _gen_parse_method(
        self, exception_needed, starting_rule
    ) -> formatter.VList:
        if exception_needed:
            return self._defmt(f"""
                parse(externs = null) {{
                  externs = externs || new Map();
                  let errors = '';
                  for (let key of externs.keys()) {{
                    if (!this.externs.has(key)) {{
                      errors += `Unexpected extern "${{key}}"\\n`;
                    }} else {{
                      this.externs[key] = externs[key];
                    }}
                  }}
                  if (errors != '') {{
                    return new Result(null, errors.trim(), 0);
                  }}

                  try {{
                    this.r_{starting_rule}();

                    if (this.failed) {{
                      return new Result(null, this.o_error(), this.errpos);
                    }} else {{
                      return new Result(this.val, null, this.pos);
                    }}
                  }} catch (e) {{
                    if (e instanceof ParsingRuntimeError) {{
                      let [lineno, _] = this.o_offsets(this.errpos);
                      return new Result(null, this.path + ':' + lineno + ' ' + e.toString());
                    }} else {{
                      throw e;
                    }}
                  }}
                }}
                """)
        return self._defmt(f"""
            parse(externs = null) {{
              externs = externs || new Map();
              let errors = '';
              for (let key of externs.keys()) {{
                if (!this.externs.has(key)) {{
                    errors += `Unexpected extern "${{key}}"\\n`;
                }} else {{
                    this.externs[key] = externs[key];
                }}
              }}

              if (errors != '') {{
                return new Result(null, errors.trim(), 0);
              }}

              this.r_{starting_rule}();

              if (this.failed) {{
                return new Result(null, this.o_error(), this.errpos);
              }} else {{
                return new Result(this.val, null, this.pos);
              }}
            }}
            """)

    def _gen_methods(self) -> formatter.VList:
        vl = self._gen_parse_method(
            exception_needed=self.grammar.exception_needed,
            starting_rule=self.grammar.starting_rule,
        )
        vl += self._gen_rule_methods()
        vl += self._gen_needed_methods()

        if self.grammar.needed_builtin_functions:
            for name in self.grammar.needed_builtin_functions:
                vl += ''
                vl += self._defmt(
                    self._builtin_methods[f'fn_{name}'], dedented=True
                )

        return vl

    def _gen_rule_methods(self):
        vl = formatter.VList()
        for rule, node in self.grammar.rules.items():
            vl += ''
            vl += f'{rule}() {{'
            svl = formatter.VList()
            for v in node.local_vars:
                svl += f'let {v};'
            svl += self._gen_stmts(node)
            vl += formatter.Indent(svl)
            vl += '}'

        if self.grammar.needed_builtin_rules:
            vl += ''
            for name in self.grammar.needed_builtin_rules:
                vl += self._defmt(
                    self._builtin_methods[f'r_{name}'], dedented=True
                )

        return vl

    def _gen_thisvar(self, name: str) -> str:
        return 'this.' + name

    def _gen_rulename(self, name: str) -> str:
        return 'this.' + name

    def _gen_funcname(self, name: str) -> str:
        return 'this.fn_' + name

    def _gen_opname(self, name: str) -> str:
        return 'o_' + name

    def _gen_extern(self, name: str) -> str:
        return "this.externs.get('" + name + "');"

    def _gen_invoke(self, fn: str, *args) -> formatter.Saw:
        return formatter.Saw(
            self._gen_rulename(fn),
            formatter.Triangle('(', formatter.Comma(*args), ')'),
        )

    #
    # Handlers for each non-host node in the glop AST follow.
    #

    def _ty_choice(self, node) -> formatter.VList:
        vl = formatter.VList('pos = this.pos;')
        for subnode in node.ch[:-1]:
            vl += self._gen_stmts(subnode)
            vl += 'if (!this.failed) {'
            vl += '  return;'
            vl += '}'
            vl += 'this.o_rewind(pos);'
        vl += self._gen_stmts(node.ch[-1])
        return vl

    def _ty_count(self, node) -> formatter.VList:
        assert isinstance(node, gram.Count)
        vl = formatter.VList(
            'vs = [];',
            'i = 0;',
            f'cmin = {node.start};',
            f'cmax = {node.stop};',
            'while (i < cmax) {',
        )
        vl += formatter.Indent(self._gen_stmts(node.child))
        vl += [
            '  if (this.failed) {',
            '    if (i >= cmin) {',
            '      this.o_succeed(vs);',
            '      return;',
            '    }',
            '    return;',
            '  }',
            '  vs.push(this.val);',
            '  i += 1;',
            '}',
            'this.o_succeed(vs);',
        ]
        return vl

    def _ty_ends_in(self, node) -> formatter.VList:
        sublines = self._gen_stmts(node.child)
        return formatter.VList(
            'while (true) {',
            formatter.Indent(sublines),
            '  if (!this.failed) {',
            '    break;',
            '  }',
            '  this.r_any();',
            '  if (this.failed) {',
            '    break;',
            '  }',
            '}',
        )

    def _ty_label(self, node) -> formatter.VList:
        varname = self._gen_varname(node.v)
        vl = formatter.VList()
        vl += self._gen_stmts(node.child)
        if node.outer_scope:
            vl += [
                'if (!this.failed) {',
                (
                    f'  this.scopes[this.scopes.length-1].'
                    f"set('{node.v}', this.val);"
                ),
                '}',
            ]
        else:
            vl += [
                'if (!this.failed) {',
                f'  {varname} = this.val;',
                '}',
            ]
        return vl

    def _ty_not(self, node) -> formatter.VList:
        vl = formatter.VList(
            'pos = this.pos;',
            'errpos = this.errpos;',
        )
        vl += self._gen_stmts(node.child)
        vl += [
            'if (this.failed) {',
            '  this.o_succeed(null, pos);',
            '} else {',
            '  this.o_rewind(pos);',
            '  this.errpos = errpos;',
            '  this.o_fail();',
            '}',
        ]
        return vl

    def _ty_not_one(self, node) -> formatter.VList:
        vl = formatter.VList()
        vl += self._gen_stmts(self.grammar.node(gram.Not, node.child))
        vl += [
            'if (!this.failed) {',
            '  this.r_any(pos);',
            '}',
        ]
        return vl

    def _ty_opt(self, node) -> formatter.VList:
        vl = formatter.VList(
            'pos = this.pos;',
        )
        vl += self._gen_stmts(node.child)
        vl += [
            'if (this.failed) {',
            '  this.o_succeed([], pos);',
            '} else {',
            '  this.o_succeed([this.val]);',
            '}',
        ]
        return vl

    def _ty_paren(self, node) -> formatter.VList:
        return self._gen_stmts(node.child)

    def _ty_plus(self, node) -> formatter.VList:
        sublines = self._gen_stmts(node.child)
        vl = formatter.VList('vs = [];')
        vl += sublines
        vl += [
            'vs.push(this.val);',
            'if (this.failed) {',
            '  return;',
            '}',
            'while (true) {',
            '  pos = this.pos;',
            formatter.Indent(sublines),
            '  if (this.failed || this.pos === pos) {',
            '    this.o_rewind(pos);',
            '    break;',
            '  }',
            '  vs.push(this.val);',
            '}',
            'this.o_succeed(vs);',
        ]
        return vl

    def _ty_pred(self, node) -> formatter.VList:
        arg = self._gen_expr(node.child)
        return formatter.VList(
            formatter.HList('v = ', arg),
            'if (v === true) {',
            '  this.o_succeed(v);',
            '} else if (v === false) {',
            '  this.o_fail();',
            '} else {',
            "  throw new ParsingRuntimeError('Bad predicate value');",
            '}',
        )

    def _ty_regexp(self, node) -> formatter.VList:
        return formatter.VList(
            f"r = new RegExp({self._gen_lit(node.v)}, 'gy');"
            'r.lastIndex = this.pos;',
            'found = r.exec(this.text);',
            'if (found) {',
            '  this.o_succeed(found[0], this.pos + found[0].length);',
            '  return;',
            '}',
            'this.o_fail();',
        )

    def _ty_run(self, node) -> formatter.VList:
        vl = formatter.VList('start = this.pos;')
        vl += self._gen_stmts(node.child)
        vl += [
            'if (this.failed) {',
            '  return;',
            '}',
            'end = this.pos;',
            'this.val = this.text.substr(start, end);',
        ]
        return vl

    def _ty_scope(self, node) -> formatter.VList:
        vl = formatter.VList('this.scopes.push(new Map());')
        vl += self._gen_stmts(node.child)
        vl += 'this.scopes.pop();'
        return vl

    def _ty_seq(self, node) -> formatter.VList:
        vl = formatter.VList()
        for v in node.vars:
            vl += f'let {self._gen_varname(v)};'

        vl += self._gen_stmts(node.ch[0])
        for subnode in node.ch[1:]:
            vl += 'if (!this.failed) {'
            vl += formatter.Indent(self._gen_stmts(subnode))
            vl += '}'
        return vl

    def _ty_star(self, node) -> formatter.VList:
        sublines = self._gen_stmts(node.child)
        vl = formatter.VList(
            'vs = [];',
            'while (true) {',
            '  pos = this.pos;',
            formatter.Indent(sublines),
            '  if (this.failed || this.pos === pos) {',
            '    this.o_rewind(pos);',
            '    break;',
            '  }',
            '  vs.push(this.val);',
            '}',
            'this.o_succeed(vs);',
        )
        return vl

    def _gen_main_footer(self) -> formatter.VList:
        return self._defmt("""
            async function main() {
              const fs = require('fs');
              const path = require('path');

              let filename;
              let s = null;
              let externs = new Map();
              let i = 2;

              while (i < process.argv.length) {
                if (process.argv[i] == '-h' || process.argv[i] == '--help') {
                  console.log(`\
            usage: ${path.basename(process.argv[1])} [-h] [-D var=val] [-c str] [file]

            positional arguments:
              file

            options:
              -h, --help            show this help message and exit
              -c, --code str        use the text in str as input
              -D, --define var=val  define an external var=value (may use multiple times)`);
                  process.exit(0);
                }

                if (process.argv[i] == '-D' || process.argv[i] == '--define') {
                  let [k, v] = process.argv[i+1].split('=', 2);
                  externs.set(k, JSON.parse(v))
                  i += 2;
                } else if (process.argv[i] == '-c' || process.argv[i] == '--code') {
                  s = process.argv[i+1];
                  filename = '<code>';
                  break;
                } else {
                  break;
                }
              }

              if (s === null) {
                if (process.argv.length == i || process.argv[i] == "-") {
                  filename = '<stdin>';
                  function readStream(stream) {
                    stream.setEncoding("utf8");
                    return new Promise((resolve, reject) => {
                      let data = "";

                      stream.on("data", (chunk) => (data += chunk));
                      stream.on("end", () => resolve(data));
                      stream.on("error", (error) => reject(error));
                    });
                  }
                  s = await readStream(process.stdin);
                } else {
                  filename = process.argv[i];
                  s = await fs.promises.readFile(filename);
                }
              }

              let result = parse(s.toString(), filename, externs);

              let txt, stream, ret;
              if (result.err != undefined) {
                txt = result.err;
                stream = process.stderr;
                ret = 1;
              } else {
                txt = JSON.stringify(result.val, null, 2);
                stream = process.stdout;
                ret = 0;
              }
              await new Promise(function(resolve, reject) {
                stream.write(txt + '\\n', 'utf8', function(err, data) {
                  if (err != null) {
                    reject(err);
                  } else {
                    resolve(data);
                  }
                });
              });
              process.exit(ret);
            }

            if (typeof process !== "undefined" && process.release.name === "node") {
              (async () => {
                main();
              })();
            }
            """)

    def _gen_default_footer(self) -> formatter.VList:
        return formatter.VList()


_BUILTINS = {
    'r_any': """
        r_any() {
          if (this.pos < this.end) {
            this.o_succeed(this.text[this.pos], this.pos + 1);
          } else {
            this.o_fail();
          }
        }
        """,
    'r_end': """
        r_end() {
          if (this.pos === this.end) {
            this.o_succeed(null);
          } else {
            this.o_fail();
          }
        }
        """,
    'ch': """
        o_ch(c) {
          let pos = this.pos;
          if (pos < this.end && this.text[pos] === c) {
            this.o_succeed(c, this.pos + 1);
          } else {
            this.o_fail();
          }
        }
        """,
    'offsets': """
        o_offsets(pos) {
          let lineno = 1;
          let colno = 1;
          for (let i = 0; i < pos; i++) {
            if (this.text[i] === '\\n') {
              lineno += 1;
              colno = 1;
            } else {
              colno += 1;
            }
          }
          return [lineno, colno];
        }
        """,
    'error': """
        o_error() {
          let [lineno, colno] = this.o_offsets(this.errpos);
          let thing;
          if (this.errpos === this.end) {
            thing = 'end of input';
          } else {
            thing = JSON.stringify(this.text[this.errpos]);
          }
          return `${this.path}:${lineno} Unexpected ${thing} at column ${colno}`;
        }
        """,
    'fail': """
        o_fail() {
          this.val = undefined;
          this.failed = true;
          this.errpos = Math.max(this.errpos, this.pos);
        }
        """,
    'leftrec': """
        o_leftrec(rule, rule_name, left_assoc) {
          let pos = this.pos;
          let key = [rule_name, pos];
          let seed = this.seeds[key];
          if (seed) {
            [this.val, this.failed, this.pos] = seed;
            return;
          }
          if (this.blocked.has(rule_name)) {
            this.val = undefined;
            this.failed = true;
            return;
          }
          let current = [undefined, true, this.pos];
          this.seeds[key] = current;
          if (left_assoc) {
            this.blocked.add(rule_name);
          }
          while (true) {
            rule.call(this);
            if (this.pos > current[2]) {
              current = [this.val, this.failed, this.pos];
              this.seeds[key] = current;
              this.pos = pos;
            } else {
              delete this.seeds[key];
              [this.val, this.failed, this.pos] = current;
              if (left_assoc) {
                this.blocked.delete(rule_name);
              }
              return;
            }
          }
        }
        """,
    'lookup': """
        o_lookup(v) {
          let l = this.scopes.length - 1;
          while (l >= 0) {
            if (this.scopes[l].has(v)) {
              return this.scopes[l].get(v);
            }
            l -= 1;
          }
          if (this.externs.has(v)) {
            return this.externs.get(v);
          }
          throw new ParsingRuntimeError(`Unknown var "${v}"`);
        }
        """,
    'memoize': """
        o_memoize(rule_name, fn) {
          let pos = this.pos;
          if (!this.cache.has(pos)) {
            this.cache.set(pos, new Map());
          }
          if (this.cache.get(pos).has(rule_name)) {
            [this.val, this.failed, this.pos] = this.cache.get(pos).get(rule_name);
            return;
          }
          fn.call(this);
          this.cache.get(pos).set(rule_name, [this.val, this.failed, this.pos]);
        }
        """,
    'operator': """
        o_operator(rule_name) {
          let o = this.operators[rule_name];
          let pos = this.pos;
          let key = [rule_name, pos];
          let seed = this.seeds[key];
          if (seed) {
            [this.val, this.failed, this.pos] = seed;
            return;
          }
          o.currentDepth += 1;
          let current = [null, true, pos];
          this.seeds[key] = current;
          let minPrec = o.currentPrec;
          let i = 0;
          while (i < o.precs.length) {
            let repeat = false;
            let prec = o.precs[i];
            let precOps = o.precOps.get(prec);
            if (prec < minPrec) {
              break;
            }
            o.currentPrec = prec;
            if (!o.rassoc.has(precOps[0])) {
              o.currentPrec += 1;
            }
            for (let j = 0; j < precOps.length; j += 1) {
              let op = precOps[j];
              o.choices.get(op).call(this);
              if (!this.failed && this.pos > pos) {
                current = [this.val, this.failed, this.pos];
                this.seeds[key] = current;
                repeat = true;
                break;
              }
              this.o_rewind(pos);
            }
            if (!repeat) {
              i += 1;
            }
          }

          delete this.seeds[key];
          o.currentDepth -= 1;
          if (o.currentDepth === 0) {
            o.currentPrec = 0;
          }
          [this.val, this.failed, this.pos] = current;
        }
        """,
    'range': """
        o_range(i, j) {
          let pos = this.pos;
          if (pos == this.end) {
            this.o_fail();
            return;
          }
          let c = this.text[pos];
          if (i <= c && c <= j) {
            this.o_succeed(this.text[pos], this.pos + 1);
          } else {
            this.o_fail();
          }
        }
        """,
    'rewind': """
        o_rewind(newpos) {
          this.o_succeed(null, newpos);
        }
        """,
    'str': """
        o_str(s) {
          for (let ch of s) {
            this.o_ch(ch);
            if (this.failed) {
              return;
            }
              this.val = s;
            }
        }
        """,
    'succeed': """
        o_succeed(v, newpos = null) {
          this.val = v;
          this.failed = false;
          if (newpos !== null) {
            this.pos = newpos;
          }
        }
        """,
    'unicat': """
        o_unicat(cat) {
          if (this.pos == this.end) {
            this.o_fail();
            return
          }
          let c = this.text[this.pos];
          let re = new RegExp(`\\\\p{${cat}}`, 'u');
          if (c.match(re)) {
            this.o_succeed(c, this.pos + 1);
          } else {
            this.o_fail();
          }
        }
        """,
    'fn_atof': """
        fn_atof(a) {
          return parseFloat(a)
        }
        """,
    'fn_atoi': """
        fn_atoi(a, base) {
          return parseInt(a, base);
        }
        """,
    'fn_atou': """
        fn_atou(a, base) {
          return String.fromCharCode(Number.parseInt(a, base));
        }
        """,
    'fn_cat': """
        fn_cat(ss) {
          return ss.join('');
        }
        """,
    'fn_colno': """
        fn_colno() {
          let colno = 0;
          if (this.pos == this.end) {
            colno += 1;
          }
          while (this.pos >= colno && this.text[this.pos - colno] != '\\n') {
            colno += 1;
          }
          return colno;
        }
        """,
    'fn_concat': """
        fn_concat(xs, ys) {
          return xs.concat(ys);
        }
        """,
    'fn_cons': """
        fn_cons(hd, tl) {
          return [hd].concat(tl);
        }
        """,
    'fn_dedent': """
        fn_dedent(s) {
          return s;
        }
        """,
    'fn_dict': """
        fn_dict(pairs) {
          let m = new Map();
          for (let [k, v] of pairs) {
            m[k] = v;
          }
          return m;
        }
        """,
    'fn_itou': """
        fn_itou(n) {
          return String.fromCharCode(n);
        }
        """,
    'fn_join': """
        fn_join(s, vs) {
          return vs.join(s);
        }
        """,
    'fn_scat': """
        fn_scat(ss) {
          return ss.join('');
        }
        """,
    'fn_scons': """
        fn_scons(hd, tl) {
          return [hd].concat(tl);
        }
        """,
    'fn_strcat': """
        fn_strcat(a, b) {
          return a.concat(b);
        }
        """,
    'fn_ulookup': """
        fn_ulookup(s) {
          throw new ParsingRuntimeError('Unsupported function "ulookup"');
        }
        """,
    'fn_utoi': """
        fn_utoi(s) {
          return s.charCodeAt(0);
        }
        """,
    'fn_xtoi': """
        fn_xtoi(s) {
          return Number.parseInt(s, 16);
        }
        """,
    'fn_xtou': """
        fn_xtou(s) {
          return String.fromCharCode(Number.parseInt(s, 16));
        }
        """,
}
