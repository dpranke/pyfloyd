# Copyright 2024 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 as found in the LICENSE file.
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-lines

import re
import shlex
import sys
from typing import Dict, List

from pyfloyd.analyzer import Grammar
from pyfloyd.formatter import flatten, Comma, Saw, Tree
from pyfloyd.generator import Generator, GeneratorOptions, FormatObj
from pyfloyd.version import __version__
from pyfloyd import string_literal as lit


class PythonGenerator(Generator):
    def __init__(self, grammar: Grammar, options: GeneratorOptions):
        super().__init__(grammar, options)
        self._indent = '    '
        self._methods: Dict[str, List[str]] = {}
        self._operators: Dict[str, str] = {}
        self._map = {
            'end': '',
            'false': 'False',
            'indent': '    ',
            'Infinity': "float('inf')",
            'NaN': "float('NaN')",
            'not': 'not ',
            'null': 'None',
            'true': 'True',
        }

        self._builtin_methods = {}
        more_builtins = self._load_more_builtins()
        for k, v in more_builtins.items():
            self._builtin_methods[k] = self._dedent(v, 1)

    def _gen_text(self) -> str:
        imports = self._imports()

        version = __version__
        args = shlex.join(sys.argv[1:])
        if self._options.main:
            text = self._gen_main_header(version, args, imports)
        else:
            text = self._gen_default_header(version, args, imports)

        if self._grammar.exception_needed:
            text += self._gen_parsing_runtime_exception_class()

        if self._grammar.operators:
            text += self._gen_operator_state_class()

        externs = self._externs()
        text += self._gen_parser_class(externs=externs)

        text += self._state()

        text += self._gen_methods()
        text += self._gen_endclass()

        if self._options.main:
            text += self._gen_main_footer()
        else:
            text += self._gen_default_footer()
        return text

    def _gen_main_header(self, version, args, imports):
        return self._dedent("""\
            #!/usr/bin/env python3
            #
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`
            
            {imports}
            import json
            import re
            from typing import Any, Optional, Dict
            
            Externs = Optional[Dict[str, Any]]
            
            # pylint: disable=too-many-lines
            
            
            def main(
                argv=sys.argv[1:],
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                exists=os.path.exists,
                opener=open,
            ) -> int:
                arg_parser = argparse.ArgumentParser()
                arg_parser.add_argument(
                    '-D',
                    '--define',
                    action='append',
                    metavar='var=val',
                    default=[],
                    help='define an external var=value (may use multiple times)'
                )
                arg_parser.add_argument('file', nargs='?')
                args = arg_parser.parse_args(argv)
            
                if not args.file or args.file[1] == '-':
                    path = '<stdin>'
                    fp = stdin
                elif not exists(args.file):
                    print('Error: file "%s" not found.' % args.file, file=stderr)
                    return 1
                else:
                    path = args.file
                    fp = opener(path)
            
                externs = {{}}
                for d in args.define:
                    k, v = d.split('=', 1)
                    externs[k] = json.loads(v)
            
                msg = fp.read()
                result = parse(msg, path, externs)
                if result.err:
                    print(result.err, file=stderr)
                    return 1
                print(json.dumps(result.val, indent=2), file=stdout)
                return 0
            
            
        """).format(version=version, args=args, imports=imports)

    def _gen_default_header(self, version, args, imports):
        return self._dedent("""\
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`
            
            {imports}
            
            Externs = Optional[Dict[str, Any]]
            
            # pylint: disable=too-many-lines
            
        """).format(version=version, args=args, imports=imports)

    def _gen_parsing_runtime_exception_class(self):
        return self._dedent("""\
            class _ParsingRuntimeError(Exception):
                pass
                

    """)

    def _gen_operator_state_class(self):
        return self._dedent("""\
            class _OperatorState:
                def __init__(self):
                    self.current_depth = 0
                    self.current_prec = 0
                    self.prec_ops = {}
                    self.precs = []
                    self.rassoc = set()
                    self.choices = {}
        """)

    def _gen_parser_class(self, externs):
        return self._dedent("""\
            class Result(NamedTuple):
                \"\"\"The result returned from a `parse()` call.
            
                If the parse is successful, `val` will contain the returned value, if any
                and `pos` will indicate the point in the text where the parser stopped.
                If the parse is unsuccessful, `err` will contain a string describing
                any errors that occurred during the parse and `pos` will indicate
                the location of the farthest error in the text.
                \"\"\"
            
                val: Any = None
                err: Optional[str] = None
                pos: Optional[int] = None
            
            
            def parse(
                text: str, path: str = '<string>', externs: Externs = None
            ) -> Result:
                \"\"\"Parse a given text and return the result.
            
                If the parse was successful, `result.val` will be the returned value
                from the parse, and `result.pos` will indicate where the parser
                stopped when it was done parsing.
            
                If the parse is unsuccessful, `result.err` will be a string describing
                any errors found in the text, and `result.pos` will indicate the
                furthest point reached during the parse.
            
                If the optional `path` is provided it will be used in any error
                messages to indicate the path to the filename containing the given
                text.
                \"\"\"
                return _Parser(text, path).parse(externs)
            
            
            class _Parser:
                def __init__(self, text, path):
                    self._text = text
                    self._end = len(self._text)
                    self._errpos = 0
                    self._externs = {externs}
                    self._failed = False
                    self._path = path
                    self._pos = 0
                    self._val = None
            """).format(externs=externs)

    def _gen_default_footer(self):
        return ''

    def _gen_parse_method(self, exception_needed, starting_rule):
        if exception_needed:
            return self._dedent(f"""\
                def parse(self, externs: Externs = None):
                    errors = ''
                    if externs:
                        for k, v in externs.items():
                            if k in self._externs:
                                self._externs[k] = v
                            else:
                                errors += f'Unexpected extern "{{k}}"\\n'
                    if errors:
                        return Result(None, errors, 0)
                    try:
                        self._r_{starting_rule}()
                        if self._failed:
                            return Result(None, self._error(), self._errpos)
                        return Result(self._val, None, self._pos)
                    except _ParsingRuntimeError as e:  # pragma: no cover
                        lineno, _ = self._offsets(self._errpos)
                        return Result(
                            None,
                            self._path + ':' + str(lineno) + ' ' + str(e),
                            self._errpos,
                        )

                """, level=1)
        else:
            return self._dedent(f"""\
                def parse(self, externs: Externs = None):
                    if externs:
                        for k, v in externs.items():
                            self._externs[k] = v
            
                    self._r_{starting_rule}()
                    if self._failed:
                        return Result(None, self._error(), self._errpos)
                    return Result(self._val, None, self._pos)
            """, level=1)

    def _gen_main_footer(self):
        return self._dedent("""\
            
            
            if __name__ == '__main__':
                sys.exit(main())
        """)

    def _imports(self):
        imports = ''
        if self._options.main:
            imports += 'import argparse\n'
        if self._options.main:
            imports += 'import json\n'
            imports += 'import os\n'
        if self._grammar.re_needed:
            imports += 'import re\n'
        if self._options.main:
            imports += 'import sys\n'
        imports += 'from typing import Any, Dict, NamedTuple, Optional\n'
        if self._unicodedata_needed:
            imports += 'import unicodedata\n'
        return imports

    def _externs(self):
        if self._grammar.externs:
            externs = '{\n            '
            externs += '\n            '.join(
                f"'{k}': {v}," for k, v in self._grammar.externs.items()
            )
            externs += '\n        }'
        else:
            externs = '{}'
        return externs

    def _state(self) -> str:
        text = ''
        if self._options.memoize:
            text += '        self._cache = {}\n'
        if self._grammar.leftrec_needed or self._grammar.operator_needed:
            text += '        self._seeds = {}\n'
        if self._grammar.leftrec_needed:
            text += '        self._blocked = set()\n'
        if self._grammar.re_needed:
            text += '        self._regexps = {}\n'
        if self._grammar.outer_scope_rules:
            text += '        self._scopes = []\n'
        if self._grammar.operator_needed:
            text += self._operator_state()
            text += '\n'
        text += '\n'

        return text

    def _operator_state(self) -> str:
        text = '        self._operators = {}\n'
        for rule, o in self._grammar.operators.items():
            text += '        o = _OperatorState()\n'
            text += '        o.prec_ops = {\n'
            for prec in sorted(o.prec_ops):
                text += '            %d: [' % prec
                text += ', '.join("'%s'" % op for op in o.prec_ops[prec])
                text += '],\n'
            text += '        }\n'
            text += '        o.precs = sorted(o.prec_ops, reverse=True)\n'
            text += '        o.rassoc = set(['
            text += ', '.join("'%s'" % op for op in o.rassoc)
            text += '])\n'
            text += '        o.choices = {\n'
            for op in o.choices:
                text += "            '%s': self._%s,\n" % (op, o.choices[op])
            text += '        }\n'
            text += "        self._operators['%s'] = o\n" % rule
        return text

    def _gen_endclass(self):
        return ''

    def _gen_methods(self) -> str:
        text = self._gen_parse_method(
            exception_needed=self._grammar.exception_needed,
            starting_rule=self._grammar.starting_rule
        )

        text += self._gen_rule_methods()

        text += self._needed_methods()

        if self._grammar.needed_builtin_functions:
            text += '\n'
            text += '\n'.join(
                self._builtin_methods[f'fn_{name}']
                for name in sorted(self._grammar.needed_builtin_functions)
            )
        return text

    def _gen_rule_methods(self):
        text = ''
        for rule, node in self._grammar.rules.items():
            self._current_rule = self._base_rule_name(rule)
            text += self._gen_method_text(rule, self._gen_expr(node))
            self._current_rule = None
        text += '\n'

        if self._grammar.needed_builtin_rules:
            text += '\n'.join(
                self._builtin_methods[f'r_{name}']
                for name in sorted(self._grammar.needed_builtin_rules)
            )
            text += '\n'

        return text

    def _gen_method_text(self, method_name, method_body) -> str:
        text = '\n'
        text += '    def _%s(self):\n' % method_name
        for line in method_body:
            text += f'        {line}\n'
        return text

    def _thisvar(self, v):
        return 'self._' + v

    def _rulename(self, r):
        return 'self._' + r

    def _extern(self, v):
        return "self._externs['" + v + "']"

    def _invoke(self, fn, *args):
        return 'self._' + fn + '(' + ', '.join(args) + ')'

    #
    # Handlers for each non-host node in the glop AST follow.
    #

    def _ty_choice(self, node) -> List[str]:
        lines = ['p = self._pos']
        for subnode in node[2][:-1]:
            lines.extend(self._gen_expr(subnode))
            lines.append('if not self._failed:')
            lines.append('    return')
            lines.append('self._rewind(p)')
        lines.extend(self._gen_expr(node[2][-1]))
        return lines

    def _ty_count(self, node) -> List[str]:
        lines = [
            'vs = []',
            'i = 0',
            f'cmin, cmax = {node[1]}',
            'while i < cmax:',
        ]
        lines.extend(['    ' + line for line in self._gen_expr(node[2][0])])
        lines.extend(
            [
                '    if self._failed:',
                '        if i >= cmin:',
                '            self._succeed(vs)',
                '            return',
                '        return',
                '    vs.append(self._val)',
                '    i += 1',
                'self._succeed(vs)',
            ]
        )
        return lines

    def _ty_ends_in(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = [
            'while True:',
        ] + ['    ' + line for line in sublines]
        if self._can_fail(node[2][0], True):
            lines.extend(['    if not self._failed:', '        break'])
        lines.extend(
            [
                '    self._r_any()',
                '    if self._failed:',
                '        break',
            ]
        )
        return lines

    def _ty_label(self, node) -> List[str]:
        lines = self._gen_expr(node[2][0])
        if self._can_fail(node[2][0], True):
            lines.extend(['if self._failed:', '    return'])
        if self._current_rule in self._grammar.outer_scope_rules:
            lines.extend([f"self._scopes[-1]['{node[1]}'] = self._val"])
        else:
            lines.extend(
                [
                    f'{self._varname(node[1])} = self._val',
                ]
            )
        return lines

    def _ty_not(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = (
            [
                'p = self._pos',
                'errpos = self._errpos',
            ]
            + sublines
            + [
                'if self._failed:',
                '    self._succeed(None, p)',
                'else:',
                '    self._rewind(p)',
                '    self._errpos = errpos',
                '    self._fail()',
            ]
        )
        return lines

    def _ty_not_one(self, node) -> List[str]:
        sublines = self._gen_expr(['not', None, node[2]])
        return sublines + ['if not self._failed:', '    self._r_any()']

    def _ty_opt(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = (
            [
                'p = self._pos',
            ]
            + sublines
            + [
                'if self._failed:',
                '    self._succeed([], p)',
                'else:',
                '    self._succeed([self._val])',
            ]
        )
        return lines

    def _ty_paren(self, node) -> List[str]:
        return self._gen_expr(node[2][0])

    def _ty_plus(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = (
            ['vs = []']
            + sublines
            + [
                'if self._failed:',
                '    return',
                'vs.append(self._val)',
                'while True:',
                '    p = self._pos',
            ]
            + ['    ' + line for line in sublines]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )

        return lines

    def _ty_pred(self, node) -> List[str]:
        arg = self._gen_expr(node[2][0])
        return [
            'v = ' + flatten(arg, indent=self._map['indent'])[0],
            'if v is True:',
            '    self._succeed(v)',
            'elif v is False:',
            '    self._fail()',
            'else:',
            "    raise _ParsingRuntimeError('Bad predicate value')",
        ]

    def _ty_regexp(self, node) -> List[str]:
        return [
            f'p = {lit.encode(node[1])}',
            'if p not in self._regexps:',
            '    self._regexps[p] = re.compile(p)',
            'm = self._regexps[p].match(self._text, self._pos)',
            'if m:',
            '    self._succeed(m.group(0), m.end())',
            '    return',
            'self._fail()',
        ]

    def _ty_run(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = ['start = self._pos'] + sublines
        if self._can_fail(node[2][0], True):
            lines.extend(['if self._failed:', '    return'])
        lines.extend(
            [
                'end = self._pos',
                'self._val = self._text[start:end]',
            ]
        )
        return lines

    def _ty_scope(self, node) -> List[str]:
        return (
            [
                'self._scopes.append({})',
            ]
            + self._gen_expr(node[2][0])
            + [
                'self._scopes.pop()',
            ]
        )

    def _ty_seq(self, node) -> List[str]:
        lines = self._gen_expr(node[2][0])
        if self._can_fail(node[2][0], inline=True):
            lines.extend(['if self._failed: return'])
        for subnode in node[2][1:-1]:
            lines.extend(self._gen_expr(subnode))
            if self._can_fail(subnode, inline=True):
                lines.extend(['if self._failed: return'])
        lines.extend(self._gen_expr(node[2][-1]))
        return lines

    def _ty_star(self, node) -> List[str]:
        sublines = self._gen_expr(node[2][0])
        lines = (
            [
                'vs = []',
                'while True:',
                '    p = self._pos',
            ]
            + ['    ' + line for line in sublines]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )
        return lines

    def _load_builtins(self):
        return {
            'r_any': """\
                def _r_any(self):
                    if self._pos < self._end:
                        self._succeed(self._text[self._pos], self._pos + 1)
                    else:
                        self._fail()
                """,
            'r_end': """\
                def _r_end(self):
                    if self._pos == self._end:
                        self._succeed(None)
                    else:
                        self._fail()
                """,
            'ch': """\
                def _ch(self, ch):
                    p = self._pos
                    if p < self._end and self._text[p] == ch:
                        self._succeed(ch, self._pos + 1)
                    else:
                        self._fail()
                """,
            'offsets': """\
                def _offsets(self, pos):
                    lineno = 1
                    colno = 1
                    for i in range(pos):
                        if self._text[i] == '\\n':
                            lineno += 1
                            colno = 1
                        else:
                            colno += 1
                    return lineno, colno
                """,
            'error': """\
                def _error(self):
                    lineno, colno = self._offsets(self._errpos)
                    if self._errpos == len(self._text):
                        thing = 'end of input'
                    else:
                        thing = repr(self._text[self._errpos]).replace("'", '"')
                    return '%s:%d Unexpected %s at column %d' % (
                        self._path,
                        lineno,
                        thing,
                        colno,
                    )
                """,
            'fail': """\
                def _fail(self):
                    self._val = None
                    self._failed = True
                    self._errpos = max(self._errpos, self._pos)
                """,
            'leftrec': """\
                def _leftrec(self, rule, rule_name, left_assoc):
                    pos = self._pos
                    key = (rule_name, pos)
                    seed = self._seeds.get(key)
                    if seed:
                        self._val, self._failed, self._pos = seed
                        return
                    if rule_name in self._blocked:
                        self._val = None
                        self._failed = True
                        return
                    current = (None, True, self._pos)
                    self._seeds[key] = current
                    if left_assoc:
                        self._blocked.add(rule_name)
                    while True:
                        rule()
                        if self._pos > current[2]:
                            current = (self._val, self._failed, self._pos)
                            self._seeds[key] = current
                            self._pos = pos
                        else:
                            del self._seeds[key]
                            self._val, self._failed, self._pos = current
                            if left_assoc:
                                self._blocked.remove(rule_name)
                            return
                """,

            'lookup': """\
                def _lookup(self, var):
                    l = len(self._scopes) - 1
                    while l >= 0:
                        if var in self._scopes[l]:
                            return self._scopes[l][var]
                        l -= 1
                    if var in self._externs:
                        return self._externs[var]
                    assert False, f'unknown var {var}'
                """,
            'memoize': """\
                def _memoize(self, rule_name, fn):
                    p = self._pos
                    r = self._cache.setdefault(p, {}).get(rule_name)
                    if r:
                        self._val, self._failed, self._pos = r
                        return
                    fn()
                    self._cache[p][rule_name] = (self._val, self._failed, self._pos)
                """,

            'operator': """\
                def _operator(self, rule_name):
                    o = self._operators[rule_name]
                    pos = self._pos
                    key = (rule_name, self._pos)
                    seed = self._seeds.get(key)
                    if seed:
                        self._val, self._failed, self._pos = seed
                        return
                    o.current_depth += 1
                    current = (None, True, self._pos)
                    self._seeds[key] = current
                    min_prec = o.current_prec
                    i = 0
                    while i < len(o.precs):
                        repeat = False
                        prec = o.precs[i]
                        prec_ops = o.prec_ops[prec]
                        if prec < min_prec:
                            break
                        o.current_prec = prec
                        if prec_ops[0] not in o.rassoc:
                            o.current_prec += 1
                        for j, _ in enumerate(prec_ops):
                            op = prec_ops[j]
                            o.choices[op]()
                            if not self._failed and self._pos > pos:
                                current = (self._val, self._failed, self._pos)
                                self._seeds[key] = current
                                repeat = True
                                break
                            self._rewind(pos)
                        if not repeat:
                            i += 1
            
                    del self._seeds[key]
                    o.current_depth -= 1
                    if o.current_depth == 0:
                        o.current_prec = 0
                    self._val, self._failed, self._pos = current
                """,

            'range': """\
                def _range(self, i, j):
                    p = self._pos
                    if p != self._end and ord(i) <= ord(self._text[p]) <= ord(j):
                        self._succeed(self._text[p], self._pos + 1)
                    else:
                        self._fail()
            """,
            'rewind': """\
                def _rewind(self, newpos):
                    self._succeed(None, newpos)
            """,
            'str': """\
                def _str(self, s):
                    for ch in s:
                        self._ch(ch)
                        if self._failed:
                            return
                    self._val = s
            """,
            'succeed': """\
                def _succeed(self, v, newpos=None):
                    self._val = v
                    self._failed = False
                    if newpos is not None:
                        self._pos = newpos
            """,
            'unicat': """\
                def _unicat(self, cat):
                    p = self._pos
                    if p < self._end and unicodedata.category(self._text[p]) == cat:
                        self._succeed(self._text[p], self._pos + 1)
                    else:
                        self._fail()
            """,
            'fn_atof': """\
                def _fn_atof(self, s):
                    if '.' in s or 'e' in s or 'E' in s:
                        return float(s)
                    return int(s)
            """,
            'fn_atoi': """\
                def _fn_atoi(self, a, base):
                    return int(a, base)
            """,
            'fn_atou': """\
                def _fn_atou(self, a, base):
                    return chr(int(a, base))
            """,
            'fn_cat': """\
                def _fn_cat(self, strs):
                    return ''.join(strs)
            """,
            'fn_concat': """\
                def _fn_concat(self, xs, ys):
                    return xs + ys
            """,
            'fn_cons': """\
                def _fn_cons(self, hd, tl):
                    return [hd] + tl
            """,
            'fn_dedent': """\
                def _fn_dedent(self, s):
                    return s
            """,
            'fn_dict': """\
                def _fn_dict(self, pairs):
                    return dict(pairs)
            """,
            'fn_itou': """\
                def _fn_itou(self, n):
                    return chr(n)
            """,
            'fn_join': """\
                def _fn_join(self, s, vs):
                    return s.join(vs)
            """,
            'fn_otou': """\
                def _fn_otou(self, s):
                    return chr(int(s, base=8))
            """,
            'fn_scat': """\
                def _fn_scat(self, hd, tl):
                    return self._fn_cat(self._fn_cons(hd, tl))
            """,
            'fn_scons': """\
                def _fn_scons(self, hd, tl):
                    return [hd] + tl
            """,
            'fn_strcat': """\
                def _fn_strcat(self, a, b):
                    return a + b
            """,
            'fn_unicode_lookup': """\
                def _fn_unicode_lookup(self, s):
                    return unicodedata.unicode_lookup(s)
            """,
            'fn_utoi': """\
                def _fn_utoi(self, s):
                    return ord(s)
            """,
            'fn_xtoi': """\
                def _fn_xtoi(self, s):
                    return int(s, base=16)
            """,
            'fn_xtou': """\
                def _fn_xtou(self, s):
                    return chr(int(s, base=16))
            """,
        }
