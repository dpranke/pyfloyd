# Copyright 2024 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 as found in the LICENSE file.
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-lines

from pyfloyd import datafile
from pyfloyd import formatter
from pyfloyd import generator
from pyfloyd import grammar as gram
from pyfloyd import hard_coded_generator
from pyfloyd import support


class PythonGenerator(hard_coded_generator.HardCodedGenerator):
    name = 'Python'
    ext = 'py'
    line_length = 79
    indent = 4

    def __init__(
        self,
        host: support.Host,
        grammar: gram.Grammar,
        options: generator.GeneratorOptions,
    ):
        super().__init__(host, grammar, options)
        self._indent = '    '
        self._map = {
            'end': '',
            'false': 'False',
            'indent': '    ',
            'Infinity': "float('inf')",
            'NaN': "float('NaN')",
            'not': 'not ',
            'null': 'None',
            'true': 'True',
        }

        self._builtin_methods = {}
        for k, v in _BUILTINS.items():
            self._builtin_methods[k] = datafile.dedent(v)

        # Python doesn't need to declare local vars.
        self._local_vars = {}

    def generate(self) -> str:
        vl = formatter.VList()
        if self.options.main:
            vl += self._gen_main_header(
                self.options.version, self.options.command_line
            )
        else:
            vl += self._gen_default_header(
                self.options.version, self.options.command_line
            )

        if self.grammar.exception_needed:
            vl += ''
            vl += ''
            vl += self._gen_parsing_runtime_exception_class()

        if self.grammar.operators:
            vl += ''
            vl += ''
            vl += self._gen_operator_state_class()

        vl += ''
        vl += ''
        vl += self._gen_result_class()
        vl += ''
        vl += ''
        vl += self._gen_parse_function()
        vl += ''
        vl += ''
        vl += self._gen_parser_class()

        if self.options.main:
            vl += self._gen_main_footer()
        else:
            vl += self._gen_default_footer()
        return self._fmt(vl)

    def _gen_main_header(self, version, args) -> formatter.FormatObj:
        imports = self._fmt(self._gen_imports())
        return self._defmtf(
            """
            #!/usr/bin/env python3
            #
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`

            {imports}

            Externs = Optional[Dict[str, Any]]

            # pylint: disable=too-many-lines


            def main(
                argv=sys.argv[1:],
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                exists=os.path.exists,
                opener=open,
            ) -> int:
                arg_parser = argparse.ArgumentParser()
                arg_parser.add_argument('-c', '--code')
                arg_parser.add_argument(
                    '-D',
                    '--define',
                    action='append',
                    metavar='var=val',
                    default=[],
                    help='define an external var=value (may use multiple times)'
                )
                arg_parser.add_argument('file', nargs='?')
                args = arg_parser.parse_args(argv)

                if args.code is not None:
                    msg = args.code
                    path = '<code>'
                elif not args.file or args.file[1] == '-':
                    path = '<stdin>'
                    fp = stdin
                elif not exists(args.file):
                    print('Error: file "%s" not found.' % args.file, file=stderr)
                    return 1
                else:
                    path = args.file
                    fp = opener(path)

                externs = {{}}
                for d in args.define:
                    k, v = d.split('=', 1)
                    externs[k] = json.loads(v)

                if args.code is None:
                    msg = fp.read()
                result = parse(msg, path, externs)
                if result.err:
                    print(result.err, file=stderr)
                    return 1
                print(json.dumps(result.val, indent=2), file=stdout)
                return 0
            """,
            imports=imports,
            args=args,
            version=version,
        )

    def _gen_default_header(self, version, args) -> formatter.FormatObj:
        imports = self._fmt(self._gen_imports())
        return self._defmtf(
            """
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`

            {imports}

            Externs = Optional[Dict[str, Any]]

            # pylint: disable=too-many-lines
            """,
            imports=imports,
            version=version,
            args=args,
        )

    def _gen_imports(self) -> formatter.FormatObj:
        vl = formatter.VList()
        if self.options.main:
            vl += 'import argparse'
        if self.options.main:
            vl += 'import json'
            vl += 'import os'
        if self.grammar.re_needed:
            vl += 'import re'
        if self.options.main:
            vl += 'import sys'
        vl += 'from typing import Any, Dict, NamedTuple, Optional'
        if self.options.unicodedata_needed:
            vl += 'import unicodedata'
        return vl

    def _gen_parsing_runtime_exception_class(self) -> formatter.FormatObj:
        return self._defmt("""
            class _ParsingRuntimeError(Exception):
                pass
            """)

    def _gen_operator_state_class(self) -> formatter.FormatObj:
        return self._defmt("""
            class _OperatorState:
                def __init__(self):
                    self.current_depth = 0
                    self.current_prec = 0
                    self.prec_ops = {}
                    self.precs = []
                    self.rassoc = set()
                    self.choices = {}
            """)

    def _gen_result_class(self) -> formatter.FormatObj:
        return self._defmt("""
            class Result(NamedTuple):
                \"\"\"The result returned from a `parse()` call.

                If the parse is successful, `val` will contain the returned value, if any
                and `pos` will indicate the point in the text where the parser stopped.
                If the parse is unsuccessful, `err` will contain a string describing
                any errors that occurred during the parse and `pos` will indicate
                the location of the farthest error in the text.
                \"\"\"

                val: Any = None
                err: Optional[str] = None
                pos: Optional[int] = None
            """)

    def _gen_parse_function(self) -> formatter.FormatObj:
        return self._defmt("""
            def parse(
                text: str, path: str = '<string>', externs: Externs = None, start: int = 0
            ) -> Result:
                \"\"\"Parse a given text and return the result.

                If the parse was successful, `result.val` will be the returned value
                from the parse, and `result.pos` will indicate where the parser
                stopped when it was done parsing.

                If the parse is unsuccessful, `result.err` will be a string describing
                any errors found in the text, and `result.pos` will indicate the
                furthest point reached during the parse.

                If the optional `path` is provided it will be used in any error
                messages to indicate the path to the filename containing the given
                text.
                \"\"\"
                return _Parser(text, path).parse(externs, start)
            """)

    def _gen_parser_class(self) -> formatter.FormatObj:
        vl = self._defmt("""
            class _Parser:
            """)

        methods = self._gen_constructor()
        methods += ''
        methods += self._gen_methods()
        vl += formatter.Indent(methods)
        return vl

    def _gen_constructor(self) -> formatter.VList:
        obj = formatter.VList(['def __init__(self, text, path):'])

        vl = self._defmt("""
            self._text = text
            self._end = len(self._text)
            self._errpos = 0
            self._failed = False
            self._path = path
            self._pos = 0
            self._val = None
            """)

        if self.grammar.externs:
            vl += 'self._externs = {'
            for k, v in self.grammar.externs.items():
                vl += f"    '{k}': {v},"
            vl += '}'
        else:
            vl += 'self._externs = {}'

        if self.options.memoize:
            vl += 'self._cache = {}'
        if self.grammar.leftrec_needed or self.grammar.operator_needed:
            vl += 'self._seeds = {}'
        if self.grammar.leftrec_needed:
            vl += 'self._blocked = set()'
        if self.grammar.re_needed:
            vl += 'self._regexps = {}'
        if self.grammar.lookup_needed:
            vl += 'self._scopes = []'
        if self.grammar.operator_needed:
            vl += self._gen_operator_state()
        obj += formatter.Indent(vl)
        return obj

    def _gen_operator_state(self) -> formatter.FormatObj:
        vl = formatter.VList()
        vl += 'self._operators = {}'
        for rule, o in self.grammar.operators.items():
            vl += 'o = _OperatorState()'
            vl += 'o.prec_ops = {'
            text = ''
            for prec in sorted(o.prec_ops):
                text += '    ' + str(prec) + ': ['
                text += ', '.join("'" + op + "'" for op in o.prec_ops[prec])
                text += '],\n'
            vl += formatter.Indent(formatter.VList(text.splitlines()))
            vl += '}'
            vl += 'o.precs = sorted(o.prec_ops, reverse=True)'
            vl += (
                'o.rassoc = set(['
                + ', '.join("'" + op + "'" for op in o.rassoc)
                + '])'
            )
            vl += 'o.choices = {'
            choices = formatter.VList()
            for op in o.choices:
                choices += "'" + op + "': self._" + o.choices[op] + ','
            vl += formatter.Indent(choices)
            vl += '}'
            vl += "self._operators['" + rule + "'] = o"
        return vl

    def _gen_methods(self) -> formatter.FormatObj:
        vobj = formatter.VList()
        vobj += self._gen_parse_method(
            exception_needed=self.grammar.exception_needed,
            starting_rule=self.grammar.starting_rule,
        )

        vobj += self._gen_rule_methods()

        vobj += self._gen_needed_methods()

        for name in self.grammar.needed_builtin_functions:
            vobj += ''
            vobj += self._defmt(
                self._builtin_methods[f'fn_{name}'], dedented=True
            )

        return vobj

    def _gen_parse_method(
        self, exception_needed, starting_rule
    ) -> formatter.VList:
        if exception_needed:
            return self._defmt(
                f"""
                def parse(self, externs: Externs = None, start: int = 0):
                    self._pos = start
                    errors = ''
                    if externs:
                        for k, v in externs.items():
                            if k in self._externs:
                                self._externs[k] = v
                            else:
                                errors += f'Unexpected extern "{{k}}"\\n'
                    if errors:
                        return Result(None, errors, 0)
                    try:
                        self._r_{starting_rule}()

                        if self._failed:
                            return Result(None, self._error(), self._errpos)
                        return Result(self._val, None, self._pos)
                    except _ParsingRuntimeError as e:  # pragma: no cover
                        lineno, _ = self._offsets(self._errpos)
                        return Result(
                            None,
                            self._path + ':' + str(lineno) + ' ' + str(e),
                            self._errpos,
                        )
                """
            )
        return self._defmt(
            f"""
            def parse(self, externs: Externs = None, start: int = 0):
                self._pos = start
                if externs:
                    for k, v in externs.items():
                        self._externs[k] = v

                self._r_{starting_rule}()

                if self._failed:
                    return Result(None, self._error(), self._errpos)
                return Result(self._val, None, self._pos)
            """
        )

    def _gen_rule_methods(self) -> formatter.VList:
        obj = formatter.VList()
        for rule, node in self.grammar.rules.items():
            obj += ''
            obj += self._gen_method_text(rule, node)

        if self.grammar.needed_builtin_rules:
            for name in sorted(self.grammar.needed_builtin_rules):
                obj += ''
                obj += self._defmt(
                    self._builtin_methods[f'r_{name}'], dedented=True
                )
        return obj

    def _gen_method_text(
        self, method_name: str, node: gram.Node
    ) -> formatter.VList:
        return formatter.VList(
            [
                formatter.HList(['def _', method_name, '(self):']),
                formatter.Indent(self._gen_stmts(node)),
            ]
        )

    def _gen_thisvar(self, name: str) -> str:
        return 'self._' + name

    def _gen_rulename(self, name: str) -> str:
        return 'self._' + name

    def _gen_extern(self, name: str) -> str:
        return "self._externs['" + name + "']"

    def _gen_invoke(self, fn, *args) -> formatter.Saw:
        return formatter.Saw('self._' + fn + '(', formatter.Comma(args), ')')

    #
    # Handlers for each non-host node in the glop AST follow.
    #

    def _ty_choice(self, node: gram.Node) -> formatter.ListObj:
        vl = formatter.VList(['p = self._pos'])
        for subnode in node.ch[:-1]:
            vl += self._gen_stmts(subnode)
            vl += 'if not self._failed:'
            vl += '    return'
            vl += 'self._rewind(p)'
        vl += self._gen_stmts(node.ch[-1])
        return vl

    def _ty_count(self, node: gram.Node) -> formatter.ListObj:
        vl = formatter.VList(
            [
                'vs = []',
                'i = 0',
                f'cmin, cmax = {node.v}',
                'while i < cmax:',
            ]
        )
        svl = self._gen_stmts(node.child)
        svl += 'if self._failed:'
        svl += '    if i >= cmin:'
        svl += '        self._succeed(vs)'
        svl += '        return'
        svl += '    return'
        svl += 'vs.append(self._val)'
        svl += 'i += 1'

        vl += formatter.Indent(svl)
        vl += 'self._succeed(vs)'
        return vl

    def _ty_ends_in(self, node: gram.Node) -> formatter.ListObj:
        sublines = self._gen_stmts(node.child)
        lines = [
            'while True:',
        ] + [formatter.Indent(sublines)]
        if node.can_fail:
            lines.extend(['    if not self._failed:', '        break'])
        lines.extend(
            [
                '    self._r_any()',
                '    if self._failed:',
                '        break',
            ]
        )
        return formatter.VList(lines)

    def _ty_label(self, node: gram.Node) -> formatter.ListObj:
        assert isinstance(node, gram.Label)
        lines: formatter.ElList = [self._gen_stmts(node.child)]
        if node.child.can_fail:
            lines.extend(['if self._failed:', '    return'])
        if node.outer_scope:
            lines.extend([f"self._scopes[-1]['{node.name}'] = self._val"])
        else:
            lines.extend(
                [
                    f'{self._gen_varname(node.name)} = self._val',
                ]
            )
        return formatter.VList(lines)

    def _ty_not(self, node: gram.Node) -> formatter.ListObj:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'p = self._pos',
                'errpos = self._errpos',
            ]
            + [sublines]
            + [
                'if self._failed:',
                '    self._succeed(None, p)',
                'else:',
                '    self._rewind(p)',
                '    self._errpos = errpos',
                '    self._fail()',
            ]
        )
        return formatter.VList(lines)

    def _ty_not_one(self, node: gram.Node) -> formatter.ListObj:
        sublines = self._gen_stmts(self.grammar.node(gram.Not, node.child))
        return formatter.VList(
            [sublines, 'if not self._failed:', '    self._r_any()']
        )

    def _ty_opt(self, node: gram.Node) -> formatter.ListObj:
        sublines = self._gen_stmts(node.child)
        return formatter.VList(
            [
                'p = self._pos',
            ]
            + [sublines]
            + [
                'if self._failed:',
                '    self._succeed([], p)',
                'else:',
                '    self._succeed([self._val])',
            ]
        )

    def _ty_paren(self, node: gram.Node) -> formatter.ListObj:
        return self._gen_stmts(node.child)

    def _ty_plus(self, node: gram.Node) -> formatter.ListObj:
        sublines = self._gen_stmts(node.child)
        lines = (
            ['vs = []']
            + [sublines]
            + [
                'if self._failed:',
                '    return',
                'vs.append(self._val)',
                'while True:',
                '    p = self._pos',
            ]
            + [formatter.Indent(sublines)]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )

        return formatter.VList(lines)

    def _ty_pred(self, node: gram.Node) -> formatter.ListObj:
        arg = self._gen_expr(node.child)
        return formatter.VList(
            [
                formatter.HList(['v = ', arg]),
                'if v is True:',
                '    self._succeed(v)',
                'elif v is False:',
                '    self._fail()',
                'else:',
                "    raise _ParsingRuntimeError('Bad predicate value')",
            ]
        )

    def _ty_regexp(self, node: gram.Node) -> formatter.ListObj:
        return formatter.VList(
            [
                f'p = {self._gen_lit(node.v)}',
                'if p not in self._regexps:',
                '    self._regexps[p] = re.compile(p)',
                'm = self._regexps[p].match(self._text, self._pos)',
                'if m:',
                '    self._succeed(m.group(0), m.end())',
                '    return',
                'self._fail()',
            ]
        )

    def _ty_run(self, node: gram.Node) -> formatter.VList:
        sublines = self._gen_stmts(node.child)
        lines = ['start = self._pos'] + [sublines]
        if node.child.can_fail:
            lines.extend(['if self._failed:', '    return'])
        lines.extend(
            [
                'end = self._pos',
                'self._val = self._text[start:end]',
            ]
        )
        return formatter.VList(lines)

    def _ty_scope(self, node: gram.Node) -> formatter.VList:
        return formatter.VList(
            [
                'self._scopes.append({})',
            ]
            + [self._gen_stmts(node.child)]
            + [
                'self._scopes.pop()',
            ]
        )

    def _ty_seq(self, node: gram.Node) -> formatter.VList:
        lines: formatter.ElList = [self._gen_stmts(node.ch[0])]
        if node.ch[0].can_fail:
            lines.extend(['if self._failed:', '    return'])
        for subnode in node.ch[1:-1]:
            lines.append(self._gen_stmts(subnode))
            if subnode.can_fail:
                lines.extend(['if self._failed:', '    return'])
        lines.append(self._gen_stmts(node.ch[-1]))
        return formatter.VList(lines)

    def _ty_star(self, node: gram.Node) -> formatter.VList:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'vs = []',
                'while True:',
                '    p = self._pos',
            ]
            + [formatter.Indent(sublines)]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )
        return formatter.VList(lines)

    def _gen_main_footer(self) -> formatter.VList:
        return self._defmt("""


            if __name__ == '__main__':
                sys.exit(main())
            """)

    def _gen_default_footer(self) -> formatter.VList:
        return formatter.VList()


_BUILTINS = {
    'r_any': """
        def _r_any(self):
            if self._pos < self._end:
                self._succeed(self._text[self._pos], self._pos + 1)
            else:
                self._fail()
        """,
    'r_end': """
        def _r_end(self):
            if self._pos == self._end:
                self._succeed(None)
            else:
                self._fail()
        """,
    'ch': """
        def _ch(self, ch):
            p = self._pos
            if p < self._end and self._text[p] == ch:
                self._succeed(ch, self._pos + 1)
            else:
                self._fail()
        """,
    'offsets': """
        def _offsets(self, pos):
            lineno = 1
            colno = 1
            for i in range(pos):
                if self._text[i] == '\\n':
                    lineno += 1
                    colno = 1
                else:
                    colno += 1
            return lineno, colno
        """,
    'error': """
        def _error(self):
            lineno, colno = self._offsets(self._errpos)
            if self._errpos == len(self._text):
                thing = 'end of input'
            else:
                thing = '"' + self._text[self._errpos] + '"'
            path = self._path
            return f'{path}:{lineno} Unexpected {thing} at column {colno}'
        """,
    'fail': """
        def _fail(self):
            self._val = None
            self._failed = True
            self._errpos = max(self._errpos, self._pos)
        """,
    'leftrec': """
        def _leftrec(self, rule, rule_name, left_assoc):
            pos = self._pos
            key = (rule_name, pos)
            seed = self._seeds.get(key)
            if seed:
                self._val, self._failed, self._pos = seed
                return
            if rule_name in self._blocked:
                self._val = None
                self._failed = True
                return
            current = (None, True, self._pos)
            self._seeds[key] = current
            if left_assoc:
                self._blocked.add(rule_name)
            while True:
                rule()
                if self._pos > current[2]:
                    current = (self._val, self._failed, self._pos)
                    self._seeds[key] = current
                    self._pos = pos
                else:
                    del self._seeds[key]
                    self._val, self._failed, self._pos = current
                    if left_assoc:
                        self._blocked.remove(rule_name)
                    return
        """,
    'lookup': """
        def _lookup(self, var):
            i = len(self._scopes) - 1
            while i >= 0:
                if var in self._scopes[i]:
                    return self._scopes[i][var]
                i -= 1
            if var in self._externs:
                return self._externs[var]
            assert False, f'unknown var {var}'
        """,
    'memoize': """
        def _memoize(self, rule_name, fn):
            p = self._pos
            r = self._cache.setdefault(p, {}).get(rule_name)
            if r:
                self._val, self._failed, self._pos = r
                return
            fn()
            self._cache[p][rule_name] = (self._val, self._failed, self._pos)
        """,
    'operator': """
        def _operator(self, rule_name):
            o = self._operators[rule_name]
            pos = self._pos
            key = (rule_name, self._pos)
            seed = self._seeds.get(key)
            if seed:
                self._val, self._failed, self._pos = seed
                return
            o.current_depth += 1
            current = (None, True, self._pos)
            self._seeds[key] = current
            min_prec = o.current_prec
            i = 0
            while i < len(o.precs):
                repeat = False
                prec = o.precs[i]
                prec_ops = o.prec_ops[prec]
                if prec < min_prec:
                    break
                o.current_prec = prec
                if prec_ops[0] not in o.rassoc:
                    o.current_prec += 1
                for j, _ in enumerate(prec_ops):
                    op = prec_ops[j]
                    o.choices[op]()
                    if not self._failed and self._pos > pos:
                        current = (self._val, self._failed, self._pos)
                        self._seeds[key] = current
                        repeat = True
                        break
                    self._rewind(pos)
                if not repeat:
                    i += 1

            del self._seeds[key]
            o.current_depth -= 1
            if o.current_depth == 0:
                o.current_prec = 0
            self._val, self._failed, self._pos = current
        """,
    'range': """
        def _range(self, i, j):
            p = self._pos
            if p != self._end and ord(i) <= ord(self._text[p]) <= ord(j):
                self._succeed(self._text[p], self._pos + 1)
            else:
                self._fail()
        """,
    'rewind': """
        def _rewind(self, newpos):
            self._succeed(None, newpos)
        """,
    'str': """
        def _str(self, s):
            for ch in s:
                self._ch(ch)
                if self._failed:
                    return
            self._val = s
        """,
    'succeed': """
        def _succeed(self, v, newpos=None):
            self._val = v
            self._failed = False
            if newpos is not None:
                self._pos = newpos
        """,
    'unicat': """
        def _unicat(self, cat):
            p = self._pos
            if p < self._end and unicodedata.category(self._text[p]) == cat:
                self._succeed(self._text[p], self._pos + 1)
            else:
                self._fail()
        """,
    'fn_atof': """
        def _fn_atof(self, s):
            if '.' in s or 'e' in s or 'E' in s:
                return float(s)
            return int(s)
        """,
    'fn_atoi': """
        def _fn_atoi(self, a, base):
            return int(a, base)
        """,
    'fn_atou': """
        def _fn_atou(self, a, base):
            return chr(int(a, base))
        """,
    'fn_cat': """
        def _fn_cat(self, strs):
            return ''.join(strs)
        """,
    'fn_concat': """
        def _fn_concat(self, xs, ys):
            return xs + ys
        """,
    'fn_cons': """
        def _fn_cons(self, hd, tl):
            return [hd] + tl
        """,
    'fn_dedent': """
        def _fn_dedent(self, s):
            return s
        """,
    'fn_dict': """
        def _fn_dict(self, pairs):
            return dict(pairs)
        """,
    'fn_itou': """
        def _fn_itou(self, n):
            return chr(n)
        """,
    'fn_join': """
        def _fn_join(self, s, vs):
            return s.join(vs)
        """,
    'fn_otou': """
        def _fn_otou(self, s):
            return chr(int(s, base=8))
        """,
    'fn_scat': """
        def _fn_scat(self, hd, tl):
            return self._fn_cat(self._fn_cons(hd, tl))
        """,
    'fn_scons': """
        def _fn_scons(self, hd, tl):
            return [hd] + tl
        """,
    'fn_strcat': """
        def _fn_strcat(self, a, b):
            return a + b
        """,
    'fn_unicode_lookup': """
        def _fn_unicode_lookup(self, s):
            return unicodedata.lookup(s)
        """,
    'fn_utoi': """
        def _fn_utoi(self, s):
            return ord(s)
        """,
    'fn_xtoi': """
        def _fn_xtoi(self, s):
            return int(s, base=16)
        """,
    'fn_xtou': """
        def _fn_xtou(self, s):
            return chr(int(s, base=16))
        """,
}
