# Copyright 2024 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 as found in the LICENSE file.
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=too-many-lines

from pyfloyd.analyzer import Grammar, Node
from pyfloyd.ast import Not, Label
from pyfloyd.formatter import (
    Comma,
    ElList,
    FormatObj,
    HList,
    Indent,
    ListObj,
    Saw,
    VList,
)
from pyfloyd.generator import Generator, GeneratorOptions


class PythonGenerator(Generator):
    def __init__(self, grammar: Grammar, options: GeneratorOptions):
        super().__init__(grammar, options)
        self._indent = '    '
        self._map = {
            'end': '',
            'false': 'False',
            'indent': '    ',
            'Infinity': "float('inf')",
            'NaN': "float('NaN')",
            'not': 'not ',
            'null': 'None',
            'true': 'True',
        }

        self._builtin_methods = {}
        for k, v in _BUILTINS.items():
            self._builtin_methods[k] = v

        # Python doesn't need to declare local vars.
        self._local_vars = {}

    def generate(self) -> str:
        vl = VList()
        if self._options.main:
            vl += self._gen_main_header(
                self._options.version, self._options.args
            )
        else:
            vl += self._gen_default_header(
                self._options.version, self._options.args
            )

        if self._grammar.exception_needed:
            vl += ''
            vl += ''
            vl += self._gen_parsing_runtime_exception_class()

        if self._grammar.operators:
            vl += ''
            vl += ''
            vl += self._gen_operator_state_class()

        vl += ''
        vl += ''
        vl += self._gen_result_class()
        vl += ''
        vl += ''
        vl += self._gen_parse_function()
        vl += ''
        vl += ''
        vl += self._gen_parser_class()

        if self._options.main:
            vl += self._gen_main_footer()
        else:
            vl += self._gen_default_footer()
        return self._fmt(vl)

    def _gen_main_header(self, version, args) -> FormatObj:
        imports = self._fmt(self._gen_imports())
        return self._defmtf(
            """\
            #!/usr/bin/env python3
            #
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`

            {imports}

            Externs = Optional[Dict[str, Any]]

            # pylint: disable=too-many-lines


            def main(
                argv=sys.argv[1:],
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                exists=os.path.exists,
                opener=open,
            ) -> int:
                arg_parser = argparse.ArgumentParser()
                arg_parser.add_argument(
                    '-D',
                    '--define',
                    action='append',
                    metavar='var=val',
                    default=[],
                    help='define an external var=value (may use multiple times)'
                )
                arg_parser.add_argument('file', nargs='?')
                args = arg_parser.parse_args(argv)

                if not args.file or args.file[1] == '-':
                    path = '<stdin>'
                    fp = stdin
                elif not exists(args.file):
                    print('Error: file "%s" not found.' % args.file, file=stderr)
                    return 1
                else:
                    path = args.file
                    fp = opener(path)

                externs = {{}}
                for d in args.define:
                    k, v = d.split('=', 1)
                    externs[k] = json.loads(v)

                msg = fp.read()
                result = parse(msg, path, externs)
                if result.err:
                    print(result.err, file=stderr)
                    return 1
                print(json.dumps(result.val, indent=2), file=stdout)
                return 0
            """,
            imports=imports,
            args=args,
            version=version,
        )

    def _gen_default_header(self, version, args) -> FormatObj:
        imports = self._fmt(self._gen_imports())
        return self._defmtf(
            """\
            # Generated by pyfloyd version {version}
            #    https://github.com/dpranke/pyfloyd
            #    `pyfloyd {args}`

            {imports}

            Externs = Optional[Dict[str, Any]]

            # pylint: disable=too-many-lines
            """,
            imports=imports,
            version=version,
            args=args,
        )

    def _gen_imports(self) -> FormatObj:
        vl = VList()
        if self._options.main:
            vl += 'import argparse'
        if self._options.main:
            vl += 'import json'
            vl += 'import os'
        if self._grammar.re_needed:
            vl += 'import re'
        if self._options.main:
            vl += 'import sys'
        vl += 'from typing import Any, Dict, NamedTuple, Optional'
        if self._unicodedata_needed:
            vl += 'import unicodedata'
        return vl

    def _gen_parsing_runtime_exception_class(self) -> FormatObj:
        return self._defmt("""\
            class _ParsingRuntimeError(Exception):
                pass
    """)

    def _gen_operator_state_class(self) -> FormatObj:
        return self._defmt("""\
            class _OperatorState:
                def __init__(self):
                    self.current_depth = 0
                    self.current_prec = 0
                    self.prec_ops = {}
                    self.precs = []
                    self.rassoc = set()
                    self.choices = {}
        """)

    def _gen_result_class(self) -> FormatObj:
        return self._defmt("""\
            class Result(NamedTuple):
                \"\"\"The result returned from a `parse()` call.

                If the parse is successful, `val` will contain the returned value, if any
                and `pos` will indicate the point in the text where the parser stopped.
                If the parse is unsuccessful, `err` will contain a string describing
                any errors that occurred during the parse and `pos` will indicate
                the location of the farthest error in the text.
                \"\"\"

                val: Any = None
                err: Optional[str] = None
                pos: Optional[int] = None
            """)

    def _gen_parse_function(self) -> FormatObj:
        return self._defmt("""\
            def parse(
                text: str, path: str = '<string>', externs: Externs = None
            ) -> Result:
                \"\"\"Parse a given text and return the result.

                If the parse was successful, `result.val` will be the returned value
                from the parse, and `result.pos` will indicate where the parser
                stopped when it was done parsing.

                If the parse is unsuccessful, `result.err` will be a string describing
                any errors found in the text, and `result.pos` will indicate the
                furthest point reached during the parse.

                If the optional `path` is provided it will be used in any error
                messages to indicate the path to the filename containing the given
                text.
                \"\"\"
                return _Parser(text, path).parse(externs)
           """)

    def _gen_parser_class(self) -> FormatObj:
        vl = self._defmt("""\
            class _Parser:
            """)

        methods = self._gen_constructor()
        methods += ''
        methods += self._gen_methods()
        vl += Indent(methods)
        return vl

    def _gen_constructor(self) -> VList:
        obj = VList(['def __init__(self, text, path):'])

        vl = self._defmt("""\
            self._text = text
            self._end = len(self._text)
            self._errpos = 0
            self._failed = False
            self._path = path
            self._pos = 0
            self._val = None
            """)

        if self._grammar.externs:
            vl += 'self._externs = {'
            for k, v in self._grammar.externs.items():
                vl += f"    '{k}': {v},"
            vl += '}'
        else:
            vl += 'self._externs = {}'

        if self._options.memoize:
            vl += 'self._cache = {}'
        if self._grammar.leftrec_needed or self._grammar.operator_needed:
            vl += 'self._seeds = {}'
        if self._grammar.leftrec_needed:
            vl += 'self._blocked = set()'
        if self._grammar.re_needed:
            vl += 'self._regexps = {}'
        if self._grammar.lookup_needed:
            vl += 'self._scopes = []'
        if self._grammar.operator_needed:
            vl += self._gen_operator_state()
        obj += Indent(vl)
        return obj

    def _gen_operator_state(self) -> FormatObj:
        vl = VList()
        vl += 'self._operators = {}'
        for rule, o in self._grammar.operators.items():
            vl += 'o = _OperatorState()'
            vl += 'o.prec_ops = {'
            text = ''
            for prec in sorted(o.prec_ops):
                text += '    %d: [' % prec
                text += ', '.join("'%s'" % op for op in o.prec_ops[prec])
                text += '],\n'
            vl += Indent(VList(text.splitlines()))
            vl += '}'
            vl += 'o.precs = sorted(o.prec_ops, reverse=True)'
            vl += (
                'o.rassoc = set(['
                + ', '.join("'%s'" % op for op in o.rassoc)
                + '])'
            )
            vl += 'o.choices = {'
            choices = VList()
            for op in o.choices:
                choices += "'%s': self._%s," % (op, o.choices[op])
            vl += Indent(choices)
            vl += '}'
            vl += "self._operators['%s'] = o" % rule
        return vl

    def _gen_methods(self) -> FormatObj:
        vobj = VList()
        vobj += self._gen_parse_method(
            exception_needed=self._grammar.exception_needed,
            starting_rule=self._grammar.starting_rule,
        )

        vobj += self._gen_rule_methods()

        vobj += self._gen_needed_methods()

        for name in self._grammar.needed_builtin_functions:
            vobj += ''
            vobj += self._defmt(self._builtin_methods[f'fn_{name}'])

        return vobj

    def _gen_parse_method(self, exception_needed, starting_rule) -> VList:
        if exception_needed:
            return self._defmt(
                f"""\
                def parse(self, externs: Externs = None):
                    errors = ''
                    if externs:
                        for k, v in externs.items():
                            if k in self._externs:
                                self._externs[k] = v
                            else:
                                errors += f'Unexpected extern "{{k}}"\\n'
                    if errors:
                        return Result(None, errors, 0)
                    try:
                        self._r_{starting_rule}()

                        if self._failed:
                            return Result(None, self._error(), self._errpos)
                        return Result(self._val, None, self._pos)
                    except _ParsingRuntimeError as e:  # pragma: no cover
                        lineno, _ = self._offsets(self._errpos)
                        return Result(
                            None,
                            self._path + ':' + str(lineno) + ' ' + str(e),
                            self._errpos,
                        )
                """
            )
        return self._defmt(
            f"""\
            def parse(self, externs: Externs = None):
                if externs:
                    for k, v in externs.items():
                        self._externs[k] = v

                self._r_{starting_rule}()

                if self._failed:
                    return Result(None, self._error(), self._errpos)
                return Result(self._val, None, self._pos)

            """
        )

    def _gen_rule_methods(self) -> VList:
        obj = VList()
        for rule, node in self._grammar.rules.items():
            obj += ''
            obj += self._gen_method_text(rule, node)

        if self._grammar.needed_builtin_rules:
            for name in sorted(self._grammar.needed_builtin_rules):
                obj += ''
                obj += self._defmt(self._builtin_methods[f'r_{name}'])
        return obj

    def _gen_method_text(self, method_name: str, node: Node) -> VList:
        return VList(
            [
                HList(['def _', method_name, '(self):']),
                Indent(self._gen_stmts(node)),
            ]
        )

    def _gen_thisvar(self, name: str) -> str:
        return 'self._' + name

    def _gen_rulename(self, name: str) -> str:
        return 'self._' + name

    def _gen_extern(self, name: str) -> str:
        return "self._externs['" + name + "']"

    def _gen_invoke(self, fn, *args) -> Saw:
        return Saw('self._' + fn + '(', Comma(args), ')')

    #
    # Handlers for each non-host node in the glop AST follow.
    #

    def _ty_choice(self, node: Node) -> ListObj:
        vl = VList(['p = self._pos'])
        for subnode in node.ch[:-1]:
            vl += self._gen_stmts(subnode)
            vl += 'if not self._failed:'
            vl += '    return'
            vl += 'self._rewind(p)'
        vl += self._gen_stmts(node.ch[-1])
        return vl

    def _ty_count(self, node: Node) -> ListObj:
        vl = VList(
            [
                'vs = []',
                'i = 0',
                f'cmin, cmax = {node.v}',
                'while i < cmax:',
            ]
        )
        svl = self._gen_stmts(node.child)
        svl += 'if self._failed:'
        svl += '    if i >= cmin:'
        svl += '        self._succeed(vs)'
        svl += '        return'
        svl += '    return'
        svl += 'vs.append(self._val)'
        svl += 'i += 1'

        vl += Indent(svl)
        vl += 'self._succeed(vs)'
        return vl

    def _ty_ends_in(self, node: Node) -> ListObj:
        sublines = self._gen_stmts(node.child)
        lines = [
            'while True:',
        ] + [Indent(sublines)]
        if node.can_fail:
            lines.extend(['    if not self._failed:', '        break'])
        lines.extend(
            [
                '    self._r_any()',
                '    if self._failed:',
                '        break',
            ]
        )
        return VList(lines)

    def _ty_label(self, node: Node) -> ListObj:
        assert isinstance(node, Label)
        lines: ElList = [self._gen_stmts(node.child)]
        if node.child.can_fail:
            lines.extend(['if self._failed:', '    return'])
        if node.outer_scope:
            lines.extend([f"self._scopes[-1]['{node.name}'] = self._val"])
        else:
            lines.extend(
                [
                    f'{self._gen_varname(node.name)} = self._val',
                ]
            )
        return VList(lines)

    def _ty_not(self, node: Node) -> ListObj:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'p = self._pos',
                'errpos = self._errpos',
            ]
            + [sublines]
            + [
                'if self._failed:',
                '    self._succeed(None, p)',
                'else:',
                '    self._rewind(p)',
                '    self._errpos = errpos',
                '    self._fail()',
            ]
        )
        return VList(lines)

    def _ty_not_one(self, node: Node) -> ListObj:
        sublines = self._gen_stmts(self._grammar.node(Not, node.child))
        return VList([sublines, 'if not self._failed:', '    self._r_any()'])

    def _ty_opt(self, node: Node) -> ListObj:
        sublines = self._gen_stmts(node.child)
        return VList(
            [
                'p = self._pos',
            ]
            + [sublines]
            + [
                'if self._failed:',
                '    self._succeed([], p)',
                'else:',
                '    self._succeed([self._val])',
            ]
        )

    def _ty_paren(self, node: Node) -> ListObj:
        return self._gen_stmts(node.child)

    def _ty_plus(self, node: Node) -> ListObj:
        sublines = self._gen_stmts(node.child)
        lines = (
            ['vs = []']
            + [sublines]
            + [
                'if self._failed:',
                '    return',
                'vs.append(self._val)',
                'while True:',
                '    p = self._pos',
            ]
            + [Indent(sublines)]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )

        return VList(lines)

    def _ty_pred(self, node: Node) -> ListObj:
        arg = self._gen_expr(node.child)
        return VList(
            [
                HList(['v = ', arg]),
                'if v is True:',
                '    self._succeed(v)',
                'elif v is False:',
                '    self._fail()',
                'else:',
                "    raise _ParsingRuntimeError('Bad predicate value')",
            ]
        )

    def _ty_regexp(self, node: Node) -> ListObj:
        return VList(
            [
                f'p = {self._gen_lit(node.v)}',
                'if p not in self._regexps:',
                '    self._regexps[p] = re.compile(p)',
                'm = self._regexps[p].match(self._text, self._pos)',
                'if m:',
                '    self._succeed(m.group(0), m.end())',
                '    return',
                'self._fail()',
            ]
        )

    def _ty_run(self, node: Node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = ['start = self._pos'] + [sublines]
        if node.child.can_fail:
            lines.extend(['if self._failed:', '    return'])
        lines.extend(
            [
                'end = self._pos',
                'self._val = self._text[start:end]',
            ]
        )
        return VList(lines)

    def _ty_scope(self, node: Node) -> VList:
        return VList(
            [
                'self._scopes.append({})',
            ]
            + [self._gen_stmts(node.child)]
            + [
                'self._scopes.pop()',
            ]
        )

    def _ty_seq(self, node: Node) -> VList:
        lines: ElList = [self._gen_stmts(node.ch[0])]
        if node.ch[0].can_fail:
            lines.extend(['if self._failed:', '    return'])
        for subnode in node.ch[1:-1]:
            lines.append(self._gen_stmts(subnode))
            if subnode.can_fail:
                lines.extend(['if self._failed:', '    return'])
        lines.append(self._gen_stmts(node.ch[-1]))
        return VList(lines)

    def _ty_star(self, node: Node) -> VList:
        sublines = self._gen_stmts(node.child)
        lines = (
            [
                'vs = []',
                'while True:',
                '    p = self._pos',
            ]
            + [Indent(sublines)]
            + [
                '    if self._failed or self._pos == p:',
                '        self._rewind(p)',
                '        break',
                '    vs.append(self._val)',
                'self._succeed(vs)',
            ]
        )
        return VList(lines)

    def _gen_main_footer(self) -> VList:
        return self._defmt("""\


            if __name__ == '__main__':
                sys.exit(main())
            """)

    def _gen_default_footer(self) -> VList:
        return VList()


_BUILTINS = {
    'r_any': """\
        def _r_any(self):
            if self._pos < self._end:
                self._succeed(self._text[self._pos], self._pos + 1)
            else:
                self._fail()
        """,
    'r_end': """\
        def _r_end(self):
            if self._pos == self._end:
                self._succeed(None)
            else:
                self._fail()
        """,
    'ch': """\
        def _ch(self, ch):
            p = self._pos
            if p < self._end and self._text[p] == ch:
                self._succeed(ch, self._pos + 1)
            else:
                self._fail()
        """,
    'offsets': """\
        def _offsets(self, pos):
            lineno = 1
            colno = 1
            for i in range(pos):
                if self._text[i] == '\\n':
                    lineno += 1
                    colno = 1
                else:
                    colno += 1
            return lineno, colno
        """,
    'error': """\
        def _error(self):
            lineno, colno = self._offsets(self._errpos)
            if self._errpos == len(self._text):
                thing = 'end of input'
            else:
                thing = repr(self._text[self._errpos]).replace("'", '"')
            return '%s:%d Unexpected %s at column %d' % (
                self._path,
                lineno,
                thing,
                colno,
            )
        """,
    'fail': """\
        def _fail(self):
            self._val = None
            self._failed = True
            self._errpos = max(self._errpos, self._pos)
        """,
    'leftrec': """\
        def _leftrec(self, rule, rule_name, left_assoc):
            pos = self._pos
            key = (rule_name, pos)
            seed = self._seeds.get(key)
            if seed:
                self._val, self._failed, self._pos = seed
                return
            if rule_name in self._blocked:
                self._val = None
                self._failed = True
                return
            current = (None, True, self._pos)
            self._seeds[key] = current
            if left_assoc:
                self._blocked.add(rule_name)
            while True:
                rule()
                if self._pos > current[2]:
                    current = (self._val, self._failed, self._pos)
                    self._seeds[key] = current
                    self._pos = pos
                else:
                    del self._seeds[key]
                    self._val, self._failed, self._pos = current
                    if left_assoc:
                        self._blocked.remove(rule_name)
                    return
        """,
    'lookup': """\
        def _lookup(self, var):
            l = len(self._scopes) - 1
            while l >= 0:
                if var in self._scopes[l]:
                    return self._scopes[l][var]
                l -= 1
            if var in self._externs:
                return self._externs[var]
            assert False, f'unknown var {var}'
        """,
    'memoize': """\
        def _memoize(self, rule_name, fn):
            p = self._pos
            r = self._cache.setdefault(p, {}).get(rule_name)
            if r:
                self._val, self._failed, self._pos = r
                return
            fn()
            self._cache[p][rule_name] = (self._val, self._failed, self._pos)
        """,
    'operator': """\
        def _operator(self, rule_name):
            o = self._operators[rule_name]
            pos = self._pos
            key = (rule_name, self._pos)
            seed = self._seeds.get(key)
            if seed:
                self._val, self._failed, self._pos = seed
                return
            o.current_depth += 1
            current = (None, True, self._pos)
            self._seeds[key] = current
            min_prec = o.current_prec
            i = 0
            while i < len(o.precs):
                repeat = False
                prec = o.precs[i]
                prec_ops = o.prec_ops[prec]
                if prec < min_prec:
                    break
                o.current_prec = prec
                if prec_ops[0] not in o.rassoc:
                    o.current_prec += 1
                for j, _ in enumerate(prec_ops):
                    op = prec_ops[j]
                    o.choices[op]()
                    if not self._failed and self._pos > pos:
                        current = (self._val, self._failed, self._pos)
                        self._seeds[key] = current
                        repeat = True
                        break
                    self._rewind(pos)
                if not repeat:
                    i += 1

            del self._seeds[key]
            o.current_depth -= 1
            if o.current_depth == 0:
                o.current_prec = 0
            self._val, self._failed, self._pos = current
        """,
    'range': """\
        def _range(self, i, j):
            p = self._pos
            if p != self._end and ord(i) <= ord(self._text[p]) <= ord(j):
                self._succeed(self._text[p], self._pos + 1)
            else:
                self._fail()
    """,
    'rewind': """\
        def _rewind(self, newpos):
            self._succeed(None, newpos)
    """,
    'str': """\
        def _str(self, s):
            for ch in s:
                self._ch(ch)
                if self._failed:
                    return
            self._val = s
    """,
    'succeed': """\
        def _succeed(self, v, newpos=None):
            self._val = v
            self._failed = False
            if newpos is not None:
                self._pos = newpos
    """,
    'unicat': """\
        def _unicat(self, cat):
            p = self._pos
            if p < self._end and unicodedata.category(self._text[p]) == cat:
                self._succeed(self._text[p], self._pos + 1)
            else:
                self._fail()
    """,
    'fn_atof': """\
        def _fn_atof(self, s):
            if '.' in s or 'e' in s or 'E' in s:
                return float(s)
            return int(s)
    """,
    'fn_atoi': """\
        def _fn_atoi(self, a, base):
            return int(a, base)
    """,
    'fn_atou': """\
        def _fn_atou(self, a, base):
            return chr(int(a, base))
    """,
    'fn_cat': """\
        def _fn_cat(self, strs):
            return ''.join(strs)
    """,
    'fn_concat': """\
        def _fn_concat(self, xs, ys):
            return xs + ys
    """,
    'fn_cons': """\
        def _fn_cons(self, hd, tl):
            return [hd] + tl
    """,
    'fn_dedent': """\
        def _fn_dedent(self, s):
            return s
    """,
    'fn_dict': """\
        def _fn_dict(self, pairs):
            return dict(pairs)
    """,
    'fn_itou': """\
        def _fn_itou(self, n):
            return chr(n)
    """,
    'fn_join': """\
        def _fn_join(self, s, vs):
            return s.join(vs)
    """,
    'fn_otou': """\
        def _fn_otou(self, s):
            return chr(int(s, base=8))
    """,
    'fn_scat': """\
        def _fn_scat(self, hd, tl):
            return self._fn_cat(self._fn_cons(hd, tl))
    """,
    'fn_scons': """\
        def _fn_scons(self, hd, tl):
            return [hd] + tl
    """,
    'fn_strcat': """\
        def _fn_strcat(self, a, b):
            return a + b
    """,
    'fn_unicode_lookup': """\
        def _fn_unicode_lookup(self, s):
            return unicodedata.lookup(s)
    """,
    'fn_utoi': """\
        def _fn_utoi(self, s):
            return ord(s)
    """,
    'fn_xtoi': """\
        def _fn_xtoi(self, s):
            return int(s, base=16)
    """,
    'fn_xtou': """\
        def _fn_xtou(self, s):
            return chr(int(s, base=16))
    """,
}
