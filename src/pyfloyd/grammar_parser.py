# Generated by pyfloyd version 0.28.0.dev0
#    https://github.com/dpranke/pyfloyd
#
#    `flc -o src/pyfloyd/grammar_parser.py grammars/floyd.g`
#

import re
from typing import Any, Dict, NamedTuple, Optional
import unicodedata

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if
    any and `pos` will indicate the point in the text where the parser
    stopped.  If the parse is unsuccessful, `err` will contain a string
    describing any errors that occurred during the parse and `pos` will
    indicate the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None


def parse(
    text: str, path: str = '<string>', externs: Externs = None, start: int = 0
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs, start)


class _State:
    def __init__(self, pos: int = 0, failed: bool = False, val: Any = None):
        self.pos = pos
        self.failed = failed
        self.val = val

    def __repr__(self):
        return f'_State(pos={self.pos}, failed={self.failed})'

    def copy(self):
        r = _State()
        r.pos = self.pos
        r.failed = self.failed
        r.val = self.val
        return r


class _ParsingRuntimeError(Exception):
    pass


class _Parser:
    def __init__(self, text, path):
        self._text = text
        self._end = len(self._text)
        self._errpos = 0
        self._path = path
        self._state = _State()
        self._externs = {
            'memoize': True,
            'unicode': True,
            'unicode_categories': True,
            'unicode_names': True,
            'node': self._fn_node,
        }
        self._cache = {}
        self._regexps = {}

    def pos(self):
        return self._state.pos

    def parse(self, externs: Externs = None, start: int = 0):
        self._state = _State(pos=start)
        errors = ''
        if externs:
            for k, v in externs.items():
                if k in self._externs:
                    self._externs[k] = v
                else:
                    errors += f'Unexpected extern "{k}"\n'
        for k, v in self._externs.items():
            if v is None:
                errors += f'Missing required extern "{k}"'
        if errors:
            return Result(None, errors, 0)

        try:
            self._r_grammar()

            if self._state.failed:
                return Result(None, self._o_error(), self._errpos)
            return Result(self._state.val, None, self._state.pos)
        except _ParsingRuntimeError as e:  # pragma: no cover
            lineno, _ = self._o_offsets(self._errpos)
            return Result(
                None,
                self._path + ':' + str(lineno) + ' ' + str(e),
                self._errpos,
            )

    def _r_grammar(self):
        self._s_grammar_1()
        v__1 = self._state.val
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_end', self._r_end)
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['rules', None, v__1]), self._state.pos
        )

    def _s_grammar_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._o_memoize('r_rule', self._r_rule)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_rule(self):
        self._s_rule_1()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('=')
        if self._state.failed:
            return
        self._o_memoize('r_choice', self._r_choice)
        v__3 = self._state.val
        self._o_succeed(
            self._externs['node'](self, ['rule', v__1, [v__3]]),
            self._state.pos,
        )

    def _s_rule_1(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_ident', self._r_ident)

    def _r_ident(self):
        self._o_memoize('r_id_start', self._r_id_start)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._s_ident_1()
        v__2 = self._state.val
        self._o_succeed(
            self._fn_cat(self._fn_scons(v__1, v__2)), self._state.pos
        )

    def _s_ident_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._o_memoize('r_id_continue', self._r_id_continue)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_id_start(self):
        rexp = '[a-zA-Z$_%]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_id_continue(self):
        state = self._state.copy()
        self._o_memoize('r_id_start', self._r_id_start)
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_id_continue_1()

    def _s_id_continue_1(self):
        rexp = '[0-9]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_choice(self):
        self._o_memoize('r_seq', self._r_seq)
        v__1 = self._state.val
        self._s_choice_1()
        v__2 = self._state.val
        self._o_succeed(
            self._externs['node'](
                self, ['choice', None, self._fn_cons(v__1, v__2)]
            ),
            self._state.pos,
        )

    def _s_choice_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_choice_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_choice_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('|')
        if self._state.failed:
            return
        self._o_memoize('r_seq', self._r_seq)

    def _r_seq(self):
        state = self._state.copy()
        self._s_seq_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_succeed(
            self._externs['node'](self, ['empty', None, []]), self._state.pos
        )

    def _s_seq_1(self):
        self._o_memoize('r_expr', self._r_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._s_seq_2()
        v__2 = self._state.val
        self._o_succeed(
            self._externs['node'](
                self, ['seq', None, self._fn_cons(v__1, v__2)]
            ),
            self._state.pos,
        )

    def _s_seq_2(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_seq_3()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_seq_3(self):
        self._o_memoize('r_expr', self._r_expr)

    def _r_expr(self):
        state = self._state.copy()
        self._s_expr_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_expr_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_expr_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_expr_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_post_expr', self._r_post_expr)

    def _s_expr_1(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('->')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['action', None, [v__2]]),
            self._state.pos,
        )

    def _s_expr_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('?{')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['pred', None, [v__2]]),
            self._state.pos,
        )

    def _s_expr_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('={')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['equals', None, [v__2]]),
            self._state.pos,
        )

    def _s_expr_4(self):
        self._o_memoize('r_post_expr', self._r_post_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(':')
        if self._state.failed:
            return
        self._s_expr_5()
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['label', v__3, [v__1]]),
            self._state.pos,
        )

    def _s_expr_5(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_ident', self._r_ident)

    def _r_post_expr(self):
        state = self._state.copy()
        self._s_post_expr_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_post_expr_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_post_expr_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_post_expr_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_prim_expr', self._r_prim_expr)

    def _s_post_expr_1(self):
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('?')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['opt', None, [v__1]]), self._state.pos
        )

    def _s_post_expr_2(self):
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('*')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['star', None, [v__1]]),
            self._state.pos,
        )

    def _s_post_expr_3(self):
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('+')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['plus', None, [v__1]]),
            self._state.pos,
        )

    def _s_post_expr_4(self):
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r_count', self._r_count)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['count', v__2, [v__1]]),
            self._state.pos,
        )

    def _r_count(self):
        state = self._state.copy()
        self._s_count_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_count_4()

    def _s_count_1(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('{')
        if self._state.failed:
            return
        self._s_count_2()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(',')
        if self._state.failed:
            return
        self._s_count_3()
        if self._state.failed:
            return
        v__4 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed([v__2, v__4], self._state.pos)

    def _s_count_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_zpos', self._r_zpos)

    def _s_count_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_zpos', self._r_zpos)

    def _s_count_4(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('{')
        if self._state.failed:
            return
        self._s_count_5()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed([v__2, v__2], self._state.pos)

    def _s_count_5(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_zpos', self._r_zpos)

    def _r_prim_expr(self):
        state = self._state.copy()
        self._s_prim_expr_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_6()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_8()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_10()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_12()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_13()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_14()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_15()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_19()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_prim_expr_20()

    def _s_prim_expr_1(self):
        self._s_prim_expr_2()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('..')
        if self._state.failed:
            return
        self._s_prim_expr_3()
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['range', [v__1, v__3], []]),
            self._state.pos,
        )

    def _s_prim_expr_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_lit', self._r_lit)

    def _s_prim_expr_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_lit', self._r_lit)

    def _s_prim_expr_4(self):
        self._s_prim_expr_5()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['lit', v__1, []]), self._state.pos
        )

    def _s_prim_expr_5(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_lit', self._r_lit)

    def _s_prim_expr_6(self):
        v = self._externs['unicode_categories']
        if v is True:
            self._o_succeed(v, self._state.pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('\\p{')
        if self._state.failed:
            return
        self._s_prim_expr_7()
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['unicat', v__3, []]), self._state.pos
        )

    def _s_prim_expr_7(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_ident', self._r_ident)

    def _s_prim_expr_8(self):
        self._s_prim_expr_9()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['set', v__1, []]), self._state.pos
        )

    def _s_prim_expr_9(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_set', self._r_set)

    def _s_prim_expr_10(self):
        self._s_prim_expr_11()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['regexp', v__1, []]), self._state.pos
        )

    def _s_prim_expr_11(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_regexp', self._r_regexp)

    def _s_prim_expr_12(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('\x7e')
        if self._state.failed:
            return
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['not', None, [v__2]]), self._state.pos
        )

    def _s_prim_expr_13(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('^.')
        if self._state.failed:
            return
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['ends_in', None, [v__2]]),
            self._state.pos,
        )

    def _s_prim_expr_14(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('^')
        if self._state.failed:
            return
        self._o_memoize('r_prim_expr', self._r_prim_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['not_one', None, [v__2]]),
            self._state.pos,
        )

    def _s_prim_expr_15(self):
        self._s_prim_expr_16()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._s_prim_expr_17()
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['apply', v__1, []]), self._state.pos
        )

    def _s_prim_expr_16(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_ident', self._r_ident)

    def _s_prim_expr_17(self):
        state = self._state.copy()
        errpos = self._errpos
        self._s_prim_expr_18()
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()

    def _s_prim_expr_18(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('=')

    def _s_prim_expr_19(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('(')
        if self._state.failed:
            return
        self._o_memoize('r_choice', self._r_choice)
        v__2 = self._state.val
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(')')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['paren', None, [v__2]]),
            self._state.pos,
        )

    def _s_prim_expr_20(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('<')
        if self._state.failed:
            return
        self._o_memoize('r_choice', self._r_choice)
        v__2 = self._state.val
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('>')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['run', None, [v__2]]), self._state.pos
        )

    def _r_lit(self):
        state = self._state.copy()
        self._s_lit_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_lit_3()

    def _s_lit_1(self):
        self._o_memoize('r_squote', self._r_squote)
        if self._state.failed:
            return
        self._s_lit_2()
        v__2 = self._state.val
        self._o_memoize('r_squote', self._r_squote)
        if self._state.failed:
            return
        self._o_succeed(self._fn_cat(v__2), self._state.pos)

    def _s_lit_2(self):
        vs = []
        while True:
            state = self._state.copy()
            self._o_memoize('r_sqchar', self._r_sqchar)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_lit_3(self):
        self._o_memoize('r_dquote', self._r_dquote)
        if self._state.failed:
            return
        self._s_lit_4()
        v__2 = self._state.val
        self._o_memoize('r_dquote', self._r_dquote)
        if self._state.failed:
            return
        self._o_succeed(self._fn_cat(v__2), self._state.pos)

    def _s_lit_4(self):
        vs = []
        while True:
            state = self._state.copy()
            self._o_memoize('r_dqchar', self._r_dqchar)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_sqchar(self):
        state = self._state.copy()
        self._o_memoize('r_escape', self._r_escape)
        if not self._state.failed:
            return
        self._o_restore(state)
        state = self._state.copy()
        errpos = self._errpos
        self._o_memoize('r_squote', self._r_squote)
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()
        if not self._state.failed:
            self._r_any()

    def _r_dqchar(self):
        state = self._state.copy()
        self._o_memoize('r_escape', self._r_escape)
        if not self._state.failed:
            return
        self._o_restore(state)
        state = self._state.copy()
        errpos = self._errpos
        self._o_memoize('r_dquote', self._r_dquote)
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()
        if not self._state.failed:
            self._r_any()

    def _r_bslash(self):
        self._o_ch('\\')

    def _r_squote(self):
        self._o_ch("'")

    def _r_dquote(self):
        self._o_ch('"')

    def _r_escape(self):
        state = self._state.copy()
        self._s_escape_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_5()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_6()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_7()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_8()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_9()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_hex_esc', self._r_hex_esc)
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_10()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_escape_11()

    def _s_escape_1(self):
        self._o_str('\\b')
        if self._state.failed:
            return
        self._o_succeed('\b', self._state.pos)

    def _s_escape_2(self):
        self._o_str('\\f')
        if self._state.failed:
            return
        self._o_succeed('\f', self._state.pos)

    def _s_escape_3(self):
        self._o_str('\\n')
        if self._state.failed:
            return
        self._o_succeed('\n', self._state.pos)

    def _s_escape_4(self):
        self._o_str('\\r')
        if self._state.failed:
            return
        self._o_succeed('\r', self._state.pos)

    def _s_escape_5(self):
        self._o_str('\\t')
        if self._state.failed:
            return
        self._o_succeed('\t', self._state.pos)

    def _s_escape_6(self):
        self._o_str('\\v')
        if self._state.failed:
            return
        self._o_succeed('\v', self._state.pos)

    def _s_escape_7(self):
        self._o_ch('\\')
        if self._state.failed:
            return
        self._o_memoize('r_squote', self._r_squote)
        if self._state.failed:
            return
        self._o_succeed("'", self._state.pos)

    def _s_escape_8(self):
        self._o_ch('\\')
        if self._state.failed:
            return
        self._o_memoize('r_dquote', self._r_dquote)
        if self._state.failed:
            return
        self._o_succeed('"', self._state.pos)

    def _s_escape_9(self):
        self._o_str('\\\\')
        if self._state.failed:
            return
        self._o_succeed('\\', self._state.pos)

    def _s_escape_10(self):
        v = self._externs['unicode']
        if v is True:
            self._o_succeed(v, self._state.pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if self._state.failed:
            return
        self._o_memoize('r_uni_esc', self._r_uni_esc)

    def _s_escape_11(self):
        self._o_ch('\\')
        if self._state.failed:
            return
        self._o_memoize('r_any', self._r_any)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_strcat('\\', v__2), self._state.pos)

    def _r_hex_esc(self):
        state = self._state.copy()
        self._s_hex_esc_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_hex_esc_3()

    def _s_hex_esc_1(self):
        self._o_str('\\x')
        if self._state.failed:
            return
        self._s_hex_esc_2()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_atou(self._fn_cat(v__2), 16), self._state.pos)

    def _s_hex_esc_2(self):
        vs = []
        i = 0
        cmin = 2
        cmax = 2
        while i < cmax:
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed:
                if i >= cmin:
                    self._o_succeed(vs, self._state.pos)
                return
            vs.append(self._state.val)
            i += 1
        self._o_succeed(vs, self._state.pos)

    def _s_hex_esc_3(self):
        self._o_str('\\x{')
        if self._state.failed:
            return
        self._s_hex_esc_4()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(self._fn_atou(self._fn_cat(v__2), 16), self._state.pos)

    def _s_hex_esc_4(self):
        vs = []
        self._o_memoize('r_hex_char', self._r_hex_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_uni_esc(self):
        state = self._state.copy()
        self._s_uni_esc_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_uni_esc_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_uni_esc_5()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_uni_esc_7()

    def _s_uni_esc_1(self):
        self._o_str('\\u')
        if self._state.failed:
            return
        self._s_uni_esc_2()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_atou(self._fn_cat(v__2), 16), self._state.pos)

    def _s_uni_esc_2(self):
        vs = []
        i = 0
        cmin = 4
        cmax = 4
        while i < cmax:
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed:
                if i >= cmin:
                    self._o_succeed(vs, self._state.pos)
                return
            vs.append(self._state.val)
            i += 1
        self._o_succeed(vs, self._state.pos)

    def _s_uni_esc_3(self):
        self._o_str('\\u{')
        if self._state.failed:
            return
        self._s_uni_esc_4()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(self._fn_atou(self._fn_cat(v__2), 16), self._state.pos)

    def _s_uni_esc_4(self):
        vs = []
        self._o_memoize('r_hex_char', self._r_hex_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_uni_esc_5(self):
        self._o_str('\\U')
        if self._state.failed:
            return
        self._s_uni_esc_6()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_atou(self._fn_cat(v__2), 16), self._state.pos)

    def _s_uni_esc_6(self):
        vs = []
        i = 0
        cmin = 8
        cmax = 8
        while i < cmax:
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed:
                if i >= cmin:
                    self._o_succeed(vs, self._state.pos)
                return
            vs.append(self._state.val)
            i += 1
        self._o_succeed(vs, self._state.pos)

    def _s_uni_esc_7(self):
        v = self._externs['unicode_names']
        if v is True:
            self._o_succeed(v, self._state.pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if self._state.failed:
            return
        self._o_memoize('r_uni_name', self._r_uni_name)

    def _r_uni_name(self):
        self._o_str('N{')
        if self._state.failed:
            return
        self._s_uni_name_1()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_ch('}')
        if self._state.failed:
            return
        self._o_succeed(self._fn_ulookup(v__2), self._state.pos)

    def _s_uni_name_1(self):
        rexp = '[A-Z][A-Z0-9]*(( [A-Z][A-Z0-9]*|(-[A-Z0-9]*)))*'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_set(self):
        state = self._state.copy()
        self._s_set_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_set_3()

    def _s_set_1(self):
        self._o_ch('[')
        if self._state.failed:
            return
        self._o_ch('^')
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._s_set_2()
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_ch(']')
        if self._state.failed:
            return
        self._o_succeed(
            self._fn_cat(self._fn_scons(v__2, v__3)), self._state.pos
        )

    def _s_set_2(self):
        vs = []
        self._o_memoize('r_set_char', self._r_set_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_set_char', self._r_set_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_set_3(self):
        self._o_ch('[')
        if self._state.failed:
            return
        self._s_set_4()
        if self._state.failed:
            return
        self._s_set_5()
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_ch(']')
        if self._state.failed:
            return
        self._o_succeed(self._fn_cat(v__3), self._state.pos)

    def _s_set_4(self):
        state = self._state.copy()
        errpos = self._errpos
        self._o_ch('^')
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()

    def _s_set_5(self):
        vs = []
        self._o_memoize('r_set_char', self._r_set_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_set_char', self._r_set_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_set_char(self):
        state = self._state.copy()
        self._s_set_char_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_escape', self._r_escape)
        if not self._state.failed:
            return
        self._o_restore(state)
        state = self._state.copy()
        errpos = self._errpos
        self._o_ch(']')
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()
        if not self._state.failed:
            self._r_any()

    def _s_set_char_1(self):
        self._o_str('\\]')
        if self._state.failed:
            return
        self._o_succeed('\\]', self._state.pos)

    def _r_regexp(self):
        self._o_ch('/')
        if self._state.failed:
            return
        self._s_regexp_1()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_ch('/')
        if self._state.failed:
            return
        self._o_succeed(self._fn_cat(v__2), self._state.pos)

    def _s_regexp_1(self):
        vs = []
        self._o_memoize('r_re_char', self._r_re_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_re_char', self._r_re_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_re_char(self):
        state = self._state.copy()
        self._s_re_char_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_escape', self._r_escape)
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_re_char_2()

    def _s_re_char_1(self):
        self._o_memoize('r_bslash', self._r_bslash)
        if self._state.failed:
            return
        self._o_ch('/')
        if self._state.failed:
            return
        self._o_succeed('/', self._state.pos)

    def _s_re_char_2(self):
        rexp = '[^/]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_zpos(self):
        state = self._state.copy()
        self._s_zpos_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_zpos_2()

    def _s_zpos_1(self):
        self._o_ch('0')
        if self._state.failed:
            return
        self._o_succeed(0, self._state.pos)

    def _s_zpos_2(self):
        self._s_zpos_3()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_atoi(v__1, 10), self._state.pos)

    def _s_zpos_3(self):
        start = self._state.pos
        self._s_zpos_4()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s_zpos_4(self):
        self._s_zpos_5()
        if self._state.failed:
            return
        self._s_zpos_6()

    def _s_zpos_5(self):
        rexp = '[1-9]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _s_zpos_6(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_zpos_7()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_zpos_7(self):
        rexp = '[0-9]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_e_expr(self):
        state = self._state.copy()
        self._s_e_expr_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_expr_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_expr_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_e_qual', self._r_e_qual)

    def _s_e_expr_1(self):
        self._o_memoize('r_e_qual', self._r_e_qual)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('+')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_plus', None, [v__1, v__3]]),
            self._state.pos,
        )

    def _s_e_expr_2(self):
        self._o_memoize('r_e_qual', self._r_e_qual)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('-')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__3 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_minus', None, [v__1, v__3]]),
            self._state.pos,
        )

    def _s_e_expr_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('!')
        if self._state.failed:
            return
        self._o_memoize('r_e_qual', self._r_e_qual)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_not', None, [v__2]]),
            self._state.pos,
        )

    def _r_e_exprs(self):
        state = self._state.copy()
        self._s_e_exprs_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_succeed([], self._state.pos)

    def _s_e_exprs_1(self):
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._s_e_exprs_2()
        v__2 = self._state.val
        self._s_e_exprs_4()
        self._o_succeed(self._fn_cons(v__1, v__2), self._state.pos)

    def _s_e_exprs_2(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_e_exprs_3()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_e_exprs_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(',')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)

    def _s_e_exprs_4(self):
        state = self._state.copy()
        self._s_e_exprs_5()
        if self._state.failed:
            self._o_succeed([], state.pos)
        else:
            self._o_succeed([self._state.val], self._state.pos)

    def _s_e_exprs_5(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(',')

    def _r_e_qual(self):
        state = self._state.copy()
        self._s_e_qual_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r_e_prim', self._r_e_prim)

    def _s_e_qual_1(self):
        self._o_memoize('r_e_prim', self._r_e_prim)
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._s_e_qual_2()
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](
                self, ['e_qual', None, self._fn_cons(v__1, v__2)]
            ),
            self._state.pos,
        )

    def _s_e_qual_2(self):
        vs = []
        self._o_memoize('r_e_post_op', self._r_e_post_op)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_e_post_op', self._r_e_post_op)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_e_post_op(self):
        state = self._state.copy()
        self._s_e_post_op_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_post_op_2()

    def _s_e_post_op_1(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('[')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(']')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_getitem', None, [v__2]]),
            self._state.pos,
        )

    def _s_e_post_op_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('(')
        if self._state.failed:
            return
        self._o_memoize('r_e_exprs', self._r_e_exprs)
        v__2 = self._state.val
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(')')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_call', None, v__2]),
            self._state.pos,
        )

    def _r_e_prim(self):
        state = self._state.copy()
        self._s_e_prim_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_5()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_7()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_9()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_11()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_13()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_e_prim_14()

    def _s_e_prim_1(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('false')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_const', 'false', []]),
            self._state.pos,
        )

    def _s_e_prim_2(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('null')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_const', 'null', []]),
            self._state.pos,
        )

    def _s_e_prim_3(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('true')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_const', 'true', []]),
            self._state.pos,
        )

    def _s_e_prim_4(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_str('func')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_const', 'func', []]),
            self._state.pos,
        )

    def _s_e_prim_5(self):
        self._s_e_prim_6()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_ident', v__1, []]), self._state.pos
        )

    def _s_e_prim_6(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_ident', self._r_ident)

    def _s_e_prim_7(self):
        self._s_e_prim_8()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_num', v__1, []]), self._state.pos
        )

    def _s_e_prim_8(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_hex', self._r_hex)

    def _s_e_prim_9(self):
        self._s_e_prim_10()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_num', v__1, []]), self._state.pos
        )

    def _s_e_prim_10(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_int', self._r_int)

    def _s_e_prim_11(self):
        self._s_e_prim_12()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_lit', v__1, []]), self._state.pos
        )

    def _s_e_prim_12(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_memoize('r_lit', self._r_lit)

    def _s_e_prim_13(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('(')
        if self._state.failed:
            return
        self._o_memoize('r_e_expr', self._r_e_expr)
        if self._state.failed:
            return
        v__2 = self._state.val
        if self._state.failed:
            return
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(')')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_paren', None, [v__2]]),
            self._state.pos,
        )

    def _s_e_prim_14(self):
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch('[')
        if self._state.failed:
            return
        self._o_memoize('r_e_exprs', self._r_e_exprs)
        v__2 = self._state.val
        self._o_memoize('r__filler', self._r__filler)
        self._o_ch(']')
        if self._state.failed:
            return
        self._o_succeed(
            self._externs['node'](self, ['e_arr', None, v__2]), self._state.pos
        )

    def _r_int(self):
        state = self._state.copy()
        self._s_int_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_int_3()

    def _s_int_1(self):
        self._o_ch('0')
        if self._state.failed:
            return
        self._s_int_2()
        if self._state.failed:
            return
        self._o_succeed('0', self._state.pos)

    def _s_int_2(self):
        state = self._state.copy()
        errpos = self._errpos
        self._o_ch('x')
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()

    def _s_int_3(self):
        start = self._state.pos
        self._s_int_4()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s_int_4(self):
        self._s_int_5()
        self._s_int_6()
        if self._state.failed:
            return
        self._s_int_7()

    def _s_int_5(self):
        state = self._state.copy()
        self._o_ch('-')
        if self._state.failed:
            self._o_succeed([], state.pos)
        else:
            self._o_succeed([self._state.val], self._state.pos)

    def _s_int_6(self):
        rexp = '[1-9]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _s_int_7(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_int_8()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_int_8(self):
        rexp = '[0-9]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_hex(self):
        start = self._state.pos
        self._s_hex_1()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s_hex_1(self):
        self._o_str('0x')
        if self._state.failed:
            return
        self._s_hex_2()

    def _s_hex_2(self):
        vs = []
        self._o_memoize('r_hex_char', self._r_hex_char)
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._o_memoize('r_hex_char', self._r_hex_char)
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_hex_char(self):
        rexp = '[0-9a-fA-F]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r__whitespace(self):
        start = self._state.pos
        self._s__whitespace_1()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s__whitespace_1(self):
        vs = []
        self._s__whitespace_2()
        if self._state.failed:
            return
        vs.append(self._state.val)
        while True:
            state = self._state.copy()
            self._s__whitespace_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s__whitespace_2(self):
        state = self._state.copy()
        self._o_ch(' ')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('\f')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('\n')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('\r')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('\t')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('\v')

    def _r__comment(self):
        state = self._state.copy()
        self._s__comment_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s__comment_6()

    def _s__comment_1(self):
        start = self._state.pos
        self._s__comment_2()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s__comment_2(self):
        self._s__comment_3()
        if self._state.failed:
            return
        self._s__comment_4()

    def _s__comment_3(self):
        state = self._state.copy()
        self._o_str('//')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_ch('#')

    def _s__comment_4(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s__comment_5()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s__comment_5(self):
        rexp = '[^\r\n]'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _s__comment_6(self):
        start = self._state.pos
        self._s__comment_7()
        if self._state.failed:
            return
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s__comment_7(self):
        self._o_str('/*')
        if self._state.failed:
            return
        while True:
            self._o_str('*/')
            if not self._state.failed:
                break
            self._r_any()
            if self._state.failed:
                break

    def _r__filler(self):
        start = self._state.pos
        self._s__filler_1()
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s__filler_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s__filler_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s__filler_2(self):
        state = self._state.copy()
        self._o_memoize('r__whitespace', self._r__whitespace)
        if not self._state.failed:
            return
        self._o_restore(state)
        self._o_memoize('r__comment', self._r__comment)

    def _r_any(self):
        pos = self.pos()
        if pos < self._end:
            self._o_succeed(self._text[pos], pos + 1)
        else:
            self._o_fail()

    def _r_end(self):
        if self.pos() == self._end:
            self._o_succeed(None, self.pos())
        else:
            self._o_fail()

    def _o_ch(self, ch):
        pos = self.pos()
        if pos < self._end and self._text[pos] == ch:
            self._o_succeed(ch, pos + 1)
        else:
            self._o_fail()

    def _o_error(self):
        lineno, colno = self._o_offsets(self._errpos)
        if self._errpos == len(self._text):
            thing = 'end of input'
        else:
            thing = repr(self._text[self._errpos]).replace("'", '"')
        path = self._path
        return f'{path}:{lineno} Unexpected {thing} at column {colno}'

    def _o_fail(self):
        self._state.val = None
        self._state.failed = True
        self._errpos = max(self._errpos, self._state.pos)

    def _o_memoize(self, rule_name, fn):
        pos = self.pos()
        if pos not in self._cache:
            self._cache[pos] = {}
        c = self._cache[pos]
        if rule_name in c:
            self._state = c[rule_name].copy()
            return
        fn()
        c[rule_name] = self._state.copy()

    def _o_offsets(self, pos):
        lineno = 1
        colno = 1
        for i in range(pos):
            if self._text[i] == '\n':
                lineno += 1
                colno = 1
            else:
                colno += 1
        return lineno, colno

    def _o_restore(self, state):
        self._state = state.copy()

    def _o_str(self, s):
        for ch in s:
            self._o_ch(ch)
            if self._state.failed:
                return
        self._state.val = s

    def _o_succeed(self, v, newpos):
        self._state.val = v
        self._state.failed = False
        self._state.pos = newpos

    def _fn_atoi(self, s, base):
        return int(s, base)

    def _fn_atou(self, s, base):
        return chr(int(s, base))

    def _fn_cat(self, strs):
        return ''.join(strs)

    def _fn_cons(self, hd, tl):
        return [hd] + tl

    def _fn_node(self, parser, *args):
        del parser
        return args[0]

    def _fn_scons(self, hd, tl):
        return [hd] + tl

    def _fn_strcat(self, *args):
        return ''.join(args)

    def _fn_ulookup(self, s):
        return unicodedata.lookup(s)
