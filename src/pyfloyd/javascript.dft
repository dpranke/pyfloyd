# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file contains the code generation templates for JavaScript.
# It depends on a base set of templates used by fairly similar languages.

name = 'JavaScript'
ext = '.js'
indent = 2 
line_length = 79

starting_template: 'generate'

inherit: ['base']

templates = {

#
# Helper rules
#

block: [fn [head body] [vl [hl head ' {'] [ind body] '}']]

#
# How to refer to different types of identifiers:
#

# Returns a field or method on the generated parse object.
fld: [fn [name] [strcat 'this.' name]]

f_pos: [fld 'pos']
f_errpos: [fld 'errpos']
f_val: [fld 'val']
failed: [fld 'failed']

extern: [fn [name] [strcat "this.externs.get(" [lit name] ")"]]

method_name: [fn [name] [fld name]]

#
# Helper methods for generating text portably.
#

t_assign: [fn [var val] [hl var ' = ' val t_end]]
t_assign_outer: [fn [var val] 
                    [hl "this.scopes[this.scopes.length - 1]."
                        "set('"
                        var
                        "', "
                        val
                        ")" 
                        t_end]]
t_append: [fn [lst val] [hl lst '.push(' val ')' t_end]]
t_break:  'break;'

t_declare_local_vars: [fn [node] [t_declare_vars node.local_vars]]
t_declare_vars: [fn [vars]
                    [vl [map [fn [v]
                                 [if [strin v ' ']
                                     [hl 'let ' [item [split v ' '] 0] t_end]
                                     [hl 'let ' v t_end]]]
                             vars]]]

t_empty_list: '[]'
t_end: ';'  # statement terminator
t_eq: [fn [x y] [hl x ' === ' y]]
t_false: 'false'
t_if: [fn [cond body] [block [hl 'if (' cond ')'] body]]
t_ifelse: [fn [cond if_body e_body]
              [vl [block [hl 'if (' cond ')'] if_body]
                  [block 'else' e_body]]]
t_ifelifelse: [fn [cond if_body elif_cond elif_body e_body]
              [vl [block [hl 'if (' cond ')'] if_body]
                  [block [hl 'else if (' elif_cond ')'] elif_body]
                  [block 'else' e_body]]]
t_istrue: [fn [v] [hl v ' === true']]
t_isfalse: [fn [v] [hl v ' === false']]
t_list_of_one: [fn [x] [hl '[' x ']']]
t_meth_def: ''
t_meth_self: ''
t_meth_params: [fn [params] params]
t_newscope: 'new Map()'  # value for a new scope (dict[str, any])
t_not: '!'  # the logical operator
t_null: 'null'
t_or: [fn [x y] [hl x ' || ' y]]
t_pop: [fn [x] [hl x '.pop()']]
t_return: 'return;'
t_substr: [fn [s start end] [hl s '.substr(' start ', ' end ')']]
t_throw: [fn [msg] [hl 'throw new ParsingRuntimeError(' msg ')' t_end]]
t_to_str: [fn [x] x]
t_toplevel_extra_sep: null
t_true: 'true'
t_while: [fn [cond body] [block [hl 'while (' cond ')'] body]]

#
# The basic block structure of the file is given in the `generate` template
# in base. This section defines the templates `generate` references.
#

default_header: @"""
    // Generated by pyfloyd version @generator_options.version
    //    https://github.com/dpranke/pyfloyd
    //
    @wrap_argv['//    `' '//    ']
    //
    """

main_header: @"""
    #!/usr/bin/env node
    @default_header[]
    """

parsing_runtime_exception_class: d"""
    class ParsingRuntimeError extends Error {
      toString() {
        return this.message.toString();
      }
    }
    """

operator_state_class: d"""
    class OperatorState {
      constructor() {
        this.currentDepth = 0;
        this.currentPrec = 0;
        this.precOps = {};  // dict[int, [str]]
        this.precs = [];    // list[int]
        this.rassoc = new Set();
        this.choices = {};  // dict[str, grammar.Rule]
      }
    }
    """

result_class: d"""
    class Result {
      constructor(val, err, pos) {
        this.val = val;
        this.err = err;
        this.pos = pos;
      }
    }
    """

parse_function: d"""
    function parse(text, path = '<string>', externs = null) {
      externs = externs || new Map();
      const p = new Parser(text, path);
      return p.parse(externs);
    }
    """

parser_class: @"""
    class Parser {
      @parser_methods[]
    }
    """

parser_constructor: @"""
    constructor(text, path) {
      this.text = text;
      this.end = text.length;
      this.errpos = 0;
      this.failed = false;
      this.path = path;
      this.pos = 0;
      this.val = undefined;
      @externs[]
      @if[generator_options.memoize 'this.cache = new Map();']
      @if[grammar.seeds_needed 'this.seeds = {};']
      @if[grammar.leftrec_needed 'this.blocked = new Set();']
      @if[grammar.lookup_needed 'this.scopes = [];'] 
      @if[grammar.operator_needed
         [vl 'this.operators = {};'
             'let o;'
             [map_items operator_state grammar.operators]]]
    }
    """  # parser_constructor
      
externs: [fn [] [if [dict_is_empty grammar.externs]
                    [vl 'this.externs = new Map();']
                    [vl 'this.externs = new Map(['
                        [ind [map_items [fn [k v]
                                            [hl '['
                                                [lit k]
                                                ', '
                                                [if v 'true' 'false']
                                                '], ']]
                                        grammar.externs]]
                        ']);']]]

operator_state: [fn [rule o]
                    [vl 'o = new OperatorState();'
                        [operator_prec_ops o]
                        [hl 'o.precs = [...o.precOps.keys()].sort('
                            '(a, b) => b - a);']
                        [operator_rassoc o]
                        [operator_choices o]
                        [hl 'this.operators[' [lit rule] '] = o;']]]

operator_prec_ops: [fn [o]
                       [vl 'o.precOps = new Map();'
                           [map [fn [prec]
                                    [hl 'o.precOps.set(' [itoa prec] ', ['
                                        [map [fn [op] [lit op]]
                                             [get o.prec_ops prec]
                                             ', ']
                                        ']);']]
                                [sort [keys o.prec_ops]]]]]

operator_rassoc: [fn [o]
                     [hl 'o.rassoc = new Set(['
                         [comma [map [fn [op] [lit op]] o.rassoc]]
                         ']);']]

operator_choices: [fn [o] [vl 'o.choices = new Map();'
                              [map_items [fn [op meth]
                                             [hl "o.choices.set("
                                                 [lit op]
                                                 ", this."
                                                 meth
                                                 ");"]]
                                         o.choices]]]
 
parse_with_exception: @"""
    parse(externs = null) {
      externs = externs || new Map()  ;
      let errors = '';
      for (let key of externs.keys()) {
        if (!this.externs.has(key)) {
          errors += `Unexpected extern "${key}"\\n`;
        } else {
          this.externs[key] = externs[key];
        }
      }
      if (errors != '') {
        return new Result(null, errors.trim(), 0);
      }

      try {
        this.r_@grammar.starting_rule();

        if (this.failed) {
          return new Result(null, this.o_error(), this.errpos);
        } else {
          return new Result(this.val, null, this.pos);
        }
      } catch (e) {
        if (e instanceof ParsingRuntimeError) {
          let [lineno, _] = this.o_offsets(this.errpos);
          return new Result(null, this.path + ':' + lineno + ' ' + e.toString());
        } else {
          throw e;
        }
      }
    }
    """  # parse_with_exception

parse_without_exception: @"""
    parse(externs = null) {
      externs = externs || new Map();
      let errors = '';
      for (let key of externs.keys()) {
        if (!this.externs.has(key)) {
            errors += `Unexpected extern "${key}"\\n`;
        } else {
            this.externs[key] = externs[key];
        }
      }

      if (errors != '') {
        return new Result(null, errors.trim(), 0);
      }

      this.r_@grammar.starting_rule();

      if (this.failed) {
        return new Result(null, this.o_error(), this.errpos);
      } else {
        return new Result(this.val, null, this.pos);
      }
    }
    """  # parse_without_exception

default_footer: null

main_footer: d""" 
    async function main() {
      const fs = require('fs');
      const path = require('path');

      let filename;
      let s = null;
      let externs = new Map();
      let i = 2;

      while (i < process.argv.length) {
        if (process.argv[i] == '-h' || process.argv[i] == '--help') {
          console.log(`\\
    usage: ${path.basename(process.argv[1])} [-h] [-D var=val] [-c str] [file]

    positional arguments:
      file

    options:
      -h, --help            show this help message and exit
      -c, --code str        use the text in str as input
      -D, --define var=val  define an external var=value (may use multiple times)`);
          process.exit(0);
        }

        if (process.argv[i] == '-D' || process.argv[i] == '--define') {
          let [k, v] = process.argv[i+1].split('=', 2);
          externs.set(k, JSON.parse(v))
          i += 2;
        } else if (process.argv[i] == '-c' || process.argv[i] == '--code') {
          s = process.argv[i+1];
          filename = '<code>';
          break;
        } else {
          break;
        }
      }

      if (s === null) {
        if (process.argv.length == i || process.argv[i] == "-") {
          filename = '<stdin>';
          function readStream(stream) {
            stream.setEncoding("utf8");
            return new Promise((resolve, reject) => {
              let data = "";

              stream.on("data", (chunk) => (data += chunk));
              stream.on("end", () => resolve(data));
              stream.on("error", (error) => reject(error));
            });
          }
          s = await readStream(process.stdin);
        } else {
          filename = process.argv[i];
          s = await fs.promises.readFile(filename);
        }
      }

      let result = parse(s.toString(), filename, externs);

      let txt, stream, ret;
      if (result.err != undefined) {
        txt = result.err;
        stream = process.stderr;
        ret = 1;
      } else {
        txt = JSON.stringify(result.val, null, 2);
        stream = process.stdout;
        ret = 0;
      }
      await new Promise(function(resolve, reject) {
        stream.write(txt + '\\n', 'utf8', function(err, data) {
          if (err != null) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      });
      process.exit(ret);
    }

    if (typeof process !== "undefined" && process.release.name === "node") {
      (async () => {
        main();
      })();
    }
    """  # main_footer

#
# Language-specific rules for nodes in the AST.
#

n_regexp: [fn [node]
              [vl [hl "r = new RegExp(" [lit node.v] ", 'gy');"]
                  'r.lastIndex = this.pos;'
                  'found = r.exec(this.text);'
                  'if (found) {'
                  '  this.o_succeed(found[0], this.pos + found[0].length);'
                  '  return;'
                  '}'
                  'this.o_fail();']]

n_set: [fn [node]
           [vl [hl "r = new RegExp(" 
                   [lit [strcat '[' node.v  ']' ]]
                   ", 'gy');"]
               'r.lastIndex = this.pos;'
               'found = r.exec(this.text);'
               'if (found) {'
               '  this.o_succeed(found[0], this.pos + found[0].length);'
               '  return;'
               '}'
               'this.o_fail();']]

#
# Built-in operators and rules
#

r_any: [meth q[] d"""
    if (this.pos < this.end) {
      this.o_succeed(this.text[this.pos], this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

r_end: [meth q[] d"""
    if (this.pos === this.end) {
      this.o_succeed(null, this.pos);
    } else {
      this.o_fail();
    }
    """]

o_ch: [meth q['c'] d"""
    let pos = this.pos;
    if (pos < this.end && this.text[pos] === c) {
      this.o_succeed(c, this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

o_offsets: [meth q['pos'] d"""
    let lineno = 1;
    let colno = 1;
    for (let i = 0; i < pos; i++) {
      if (this.text[i] === '\\n') {
        lineno += 1;
        colno = 1;
      } else {
        colno += 1;
      }
    }
    return [lineno, colno];
    """]

o_error: [meth q[] d"""
    let [lineno, colno] = this.o_offsets(this.errpos);
    let thing;
    if (this.errpos === this.end) {
      thing = 'end of input';
    } else {
      thing = JSON.stringify(this.text[this.errpos]);
    }
    return `${this.path}:${lineno} Unexpected ${thing} at column ${colno}`;
    """]

o_fail: [meth q[] d"""
    this.val = undefined;
    this.failed = true;
    this.errpos = Math.max(this.errpos, this.pos);
    """]

o_leftrec: [meth q['rule' 'rule_name' 'left_assoc'] d"""
    let pos = this.pos;
    let key = [rule_name, pos];
    let seed = this.seeds[key];
    if (seed) {
      [this.val, this.failed, this.pos] = seed;
      return;
    }
    if (this.blocked.has(rule_name)) {
      this.val = undefined;
      this.failed = true;
      return;
    }
    let current = [undefined, true, this.pos];
    this.seeds[key] = current;
    if (left_assoc) {
      this.blocked.add(rule_name);
    }
    while (true) {
      rule.call(this);
      if (this.pos > current[2]) {
        current = [this.val, this.failed, this.pos];
        this.seeds[key] = current;
        this.pos = pos;
      } else {
        delete this.seeds[key];
        [this.val, this.failed, this.pos] = current;
        if (left_assoc) {
          this.blocked.delete(rule_name);
        }
        return;
      }
    }
    """]  # o_leftrec
    
o_lookup: [meth q['v'] d"""
    let l = this.scopes.length - 1;
    while (l >= 0) {
      if (this.scopes[l].has(v)) {
        return this.scopes[l].get(v);
      }
      l -= 1;
    }
    if (this.externs.has(v)) {
      return this.externs.get(v);
    }
    throw new ParsingRuntimeError(`Unknown var "${v}"`);
    """]

o_memoize: [meth q['rule_name' 'fn'] d"""
    let pos = this.pos;
    if (!this.cache.has(pos)) {
      this.cache.set(pos, new Map());
    }
    let c = this.cache.get(pos);
    if (c.has(rule_name)) {
      [this.val, this.failed, this.pos] = c.get(rule_name);
      return;
    }
    fn.call(this);
    c.set(rule_name, [this.val, this.failed, this.pos]);
   """]

o_operator: [meth q['rule_name'] d"""
    let o = this.operators[rule_name];
    let pos = this.pos;
    let key = [rule_name, pos];
    let seed = this.seeds[key];
    if (seed) {
      [this.val, this.failed, this.pos] = seed;
      return;
    }
    o.currentDepth += 1;
    let current = [null, true, pos];
    this.seeds[key] = current;
    let minPrec = o.currentPrec;
    let i = 0;
    while (i < o.precs.length) {
      let repeat = false;
      let prec = o.precs[i];
      let precOps = o.precOps.get(prec);
      if (prec < minPrec) {
        break;
      }
      o.currentPrec = prec;
      if (!o.rassoc.has(precOps[0])) {
        o.currentPrec += 1;
      }
      for (let j = 0; j < precOps.length; j += 1) {
        let op = precOps[j];
        o.choices.get(op).call(this);
        if (!this.failed && this.pos > pos) {
          current = [this.val, this.failed, this.pos];
          this.seeds[key] = current;
          repeat = true;
          break;
        }
        this.o_rewind(pos);
      }
      if (!repeat) {
        i += 1;
      }
    }
    delete this.seeds[key];
    o.currentDepth -= 1;
    if (o.currentDepth === 0) {
      o.currentPrec = 0;
    }
    [this.val, this.failed, this.pos] = current;
    """]  # o_operator

o_range: [meth q['i' 'j'] d"""
    let pos = this.pos;
    if (pos == this.end) {
      this.o_fail();
      return;
    }
    let c = this.text[pos];
    if (i <= c && c <= j) {
      this.o_succeed(this.text[pos], this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

o_rewind: [meth q['newpos'] 'this.o_succeed(null, newpos);']

o_str: [meth q['s'] d"""
   for (let ch of s) {
     this.o_ch(ch);
     if (this.failed) {
       return;
     }
   }
   this.val = s;
   """]

o_succeed: [meth q['v' 'newpos'] d"""
   this.val = v;
   this.failed = false;
   if (newpos !== null) {
     this.pos = newpos;
   }
   """]

o_unicat: [meth q['cat'] d"""
    if (this.pos == this.end) {
      this.o_fail();
      return
    }
    let c = this.text[this.pos];
    let re = new RegExp(`\\\\p{${cat}}`, 'u');
    if (c.match(re)) {
      this.o_succeed(c, this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

fn_atof: [meth q['a'] 'return parseFloat(a);']

fn_atoi: [meth q['a' 'base'] 'return parseInt(a, base);']

fn_atou: [meth q['a' 'base']
               'return String.fromCharCode(Number.parseInt(a, base));']

fn_cat: [meth q['ss'] "return ss.join('');"]

fn_colno: [
    meth q[] d"""
          let colno = 0;
          if (this.pos == this.end) {
            colno += 1;
          }
          while (this.pos >= colno && this.text[this.pos - colno] != '\\n') {
            colno += 1;
          }
          return colno;
          """]

fn_concat: [meth q['xs' 'ys'] 'return xs.concat(ys);']

fn_cons: [meth q['hd' 'tl'] 'return [hd].concat(tl);']

fn_dedent: [meth q['s'] 'return s;']

fn_dict: [meth q['pairs'] d"""
    let m = new Map();
    for (let [k, v] of pairs) {
      m[k] = v;  // TODO: m.set(k, v) doesn't work?
    }
    return m;
    """]

fn_itou: [meth q['n'] 'return String.fromCharCode(n);']

fn_join: [meth q['s' 'vs'] 'return vs.join(s);']

fn_scat: [meth q['ss'] "return ss.join('');"]

fn_scons: [meth q['hd' 'tl'] 'return [hd].concat(tl);']

fn_strcat: [meth q['a' 'b'] 'return a.concat(b);']

fn_ulookup: [meth q['s'] d"""
    throw new ParsingRuntimeError('Unsupported function "ulookup"');
    """]

fn_utoi: [meth q['s'] 'return s.charCodeAt(0);']

fn_xtoi: [meth q['s'] 'return Number.parseInt(s, 16);']

fn_xtou: [meth q['s'] 'return String.fromCharCode(Number.parseInt(s, 16));']

}
