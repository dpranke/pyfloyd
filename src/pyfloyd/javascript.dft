# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file contains the code generation templates for JavaScript.
# It depends on a base set of templates used by fairly similar languages.

name = 'JavaScript'
ext = 'js'
indent = 2 
line_length = 79

starting_template: 'generate'

inherit: ['base']

# List the names of each local variable used in a given AST node;
# the generator will use this map to walk the AST and populate the
# list of vars that need to be declared up front in each rule.
local_vars: {
    choice: [pos]
    count: [cmin cmax i vs]
    not: [errpos pos]
    not_one: [errpos pos]
    opt: [pos]
    plus: [pos vs]
    pred: [v]
    regexp: [found r]
    run: [end start]
    set: [found r]
    star: [pos vs]
}

templates = {

#
# Helper rules
#

# Define a method based on the template name (used for builtins)
meth: [fn params [if [equal [length params] 1]
                     [vl [hl _t_name '() {']
                         [ind [getitem params 0]]
                         [hl '}']]
                     [vl [hl _t_name '(' [getitem params 0] ') {']
                         [ind [getitem params 1]]
                         [hl '}']]]]

# define a method for the given rule
rule_method: [fn [rule node] [vl [strcat rule '() {']
                                 [ind [vl [t_local_vars node.local_vars]
                                          [stmts node]]]
                                 '}']]

# How to refer to different types of identifiers:

# Returns a field or method on the generated parse object.
fld: [fn [name] [strcat 'this.' name]]

f_pos: [fld 'pos']
f_errpos: [fld 'errpos']
f_val: [fld 'val']
failed: [fld 'failed']

extern: [fn [name] [strcat "this.externs.get(" [lit name] ")"]]

method_name: [fn [name] [fld name]]

block: [fn [head body] [vl [hl head ' {'] [ind body] '}']]

# Invoke a method on the parser object.
call: [fn [name args] [tri [strcat [method_name name] '(']
                           [comma args]
                           ')']]

#
# Helper methods for generating text portably.
#

t_assign: [fn [var val] [hl var ' = ' val t_end]]
t_assign_outer: [fn [var val] 
                    [hl "this.scopes[this.scopes.length - 1]."
                        "set('"
                        var
                        "', "
                        val
                        ")" 
                        t_end]]

t_append: [fn [lst val] [hl lst '.push(' val ')' t_end]]
t_break:  'break;'
t_end: ';'  # statement terminator
t_false: 'false'
t_newmap: 'new Map()'
t_not: '!'  # the logical operator
t_null: 'null'
t_true: 'true'
t_eq: [fn [x y] [hl x ' === ' y]]
t_if: [fn [cond body] [block [hl 'if (' cond ')'] body]]
t_ifelse: [fn [cond if_body e_body]
              [vl [block [hl 'if (' cond ')'] if_body]
                  [block 'else' e_body]]]
t_ifelifelse: [fn [cond if_body elif_cond elif_body e_body]
              [vl [block [hl 'if (' cond ')'] if_body]
                  [block [hl 'else if (' elif_cond ')'] elif_body]
                  [block 'else' e_body]]]
t_istrue: [fn [v] [hl v ' === true']]
t_isfalse: [fn [v] [hl v ' === false']]
t_local_vars: [fn [vars] [vl_l [map [fn [v] [hl 'let ' v t_end]]
                                        vars]]]
t_or: [fn [x y] [hl x ' || ' y]]
t_pop: [fn [x] [hl x '.pop()']]
t_return: 'return;'
t_substr: [fn [s start end] [hl s '.substr(' start ', ' end ')']]
t_throw: [fn [msg] [hl 'throw new ParsingRuntimeError(' msg ')' t_end]]
t_while: [fn [cond body] [block [hl 'while (' cond ')'] body]]

#
# The basic block structure of the file is given in the `generate` template
# in base. This section defines the templates `generate` references.
#

main_header: @"""
    #!/usr/bin/env node
    //
    // Generated by pyfloyd version @generator_options.version
    //    https://github.com/dpranke/pyfloyd
    //    `pyfloyd @generator_options.command_line`
    """
    
default_header: @"""
    // Generated by pyfloyd version @generator_options.version
    //    https://github.com/dpranke/pyfloyd
    //    `pyfloyd @generator_options.command_line`
    """
           
parsing_runtime_exception_class: d"""
    class ParsingRuntimeError extends Error {
      toString() {
        return this.message.toString();
      }
    }
    """

operator_state_class: d"""
    class OperatorState {
      constructor() {
        this.currentDepth = 0
        this.currentPrec = 0
        this.precOps = {}  // dict[int, [str]]
        this.precs = []    // list[int]
        this.rassoc = new Set()
        this.choices = {}  // dict[str, Rule]
      }
    }
    """

result_class: d"""
    class Result {
      constructor(val, err, pos) {
        this.val = val;
        this.err = err;
        this.pos = pos;
      }
    }
    """

parse_function: d"""
    function parse(text, path = '<string>', externs = null) {
      externs = externs || new Map();
      const p = new Parser(text, path);
      return p.parse(externs);
    }
    """

parser_class: @"""
    class Parser {
      @parser_constructor[]
      @parser_methods[]
    }
    """

parser_constructor: @"""
    constructor(text, path) {
      this.text = text;
      this.end = text.length;
      this.errpos = 0;
      this.failed = false;
      this.path = path;
      this.pos = 0;
      this.val = undefined;
      this.externs = new Map();
      @externs[]
      @if[generator_options.memoize 'this.cache = new Map();' null]
      @if[grammar.seeds_needed 'this.seeds = {};' null]
      @if[grammar.leftrec_needed 'this.blocked = new Set();' null]
      @if[grammar.lookup_needed 'this.scopes = [];' null] 
      @if[grammar.operator_needed
         [vl 'this.operators = {};'
             'let o;'
             [vl_l [map_items operator_state grammar.operators]]]
         [vl]]
    }

    """  # parser_constructor
      
externs: [fn [] [vl_l [map_items [fn [k v]
                                     [strcat "this.externs.set('"
                                             k
                                             "', " [if v 'true' 'false']
                                             ");"]]
                                 grammar.externs]]]

operator_state: [fn [rule o]
                    [vl 'o = new OperatorState();'
                        'o.precOps = new Map();'
                        [operator_prec o]
                        [hl 'o.precs = [...o.precOps.keys()].sort('
                            '(a, b) => b - a);']
                        [operator_rassoc o]
                        'o.choices = new Map();'
                        [ind_l [operator_choices o]]
                        [hl 'this.operators[' [lit rule] '] = o;']]]

operator_prec: [fn [o]
                   [vl_l [map [fn [prec]
                                  [hl 'o.precOps.set(' [to_string prec] ', ['
                                      [hl_l [map [fn [op] [lit op]]
                                                 [getitem o.prec_ops prec]
                                                 ', ']]
                                      ']);']]
                              [sort [keys o.prec_ops]]]]]

operator_rassoc: [fn [o]
                     [hl 'o.rassoc = new Set(['
                         [comma  [map [fn [op] [strcat "'" op "'"]]
                                      o.rassoc]]
                         '])']]

operator_choices: [fn [o]
                      [map_items [fn [op meth]
                                     [hl "o.choices.set(" 
                                         [lit op] 
                                         ", this."
                                         meth
                                         ");"]]
                                 o.choices]]
 
parse_with_exception: @"""
    parse(externs = null) {
      externs = externs || new Map();
      let errors = '';
      for (let key of externs.keys()) {
        if (!this.externs.has(key)) {
          errors += `Unexpected extern "${key}"\\n`;
        } else {
          this.externs[key] = externs[key];
        }
      }
      if (errors != '') {
        return new Result(null, errors.trim(), 0);
      }

      try {
        this.r_@grammar.starting_rule();

        if (this.failed) {
          return new Result(null, this.o_error(), this.errpos);
        } else {
          return new Result(this.val, null, this.pos);
        }
      } catch (e) {
        if (e instanceof ParsingRuntimeError) {
          let [lineno, _] = this.o_offsets(this.errpos);
          return new Result(null, this.path + ':' + lineno + ' ' + e.toString());
        } else {
          throw e;
        }
      }
    }
    """  # parse_with_exception

parse_without_exception: @"""
    parse(externs = null) {
      externs = externs || new Map();
      let errors = '';
      for (let key of externs.keys()) {
        if (!this.externs.has(key)) {
            errors += `Unexpected extern "${key}"\\n`;
        } else {
            this.externs[key] = externs[key];
        }
      }

      if (errors != '') {
        return new Result(null, errors.trim(), 0);
      }

      this.r_@grammar.starting_rule();

      if (this.failed) {
        return new Result(null, this.o_error(), this.errpos);
      } else {
        return new Result(this.val, null, this.pos);
      }
    }
    """  # parse_without_exception

default_footer: null

main_footer: d""" 
    async function main() {
      const fs = require('fs');
      const path = require('path');

      let filename;
      let s = null;
      let externs = new Map();
      let i = 2;

      while (i < process.argv.length) {
        if (process.argv[i] == '-h' || process.argv[i] == '--help') {
          console.log(`\\
    usage: ${path.basename(process.argv[1])} [-h] [-D var=val] [-c str] [file]

    positional arguments:
      file

    options:
      -h, --help            show this help message and exit
      -c, --code str        use the text in str as input
      -D, --define var=val  define an external var=value (may use multiple times)`);
          process.exit(0);
        }

        if (process.argv[i] == '-D' || process.argv[i] == '--define') {
          let [k, v] = process.argv[i+1].split('=', 2);
          externs.set(k, JSON.parse(v))
          i += 2;
        } else if (process.argv[i] == '-c' || process.argv[i] == '--code') {
          s = process.argv[i+1];
          filename = '<code>';
          break;
        } else {
          break;
        }
      }

      if (s === null) {
        if (process.argv.length == i || process.argv[i] == "-") {
          filename = '<stdin>';
          function readStream(stream) {
            stream.setEncoding("utf8");
            return new Promise((resolve, reject) => {
              let data = "";

              stream.on("data", (chunk) => (data += chunk));
              stream.on("end", () => resolve(data));
              stream.on("error", (error) => reject(error));
            });
          }
          s = await readStream(process.stdin);
        } else {
          filename = process.argv[i];
          s = await fs.promises.readFile(filename);
        }
      }

      let result = parse(s.toString(), filename, externs);

      let txt, stream, ret;
      if (result.err != undefined) {
        txt = result.err;
        stream = process.stderr;
        ret = 1;
      } else {
        txt = JSON.stringify(result.val, null, 2);
        stream = process.stdout;
        ret = 0;
      }
      await new Promise(function(resolve, reject) {
        stream.write(txt + '\\n', 'utf8', function(err, data) {
          if (err != null) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      });
      process.exit(ret);
    }

    if (typeof process !== "undefined" && process.release.name === "node") {
      (async () => {
        main();
      })();
    }
    """  # main_footer

#
# Language-specific rules for nodes in the AST.
#

n_regexp: [fn [node]
              [vl [hl "r = new RegExp(" [lit node.v] ", 'gy');"]
                  'r.lastIndex = this.pos;'
                  'found = r.exec(this.text);'
                  'if (found) {'
                  '  this.o_succeed(found[0], this.pos + found[0].length);'
                  '  return;'
                  '}'
                  'this.o_fail();']]

n_set: [fn [node]
           [vl [hl "r = new RegExp(" 
                   [lit [strcat '[' node.v  ']' ]]
                   ", 'gy');"]
               'r.lastIndex = this.pos;'
               'found = r.exec(this.text);'
               'if (found) {'
               '  this.o_succeed(found[0], this.pos + found[0].length);'
               '  return;'
               '}'
               'this.o_fail();']]

#
# Built-in operators and rules
#

r_any: [meth d"""
    if (this.pos < this.end) {
      this.o_succeed(this.text[this.pos], this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

r_end: [meth d"""
    if (this.pos === this.end) {
      this.o_succeed(null);
    } else {
      this.o_fail();
    }
    """]

o_ch: [meth 'c' d"""
    let pos = this.pos;
    if (pos < this.end && this.text[pos] === c) {
      this.o_succeed(c, this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

o_offsets: [meth 'pos' d"""
    let lineno = 1;
    let colno = 1;
    for (let i = 0; i < pos; i++) {
      if (this.text[i] === '\\n') {
        lineno += 1;
        colno = 1;
      } else {
        colno += 1;
      }
    }
    return [lineno, colno];
    """]

o_error: [meth d"""
    let [lineno, colno] = this.o_offsets(this.errpos);
    let thing;
    if (this.errpos === this.end) {
      thing = 'end of input';
    } else {
      thing = JSON.stringify(this.text[this.errpos]);
    }
    return `${this.path}:${lineno} Unexpected ${thing} at column ${colno}`;
    """]

o_fail: [meth d"""
    this.val = undefined;
    this.failed = true;
    this.errpos = Math.max(this.errpos, this.pos);
    """]

o_leftrec: [meth 'rule, rule_name, left_assoc' d"""
    let pos = this.pos;
    let key = [rule_name, pos];
    let seed = this.seeds[key];
    if (seed) {
      [this.val, this.failed, this.pos] = seed;
      return;
    }
    if (this.blocked.has(rule_name)) {
      this.val = undefined;
      this.failed = true;
      return;
    }
    let current = [undefined, true, this.pos];
    this.seeds[key] = current;
    if (left_assoc) {
      this.blocked.add(rule_name);
    }
    while (true) {
      rule.call(this);
      if (this.pos > current[2]) {
        current = [this.val, this.failed, this.pos];
        this.seeds[key] = current;
        this.pos = pos;
      } else {
        delete this.seeds[key];
        [this.val, this.failed, this.pos] = current;
        if (left_assoc) {
          this.blocked.delete(rule_name);
        }
        return;
      }
    }
    """]  # o_leftrec
    
o_lookup: [meth 'v' d"""
    let l = this.scopes.length - 1;
    while (l >= 0) {
      if (this.scopes[l].has(v)) {
        return this.scopes[l].get(v);
      }
      l -= 1;
    }
    if (this.externs.has(v)) {
      return this.externs.get(v);
    }
    throw new ParsingRuntimeError(`Unknown var "${v}"`);
    """]

o_memoize: [meth 'rule_name, fn' d"""
    let pos = this.pos;
    if (!this.cache.has(pos)) {
      this.cache.set(pos, new Map());
    }
    if (this.cache.get(pos).has(rule_name)) {
      [this.val, this.failed, this.pos] = this.cache.get(pos).get(rule_name);
      return;
    }
    fn.call(this);
    this.cache.get(pos).set(rule_name, [this.val, this.failed, this.pos]);
   """]

o_operator: [meth 'rule_name' d"""
    let o = this.operators[rule_name];
    let pos = this.pos;
    let key = [rule_name, pos];
    let seed = this.seeds[key];
    if (seed) {
      [this.val, this.failed, this.pos] = seed;
      return;
    }
    o.currentDepth += 1;
    let current = [null, true, pos];
    this.seeds[key] = current;
    let minPrec = o.currentPrec;
    let i = 0;
    while (i < o.precs.length) {
      let repeat = false;
      let prec = o.precs[i];
      let precOps = o.precOps.get(prec);
      if (prec < minPrec) {
        break;
      }
      o.currentPrec = prec;
      if (!o.rassoc.has(precOps[0])) {
        o.currentPrec += 1;
      }
      for (let j = 0; j < precOps.length; j += 1) {
        let op = precOps[j];
        o.choices.get(op).call(this);
        if (!this.failed && this.pos > pos) {
          current = [this.val, this.failed, this.pos];
          this.seeds[key] = current;
          repeat = true;
          break;
        }
        this.o_rewind(pos);
      }
      if (!repeat) {
        i += 1;
      }
    }
    delete this.seeds[key];
    o.currentDepth -= 1;
    if (o.currentDepth === 0) {
      o.currentPrec = 0;
    }
    [this.val, this.failed, this.pos] = current;
    """]  # o_operator

o_range: [meth 'i, j' d"""
    let pos = this.pos;
    if (pos == this.end) {
      this.o_fail();
      return;
    }
    let c = this.text[pos];
    if (i <= c && c <= j) {
      this.o_succeed(this.text[pos], this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

o_rewind: [meth 'newpos' 'this.o_succeed(null, newpos);']

o_str: [meth 's' d"""
   for (let ch of s) {
     this.o_ch(ch);
     if (this.failed) {
       return;
     }
   }
   this.val = s;
   """]

o_succeed: [meth 'v, newpos = null' d"""
   this.val = v;
   this.failed = false;
   if (newpos !== null) {
     this.pos = newpos;
   }
   """]

o_unicat: [meth 'cat' d"""
    if (this.pos == this.end) {
      this.o_fail();
      return
    }
    let c = this.text[this.pos];
    let re = new RegExp(`\\\\p{${cat}}`, 'u');
    if (c.match(re)) {
      this.o_succeed(c, this.pos + 1);
    } else {
      this.o_fail();
    }
    """]

fn_atof: [meth 'a' 'return parseFloat(a);']

fn_atoi: [meth 'a, base' 'return parseInt(a, base);']

fn_atou: [meth 'a, base' 
               'return String.fromCharCode(Number.parseInt(a, base));']

fn_cat: [meth 'ss' "return ss.join('');"]

fn_concat: [meth 'xs, ys' 'return xs.concat(ys);']

fn_cons: [meth 'hd, tl' 'return [hd].concat(tl);']

fn_dedent: [meth 's' 'return s;']

fn_dict: [meth 'pairs' d"""
    let m = new Map();
    for (let [k, v] of pairs) {
      m[k] = v;
    }
    return m;
    """]

fn_itou: [meth 'n' 'return String.fromCharCode(n);']

fn_join: [meth 's, vs' 'return vs.join(s);']

fn_scat: [meth 'ss' "return ss.join('');"]

fn_scons: [meth 'hd, tl' 'return [hd].concat(tl);']

fn_strcat: [meth 'a, b' 'return a.concat(b);']

fn_unicode_lookup: [meth 's' d"""
    throw new ParsingRuntimeError('Unsupported function "unicode_lookup"');
    """]

fn_utoi: [meth 's' 'return s.charCodeAt(0);']

fn_xtoi: [meth 's' 'return Number.parseInt(s, 16);']

fn_xtou: [meth 's' 'return String.fromCharCode(Number.parseInt(s, 16));']

}