# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file a set of base code generation templates appropriate for many
# dynamically typed, block structured, garbage collected languages.

# These two values must be overridden by other templates.

# Name of the language being generated, e.g., "Python"
name = null

# File extension used by the language, e.g. "py" (no leading dot)
ext = null

# indent for blocks (int number of spaces or a string value)
indent = 2

# Maximum line length; can use `null` for no maximum.
line_length = 79

templates = {

#
# Helper methods
#

# Generates code for a host expression node in the AST. Returns a `formatter.El`.
expr:      [fn [node] [invoke [node_name node.t] node]]

# Generates code for a statement node in the AST. Returns a `formatter.El`.
stmts:     [fn [node] [invoke [node_name node.t] node]]

# Invokes a template that takes a single argument, an AST node.
invoke_node: [fn [node] [invoke [node_name node.t] node]]

# Templates for how to refer to different kinds of things.

# Returns the identifier for a method or template used for a particular type of AST
# node during code generation. It does not refer to things in the generated output.
node_name: [fn [name] [strcat 'n_' name]]

# Returns the identifier used for built-in operators like `succeed` and `leftrec` in
# the output. May be used both to identify a template and as part of identifying
# a method in the generated output.
op_name:   [fn [name] [strcat 'o_' name]]

# The name used for a built-in function like `strcat`. Maybe be used both to 
# identify a template and as part of identifying a method in the generated output.
fn_name:   [fn [name] [strcat 'fn_' name]]

# Return the identifier for a local variable like `x` or `$1`. Usually `v_x` or `v_1`.
local_var: [fn [name] [strcat 'v_' [replace name '$' '_']]]

# Returns a string that will reference a field or method on the main object.
thisref: [fn [name] ['self.' name]]

# The name for a rule in the output; rules names either correspond to a production
# in the grammar, in which case it will be named with an `r_` prefix (e.g.
# `grammar` -> `r_grammar`), or a derived subrule (part of the production), in
# which case it'll be named with an `s_` prefix.
rule_name: [fn [name] name]

# Returns a formatter.El that will invoke a method on the parser object.
call:      [fn [name args] [tri [strcat [method_name name] '(']
                                [comma args]
                                ')']]

# Invoke specific kinds of methods on the generated parser object.
call_op:   [fn [name args] [call [op_name name] args]]
call_rule: [fn [name args] [call [rule_name name] args]]

succeed: [fn args [hl [call [op_name 'succeed'] args] c_end]]
rewind: [fn [pos] [hl [call [op_name 'rewind'] [list pos] c_end]]]
fail: [fn [] [hl [call [op_name 'fail'] q[]] c_end]]

# Helper methods that must be overridden in sub-grammars:

# Generates the code that defines a rule method on the parser.
rule_method: null

# Returns a string that will return the value of an extern like `allow_trailing`.
# Might return something like `this.externs['allow_trailing']`.
extern: null

#
# Starting rule
#

#
# 'generate' is invoked to generate the file from the AST. It 
# establishes the general layout of the file and defines the major
# sections that a language needs to implement.
#

generate: @"
    @if[generator_options.main [main_header] [default_header]]
    @if[grammar.exception_needed 
        [vl '' '' parsing_runtime_exception_class]
        [vl]]
    @if[grammar.operators
        [vl '' '' operator_state_class]
        [vl]]

    @result_class

    @parse_function

    @parser_class[]
    @if[generator_options.main main_footer default_footer]
    "

parser_methods: [fn [] [vl [parse_method]
                           [vl_l [map_items [fn [rule node]
                                                [vl ''
                                                    [rule_method rule node]]]
                                            grammar.rules]]
                           [vl_l [map [fn [name]
                                          [vl '\n'
                                              [invoke [strcat 'r_' name]]]]
                                      grammar.needed_builtin_rules]]
                           [vl_l [map [fn [name]
                                          [vl ''
                                              [invoke [op_name name]]]]
                                      grammar.needed_operators]]
                           [vl_l [map [fn [name]
                                          [vl '\n'
                                              [invoke [fn_name name]]]]
                                      grammar.needed_builtin_functions]]]]

parse_method: [fn [] [if grammar.exception_needed
                         [parse_with_exception]
                         [parse_without_exception]]]

#
# Rules for nodes in the AST that are basically the same across languages
#

n_action: [fn [node] [succeed [expr node.child]]]

n_apply: [fn [node]
             [if node.memoize
                 [hl [call_op 'memoize' [list [lit node.rule_name]
                                              [method_name node.rule_name]]]
                     c_end]
                 [hl [call_rule node.rule_name q[]] c_end]]]

n_e_arr: [fn [node] [if [is_empty node.ch]
                        '[]'
                        [tri '['
                             [comma [map [fn [c] [expr c]] node.ch]]
                             ']']]]

n_e_call: [fn [node] [tri '(' [comma [map [fn [c] [expr c]] node.ch]] ')']]

n_e_const: [fn [node] [invoke [strcat 'c_' node.v]]]

n_e_getitem: [fn [node] [tri '[' [expr node.child] ']']]

n_e_ident: [fn [node] [if [equal node.kind 'outer']
                          [call_op 'lookup' [list [lit node.v]]]
                          [if [equal node.kind 'extern']
                              [extern node.v]
                              [if [equal node.kind 'function']
                                  [method_name [fn_name node.v]]
                                  [local_var node.v]]]]]

n_e_lit: [fn [node] [lit node.v]]

n_e_minus: [fn [node] [tree [expr node.left] '-' [expr node.right]]]

n_e_not: [fn [node] [tree null c_not [expr node.child]]]

n_e_num: [fn [node] node.v]

n_e_paren: [fn [node] [expr node.child]]

n_e_plus: [fn [node] [tree [expr node.left] '+' [expr node.right]]]

n_e_qual: [fn [node] [saw [map [fn [n] [invoke_node n]] node.ch]]]

n_empty: [fn [node] [succeed c_null]]

n_equals: [fn [node] [hl [call_op 'str' [list [expr node.child]] c_end]]]

n_leftrec: [fn [node] [hl [call_op 'leftrec'
                                   [list [method_name node.child.v]
                                         [lit node.v]
                                         [if node.left_assoc c_true c_false]]]
                           c_end]]

n_lit: [fn [node] [hl [if [equal [strlen node.v] 1]
                          [call_op 'ch' [list [lit node.v]]]
                          [call_op 'str' [list [lit node.v]]]]
                      c_end]]

n_operator: [fn [node] [hl [call_op 'operator' [list [lit node.v]] c_end]]]

n_paren: [fn [node] [stmts node.child]]

n_range: [fn [node] [hl [call_op 'range'
                                 [list [lit node.start] [lit node.stop]]]
                        c_end]]

n_unicat: [fn [node] [hl [call_op 'unicat' [list [lit node.v]]] c_end]]

}
