# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file a set of base code generation templates appropriate for many
# dynamically typed, block structured, garbage collected languages.

# These two values must be overridden by other templates.

# Name of the language being generated, e.g., "Python"
name = null

# File extension used by the language, e.g. "py" (no leading dot)
ext = null

# indent for blocks (int number of spaces or a string value)
indent = 2

# Maximum line length; can use `null` for no maximum.
line_length = 79

# List the names of each local variable used in a given AST node;
# the generator will use this map to walk the AST and populate the
# list of vars that need to be declared up front in each rule.
local_vars: {
    choice: [pos]
    count: [cmin cmax i vs]
    not: [errpos pos]
    not_one: [errpos pos]
    opt: [pos]
    plus: [pos vs]
    pred: [v]
    regexp: [found r]
    run: [end start]
    set: [found r]
    star: [pos vs]
}

templates = {

#
# Helper methods
#

meth: [fn params [block [hl t_meth_def
                            _t_name
                             '('
                             [t_meth_params [if [equal [length params] 2]
                                                [getitem params 0]
                                                '']]
                             ')']
                        [getitem params -1]]]

rule_method: [fn [rule node]
                 [block [hl t_meth_def rule '(' [t_meth_params ''] ')']
                        [vl [t_declare_local_vars node]
                            [stmts node]]]]

# Generates code for a host expression node in the AST. Returns a `formatter.El`.
expr:      [fn [node] [invoke [node_name node.t] node]]

# Generates code for a statement node in the AST. Returns a `formatter.El`.
stmts:     [fn [node] [invoke [node_name node.t] node]]

# Templates for how to refer to different kinds of things.

# Returns the identifier for a method or template used for a particular type of AST
# node during code generation. It does not refer to things in the generated output.
node_name: [fn [name] [strcat 'n_' name]]

# Returns the identifier used for built-in operators like `succeed` and `leftrec` in
# the output. May be used both to identify a template and as part of identifying
# a method in the generated output.
op_name:   [fn [name] [strcat 'o_' name]]

# The name used for a built-in function like `strcat`. Maybe be used both to 
# identify a template and as part of identifying a method in the generated output.
fn_name:   [fn [name] [strcat 'fn_' name]]

# Return the identifier for a local variable like `x` or `$1`. Usually `v_x` or `v_1`.
local_var: [fn [name] [strcat 'v_' [replace name '$' '_']]]

# The name for a rule in the output; rules names either correspond to a production
# in the grammar, in which case it will be named with an `r_` prefix (e.g.
# `grammar` -> `r_grammar`), or a derived subrule (part of the production), in
# which case it'll be named with an `s_` prefix.
rule_name: [fn [name] name]

# Returns a formatter.El that will invoke a method on the parser object.
call:      [fn [name args] [tri [strcat [method_name name] '(']
                                [comma args]
                                ')']]

# Invoke specific kinds of methods on the generated parser object.
call_op:   [fn [name args] [call [op_name name] args]]
call_rule: [fn [name args] [call [rule_name name] args]]

succeed: [fn args [hl [call [op_name 'succeed'] args] t_end]]
rewind: [fn [pos] [hl [call [op_name 'rewind'] [list pos] t_end]]]
fail: [fn [] [hl [call [op_name 'fail'] q[]] t_end]]

break_if_failed: [fn [node] [if node.can_fail [t_if failed t_break]]]
break_if_not_failed: [fn [node] [if node.can_fail
                                    [t_if [hl t_not failed] t_break]]]
return_if_failed: [fn [node] [if node.can_fail [t_if failed t_return]]]
return_if_not_failed: [fn [node] [if node.can_fail
                                     [t_if [hl t_not failed] t_return]]]

# Helper methods that must be overridden in sub-grammars:

# Returns a string that will return the value of an extern like `allow_trailing`.
# Might return something like `this.externs['allow_trailing']`.
extern: null

#
# Starting rule
#

#
# 'generate' is invoked to generate the file from the AST. It 
# establishes the general layout of the file and defines the major
# sections that a language needs to implement.
#

generate: @"
    @if[generator_options.main [main_header] [default_header]]
    @if[grammar.exception_needed 
        [vl '' '' parsing_runtime_exception_class]
        [vl]]
    @if[grammar.operators
        [vl '' '' operator_state_class]
        [vl]]

    @result_class

    @parse_function

    @parser_class[]
    @if[generator_options.main main_footer default_footer]
    "

parser_methods: [fn [] [vl [parse_method]
                           [vl_l [map_items [fn [rule node]
                                                [vl ''
                                                    [rule_method rule node]]]
                                            grammar.rules]]
                           [vl_l [map [fn [name]
                                          [vl '\n'
                                              [invoke [strcat 'r_' name]]]]
                                      grammar.needed_builtin_rules]]
                           [vl_l [map [fn [name]
                                          [vl ''
                                              [invoke [op_name name]]]]
                                      grammar.needed_operators]]
                           [vl_l [map [fn [name]
                                          [vl '\n'
                                              [invoke [fn_name name]]]]
                                      grammar.needed_builtin_functions]]]]

parse_method: [fn [] [if grammar.exception_needed
                         [parse_with_exception]
                         [parse_without_exception]]]

#
# Rules for nodes in the AST that are basically the same across languages
#

n_action: [fn [node] [succeed [expr node.child]]]

n_apply: [fn [node]
             [if node.memoize
                 [hl [call_op 'memoize' [list [lit node.rule_name]
                                              [method_name node.rule_name]]]
                     t_end]
                 [hl [call_rule node.rule_name q[]] t_end]]]

n_choice: [fn [node] [vl [t_assign 'pos' f_pos]
                         [vl_l [map [fn [c] [vl [stmts c]
                                                [return_if_not_failed c]
                                                [rewind 'pos']]]
                                    [slice node.ch 0 -1]]]
                         [stmts [getitem node.ch -1]]]]

n_count: [fn [node] [vl [t_assign 'vs' '[]']
                        [t_assign 'i' '0']
                        [t_assign 'cmin' [to_string [getitem node.v 0]]]
                        [t_assign 'cmax' [to_string [getitem node.v 1]]]
                        [t_while 'i < cmax'
                                 [vl [stmts node.child]
                                     [t_if failed
                                           [vl [t_if 'i >= cmin' [succeed 'vs']]
                                               t_return]]
                                     [t_append 'vs' f_val]
                                     [hl 'i += 1' t_end]]]
                        [succeed 'vs']]]
n_e_arr: [fn [node] [if [is_empty node.ch]
                        '[]'
                        [tri '['
                             [comma [map [fn [c] [expr c]] node.ch]]
                             ']']]]

n_e_call: [fn [node] [tri '(' [comma [map [fn [c] [expr c]] node.ch]] ')']]

n_e_const: [fn [node] [invoke [strcat 't_' node.v]]]

n_e_getitem: [fn [node] [tri '[' [expr node.child] ']']]

n_e_ident: [fn [node] [if [equal node.kind 'outer']
                          [call_op 'lookup' [list [lit node.v]]]
                          [if [equal node.kind 'extern']
                              [extern node.v]
                              [if [equal node.kind 'function']
                                  [method_name [fn_name node.v]]
                                  [local_var node.v]]]]]

n_e_lit: [fn [node] [lit node.v]]

n_e_minus: [fn [node] [tree [expr node.left] '-' [expr node.right]]]

n_e_not: [fn [node] [tree null t_not [expr node.child]]]

n_e_num: [fn [node] node.v]

n_e_paren: [fn [node] [expr node.child]]

n_e_plus: [fn [node] [tree [expr node.left] '+' [expr node.right]]]

n_e_qual: [fn [node] [saw [map [fn [c] [expr c]] node.ch]]]

n_empty: [fn [node] [succeed t_null]]

n_ends_in: [fn [node] [t_while t_true
                          [vl [stmts node.child]
                              [break_if_not_failed node]
                              [call_rule 'r_any' q[]]
                              [t_if failed t_break]]]]

n_equals: [fn [node] [hl [call_op 'str' [list [expr node.child]] t_end]]]

n_label: [fn [node] [vl [stmts node.child]
                        [return_if_failed node.child]
                        [if node.outer_scope
                            [vl [t_assign_outer node.name f_val]]
                            [vl [t_assign [local_var node.name] f_val]]]]]

n_leftrec: [fn [node] [hl [call_op 'leftrec'
                                   [list [method_name node.child.v]
                                         [lit node.v]
                                         [if node.left_assoc t_true t_false]]]
                           t_end]]

n_lit: [fn [node] [hl [if [equal [strlen node.v] 1]
                          [call_op 'ch' [list [lit node.v]]]
                          [call_op 'str' [list [lit node.v]]]]
                      t_end]]

n_not: [fn [node] [vl [t_assign 'pos' f_pos]
                      [t_assign 'errpos' [fld 'errpos']]
                      [stmts node.child]
                      [t_ifelse failed
                                [vl [succeed t_null 'pos']]
                                [vl [rewind 'pos']
                                    [t_assign [fld 'errpos'] 'errpos']
                                    [fail]]]]]

n_not_one: [fn [node] [vl [n_not node]
                          [t_if [hl t_not failed] [call_rule 'r_any' q[]]]]]

n_operator: [fn [node] [hl [call_op 'operator' [list [lit node.v]] t_end]]]

n_opt: [fn [node] [vl [t_assign 'pos' f_pos]
                      [stmts node.child]
                      [t_ifelse failed
                                [vl [succeed '[]']]
                                [vl [succeed [hl '[' f_val ']']]]]]]

n_paren: [fn [node] [stmts node.child]]

n_plus: [fn [node]
            [vl [t_assign 'vs' '[]']
                [stmts node.child]
                [return_if_failed node.child]
                [t_append 'vs' f_val]
                [t_while t_true
                    [vl [t_assign 'pos' f_pos]
                        [stmts node.child]
                        [t_if [t_or failed [t_eq f_pos 'pos']]
                              [vl [rewind 'pos']
                                  t_break]]
                        [t_append 'vs' f_val]]]
                [succeed 'vs']]]

n_pred: [fn [node]
            [vl [t_assign 'v' [expr node.child]]
                [t_ifelifelse [t_istrue 'v'] [succeed 'v']
                              [t_isfalse 'v'] [fail]
                              [t_throw [lit 'Bad predicate value']]]]]

n_range: [fn [node] [hl [call_op 'range'
                                 [list [lit node.start] [lit node.stop]]]
                        t_end]]

n_run: [fn [node]
           [vl [t_assign 'start' f_pos]
               [stmts node.child]
               [return_if_failed node.child]
               [t_assign 'end' f_pos]
               [t_assign f_val [t_substr [fld 'text'] 'start' 'end']]]]

n_scope: [fn [node] [vl [t_append [fld 'scopes'] t_newmap]
                        [stmts node.child]
                        [t_pop [fld 'scopes']]]]

n_seq: [fn [node]
           [vl [t_declare_vars [map [fn [v] [local_var v]] node.vars]]
               [stmts [getitem node.ch 0]]
               [return_if_failed [getitem node.ch 0]]
               [vl_l [map [fn [c] [vl [stmts c]
                                      [return_if_failed c]]]
                          [slice node.ch 1 -1]]]
               [stmts [getitem node.ch -1]]]]

n_star: [fn [node]
            [vl [t_assign 'vs' '[]']
                [t_while t_true
                      [vl [t_assign 'pos' f_pos]
                          [stmts node.child]
                          [t_if [t_or failed [t_eq f_pos 'pos']]
                                [vl [rewind 'pos']
                                    t_break]]
                          [t_append 'vs' f_val]]]
                [succeed 'vs']]]

n_unicat: [fn [node] [hl [call_op 'unicat' [list [lit node.v]]] t_end]]

}