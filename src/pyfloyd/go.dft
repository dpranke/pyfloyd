# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file contains the code generation templates for JavaScript.
# It depends on a base set of templates used by fairly similar languages.

name = 'Go'
ext = '.go'
indent = 4
line_length = 79

starting_template: 'generate'

inherit: ['base']

declare_local_vars = true

templates = {

#
# Helper rules
#

block: [fn [head body] [vl [hl head ' {'] [ind body] '}']]

#
# How to refer to different types of identifiers:
#

# Returns a field or method on the generated parse object.
fld: [fn [name] [strcat 'p.' name]]

f_pos: [fld 'pos']
f_errpos: [fld 'errpos']
f_val: [fld 'val']
failed: [fld 'failed']

extern: [fn [name] [strcat "p.externs[" [lit name] "]"]]

method_name: [fn [name] [fld name]]

#
# Helper methods for generating text portably.
#

t_assign: [fn [var val] [hl var ' = ' val t_end]]
t_assign_outer: [fn [var val]
                    [hl "p.scopes[p.scopes.length - 1]."
                        "set('"
                        var
                        "', "
                        val
                        ")" 
                        t_end]]
t_append: [fn [lst val] [hl lst '.push(' val ')' t_end]]
t_break:  'break'
t_declare_local_vars: [fn [node] [t_declare_vars node.local_vars]]
t_declare_vars: [fn [vars] [vl [map [fn [v] [hl 'var ' v t_end]]
                                    vars]]]
t_end: ''  # statement terminator
t_eq: [fn [x y] [hl x ' == ' y]]
t_false: 'false'
t_if: [fn [cond body] [block [hl 'if ' cond] body]]
t_ifelse: [fn [cond if_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block 'else' e_body]]]
t_ifelifelse: [fn [cond if_body elif_cond elif_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block [hl 'else if ' elif_cond] elif_body]
                  [block 'else' e_body]]]
t_istrue: [fn [v] [hl v ' === true']]
t_isfalse: [fn [v] [hl v ' === false']]
t_meth_def: 'func (p *Parser) '
t_meth_self: ''
t_meth_params: [fn [params] params]
t_newmap: 'new Map()'
t_not: '!'  # the logical operator
t_null: 'nil'
t_or: [fn [x y] [hl x ' || ' y]]
t_pop: [fn [x] [hl x '.pop()']]
t_return: 'return'
t_substr: [fn [s start end] [hl s '.substr(' start ', ' end ')']]
t_throw: [fn [msg] [hl 'panic(' msg ')']]
t_toplevel_extra_sep: null
t_true: 'true'
t_while: [fn [cond body] [block [hl 'for ' cond ] body]]

#
# The basic block structure of the file is given in the `generate` template
# in base. This section defines the templates `generate` references.
#

default_header: @"""
    // Generated by pyfloyd version @generator_options.version
    //    https://github.com/dpranke/pyfloyd
    //
    @wrap_argv['//    `' '//    ']
    //

    import (
        "errors"
        "fmt"
    )
    """

main_header: @"""
    // Generated by pyfloyd version @generator_options.version
    //    https://github.com/dpranke/pyfloyd
    //
    @wrap_argv['//    `' '//    ']
    //

    package main

    import (
        "errors"
        "fmt"
        "io"
        "os"
    )

    """

parsing_runtime_exception_class: d"""
    """

operator_state_class: d"""
    type OperatorState struct {
        currentDepth int
        currentPrec int
        precOps map[int][string]
        precs []int
        rassoc []str
        choices map[str][any] // any == grammar.Rule
    }
    """

result_class: d"""
    type seed struct {
        val any
        failed bool
        pos int
    }

    type Result struct {
        val any
        err error
        pos int
    }
    """

parse_function: d"""
    func Parse(text string, args ...any) (any, error) {
      var path string
      var start int
      var externs map[string]bool

      if len(args) == 3 {
          path = args[0].(string)
          start = args[1].(int)
          externs = args[2].(map[string]bool)
      } else if len(args) == 1 {
          path = args[0].(string)
          start = 0
          externs = make(map[string]bool)
      } else {
          path = "<string>"
          start = 0
          externs = make(map[string]bool)
      }

      p := NewParser(text, path);

      r := p.Parse(externs, start);
      return r.val, r.err
    }
    """

parser_class: @"""
    type Parser struct {
        text []rune
        path string
        val any
        failed bool
        pos  int
        end  int
        errpos int
        externs map[string]bool
        @if[generator_options.memoize 'cache map[int]any']
        @if[grammar.seeds_needed 'seeds map[int]seed']
        @if[grammar.leftrec_needed 'blocked map[string][int]']
        @if[grammar.lookup_needed 'scopes []map[string][any]']
        @if[grammar.operator_needed 'operators map[string]any']
    }

    @parser_methods[]
    """

parser_constructor: @"""
    func NewParser(text string, path string) *Parser {
        p := Parser{text: []rune(text), path: path}
        @externs[]
        return &p
    }

    """


externs: [fn [] [vl [map_items [fn [k v]
                                   [hl 'p.externs['
                                       [lit k]
                                       '] = '
                                       [if v 'true' 'false']]]
                               grammar.externs]]]

operator_state: [fn [rule o]
                    [vl 'o := OperatorState{}'
                        [operator_prec_ops o]
                        [hl 'o.precs = [...o.precOps.keys()].sort('
                            '(a, b) => b - a)']
                        [operator_rassoc o]
                        [operator_choices o]
                        [hl 'p.operators[' [lit rule] '] = o']]]

operator_prec_ops: [fn [o]
                       [vl 'o.precOps = new Map()'
                           [map [fn [prec]
                                    [hl 'o.precOps[' [itoa prec] '] = ['
                                        [map [fn [op] [lit op]]
                                             [get o.prec_ops prec]
                                             ', ']
                                        ']']]
                                [sort [keys o.prec_ops]]]]]

operator_rassoc: [fn [o]
                     [hl 'o.rassoc = new Set(['
                         [comma [map [fn [op] [lit op]] o.rassoc]]
                         '])']]

operator_choices: [fn [o] [vl 'o.choices = new Map()'
                              [map_items [fn [op meth]
                                             [hl "o.choices["
                                                 [lit op]
                                                 "] = p."
                                                 meth]]
                                         o.choices]]]

parse_with_exception: @"""
    func (p Parser) Parse(args ...any) Result {
      var externs map[string]bool
      var start int

      if len(args) == 2 {
          externs = args[0].(map[string]bool)
          start = args[1].(int)
      } else if len(args) == 1 {
          externs = args[0].(map[string]bool)
          start = 0
      }

      errs := ""
      for key := range externs {
          if _, ok := p.externs[key] ; !ok {
              errs += "Unexpected extern '" + key + "'\\n"
          } else {
              p.externs[key] = externs[key]
          }
      }

      if errs != "" {
          return Result{nil, errors.New(errs), 0}
      }

      p.pos = start
      p.r_@grammar.starting_rule()

      if p.failed {
          fmt.Println("failed")
          return Result{nil, errors.New(p.o_error()), p.errpos}
      } else {
          fmt.Println("succeeded")
          return Result{p.val, nil, p.pos}
      }
    }
    """  # parse_with_exception

parse_without_exception: @"""
    @parse_with_exception[]
    """  # parse_without_exception

default_footer: null

main_footer: d"""

    func main() {
        if len(os.Args) != 2 || os.Args[1] == "-h" || os.Args[1] == "--help" {
            fmt.Println("usage: [-h|--help] data")
            os.Exit(2)
        }
        data_file := os.Args[1]

        var d []byte
        var err error

        if data_file == "-" {
            d, err = io.ReadAll(os.Stdin)
        } else {
            d, err = os.ReadFile(data_file)
        }
        if err != nil {
            panic(err)
        }

        if err != nil {
            panic(err)
        }
        val, err := Parse(string(d), data_file)
        if err == nil {
            fmt.Println("success: ", val)
        } else {
            fmt.Println("Error: '", err, "'")
        }

    }
    """  # main_footer

#
# Language-specific rules for nodes in the AST.
#

n_regexp: [fn [node]
              [vl [hl "r = new RegExp(" [lit node.v] ", 'gy')"]
                  'r.lastIndex = p.pos'
                  'found = r.exec(p.text)'
                  'if found {'
                  '    p.o_succeed(found[0], p.pos + found[0].length)'
                  '    return'
                  '}'
                  'p.o_fail()']]

n_set: [fn [node]
           [vl [hl "r = new RegExp(" 
                   [lit [strcat '[' node.v  ']' ]]
                   ", 'gy')"]
               'r.lastIndex = p.pos'
               'found = r.exec(p.text)'
               'if found {'
               '    p.o_succeed(found[0], p.pos + found[0].length)'
               '    return'
               '}'
               'p.o_fail()']]

#
# Built-in operators and rules
#

r_any: [meth q[] d"""
    if p.pos < p.end {
      p.o_succeed(p.text[p.pos], p.pos + 1)
    } else {
      p.o_fail()
    }
    """]

r_end: [meth q[] d"""
    if p.pos == p.end {
      p.o_succeed(nil, p.pos)
    } else {
      p.o_fail()
    }
    """]

o_ch: [meth q['c string'] d"""
    pos := p.pos
    if pos < p.end && p.text[pos] == c {
      p.o_succeed(c, p.pos + 1)
    } else {
      p.o_fail()
    }
    """]

o_offsets: d"""
    func (p *Parser) o_offsets(pos int) (int, int) {
        lineno := 1
        colno := 1
        for i := 0 ; i < pos ; i++ {
          if p.text[i] == '\\n' {
            lineno += 1
            colno = 1
          } else {
            colno += 1
          }
        }
        return lineno, colno
    }
    """

o_error: d"""
    func (p *Parser) o_error() string {
        lineno, colno := p.o_offsets(p.errpos)
        var thing string
        if p.errpos == p.end {
          thing = "end of input"
        } else {
          thing = string(p.text[p.errpos])
        }
        return (p.path + ":" + string(lineno) + " Unexpected " + thing +
                " at column " + string(colno))
    }
    """

o_fail: [meth q[] d"""
    p.val = nil
    p.failed = true
    p.errpos = max(p.errpos, p.pos)
    """]

o_leftrec: [meth q['rule any' 'rule_name string' 'left_assoc bool'] d"""
    pos := p.pos
    key := [rule_name, pos]
    seed := p.seeds[key]
    if seed {
      [p.val, p.failed, p.pos] = seed
      return
    }
    if _, ok := p.blocked[rule_name]; ok {
      p.val = nil
      p.failed = true
      return
    }
    current := [nil, true, p.pos]
    p.seeds[key] = current
    if left_assoc {
      p.blocked.add(rule_name)
    }
    while (true) {
      rule.call(p)
      if p.pos > current[2] {
        current = [p.val, p.failed, p.pos]
        p.seeds[key] = current
        p.pos = pos
      } else {
        delete p.seeds[key]
        [p.val, p.failed, p.pos] = current
        if left_assoc {
          p.blocked.delete(rule_name)
        }
        return
      }
    }
    """]  # o_leftrec
    
o_lookup: [meth q['v string'] d"""
    l := p.scopes.length - 1
    while (l >= 0) {
      if val, ok := p.scopes[l][v] ; ok {
        return val
      }
      l -= 1
    }
    if val, ok :p p.externs[v] {
      return val
    }
    panic("Unknown var '" + v + "'")
    """]

o_memoize: [meth q['rule_name string' 'fn any'] d"""
    pos := p.pos
    if !p.cache.has(pos) {
      p.cache.set(pos, new Map())
    }
    let c = p.cache.get(pos)
    if c.has(rule_name) {
      [p.val, p.failed, p.pos] = c.get(rule_name)
      return
    }
    fn.call(p)
    c.set(rule_name, [p.val, p.failed, p.pos])
   """]

o_operator: [meth q['rule_name string'] d"""
    o := p.operators[rule_name]
    pos := p.pos
    key := [rule_name, pos]
    seed := p.seeds[key]
    if seed {
      [p.val, p.failed, p.pos] = seed
      return
    }
    o.currentDepth += 1
    current := [nil, true, pos]
    p.seeds[key] = current
    minPrec := o.currentPrec
    i := 0
    while (i < o.precs.length) {
      repeat := false
      prec := o.precs[i]
      precOps := o.precOps.get(prec)
      if prec < minPrec {
        break
      }
      o.currentPrec = prec
      if !o.rassoc.has(precOps[0]) {
        o.currentPrec += 1
      }
      for (let j = 0 j < precOps.length j += 1) {
        let op = precOps[j]
        o.choices.get(op).call(p)
        if !p.failed && p.pos > pos {
          current = [p.val, p.failed, p.pos]
          p.seeds[key] = current
          repeat = true
          break
        }
        p.o_rewind(pos)
      }
      if !repeat {
        i += 1
      }
    }
    delete p.seeds[key]
    o.currentDepth -= 1
    if o.currentDepth === 0 {
      o.currentPrec = 0
    }
    [p.val, p.failed, p.pos] = current
    """]  # o_operator

o_range: [meth q['i int' 'j int'] d"""
    pos := p.pos
    if pos == p.end {
      p.o_fail()
      return
    }
    c := p.text[pos]
    if i <= c && c <= j {
      p.o_succeed(p.text[pos], p.pos + 1)
    } else {
      p.o_fail()
    }
    """]

o_rewind: [meth q['newpos int'] 'p.o_succeed(nil, newpos)']

o_str: [meth q['s string'] d"""
   for ch of s {
     p.o_ch(ch)
     if p.failed {
       return
     }
   }
   p.val = s
   """]

o_succeed: [meth q['v any' 'newpos int'] d"""
   p.val = v
   p.failed = false
   p.pos = newpos
   """]

o_unicat: [meth q['cat'] d"""
    if p.pos == p.end {
      p.o_fail()
      return
    }
    c := p.text[p.pos]
    let re = new RegExp(`\\\\p{${cat}}`, 'u')
    if c.match(re) {
      p.o_succeed(c, p.pos + 1)
    } else {
      p.o_fail()
    }
    """]

fn_atof: [meth q['a string'] 'return parseFloat(a)']

fn_atoi: [meth q['a string' 'base int'] 'return parseInt(a, base)']

fn_atou: [meth q['a string' 'base int']
               'return String.fromCharCode(Number.parseInt(a, base))']

fn_cat: [meth q['ss []string'] "return ss.join('')"]

fn_colno: [
    meth q[] d"""
          colno := 0
          if p.pos == p.end {
            colno += 1
          }
          while (p.pos >= colno && p.text[p.pos - colno] != "\\n") {
            colno += 1
          }
          return colno
          """]

fn_concat: [meth q['xs []string' 'ys []string'] 'return xs.concat(ys)']

fn_cons: [meth q['hd any' 'tl []any'] 'return [hd].concat(tl)']

fn_dedent: [meth q['s string'] 'return s']

fn_dict: [meth q['pairs [](string, any)'] d"""
    m := map[str]any
    for [k, v] of pairs {
      m[k] = v  // TODO: m.set(k, v) doesn't work?
    }
    return m
    """]

fn_itou: [meth q['n int'] 'return String.fromCharCode(n)']

fn_join: [meth q['s string' 'vs []string'] 'return vs.join(s)']

fn_scat: [meth q['ss []string'] "return ss.join('')"]

fn_scons: [meth q['hd string' 'tl []string'] 'return [hd].concat(tl)']

fn_strcat: [meth q['a string' 'b string'] 'return a.concat(b)']

fn_ulookup: [meth q['s string'] d"""
    panic('Unsupported function "ulookup"')
    """]

fn_utoi: [meth q['s string'] 'return s.charCodeAt(0)']

fn_xtoi: [meth q['s string'] 'return Number.parseInt(s, 16)']

fn_xtou: [meth q['s string']
               'return String.fromCharCode(Number.parseInt(s, 16))']

}
