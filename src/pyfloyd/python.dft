# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This file contains the code generation templates for Python3.
# It depends on a base set of templates used by fairly similar languages.

name = 'Python'
ext = 'py'
indent = 4
line_length = 79

starting_template: 'generate'

inherit: ['base']

templates: {

#
# Various constants
#

c_true:   'True'
c_false:  'False'
c_null:   'None'
c_not:    'not '  # the not / `!` operator
c_end:    ''      # statement terminator

t_return:  'return;'
t_break:   'break;'

#
# Helper rules
#

# Defines a method on the generated parser object corresponding to the given.
# template name `params` may be either
# of length 1, in which case the method takes no arguments and the param
# is the formater.El for the body, or 2, in which case the first argument is a
# string with the parameter names (and optional values) and the second is the
# body. `_t_name` can be used to refer to the name of the template.
meth: [fn params [if [equal [length params] 1]
                     [vl [hl 'def _' _t_name '(self):']
                         [ind [getitem params 0]]]
                     [vl [hl 'def _'
                             _t_name
                             '(self, '
                             [getitem params 0]
                             '):']
                         [ind [getitem params 1]]]]]

rule_method: [fn [rule node] [vl [strcat 'def _' rule '(self):']
                                 [ind [invoke_node node]]]]


# Reference different kinds of variable names.

# Returns a field or method on the generated parse object.
fld: [fn [name] [strcat 'self._' name]]

method_name: [fn [name] [fld name]]

failed: [fld 'failed']

f_pos: [fld 'pos']
f_errpos: [fld 'errpos']
f_val: [fld 'val']

t_append: [fn [lst val] [hl lst '.append(' val ')' c_end]]
t_pop: [fn [lst] [hl lst '.pop()']]

t_substr: [fn [s start end] [hl s '[' start ':' end ']']]

extern: [fn [name] [strcat 'self._externs[' [lit name] ']']]

t_assign: [fn [var val] [hl var ' = ' val c_end]]
t_assign_outer: [fn [var val] 
                    [hl "self._scopes[-1]['" var "'] = " val]]

block: [fn [head body] [vl [hl head ':'] [ind body]]]

t_while: [fn [cond body] [block [hl 'while ' cond] body]]

t_if: [fn [cond body] [block [hl 'if ' cond] body]]
t_ifelse: [fn [cond if_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block 'else' e_body]]]

t_ifelifelse: [fn [cond if_body elif_cond elif_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block [hl 'elif ' elif_cond] elif_body]
                  [block 'else' e_body]]]

t_istrue: [fn [v] [hl v ' is True']]
t_isfalse: [fn [v] [hl v ' is False']]
                  
t_throw: [fn [msg] [hl 'raise _ParsingRuntimeError(' msg ')' c_end]]

t_or: [fn [x y] [hl x ' or ' y]]
t_eq: [fn [x y] [hl x ' == ' y]]

break_if_failed: [fn [node] [if node.can_fail [t_if failed t_break]]]
break_if_not_failed: [fn [node] [if node.can_fail
                                    [t_if [hl c_not failed] t_break]]]
return_if_failed: [fn [node] [if node.can_fail [t_if failed t_return]]]
return_if_not_failed: [fn [node] [if node.can_fail
                                     [t_if [hl c_not failed] t_return]]]

#
# The basic block structure of the file is given in the `generate` template
# in base. This section defines the templates `generate` references.
#

default_header: @"
    # Generated by pyfloyd version @generator_options.version
    #    https://github.com/dpranke/pyfloyd
    #
    # pylint: disable=line-too-long
    #
    #    `pyfloyd @generator_options.command_line`
    #
    # pylint: enable=line-too-long

    @imports

    Externs = Optional[Dict[str, Any]]

    # pylint: disable=too-many-lines
    "

main_header: @'''
    #!/usr/bin/env python3
    #
    # Generated by pyfloyd version {version}
    #    https://github.com/dpranke/pyfloyd
    #
    # pylint: disable=line-too-long
    #
    #    `pyfloyd @generator_options.command_line`
    #
    # pylint: enable=line-too-long

    @imports

    Externs = Optional[Dict[str, Any]]

    # pylint: disable=too-many-lines


    def main(
        argv=sys.argv[1:],
        stdin=sys.stdin,
        stdout=sys.stdout,
        stderr=sys.stderr,
        exists=os.path.exists,
        opener=open,
    ) -> int:
        arg_parser = argparse.ArgumentParser()
        arg_parser.add_argument('-c', '--code')
        arg_parser.add_argument(
            '-D',
            '--define',
            action='append',
            metavar='var=val',
            default=[],
            help='define an external var=value (may use multiple times)'
        )
        arg_parser.add_argument('file', nargs='?')
        args = arg_parser.parse_args(argv)

        if args.code is not None:
           msg = args.code
           path = '<code>'
        elif not args.file or args.file[1] == '-':
            path = '<stdin>'
            fp = stdin
        elif not exists(args.file):
            print('Error: file "%s" not found.' % args.file, file=stderr)
            return 1
        else:
            path = args.file
            fp = opener(path)

        externs = {}
        for d in args.define:
            k, v = d.split('=', 1)
            externs[k] = json.loads(v)

        if args.code is None:
            msg = fp.read()
        result = parse(msg, path, externs)
        if result.err:
            print(result.err, file=stderr)
            return 1
        print(json.dumps(result.val, indent=2), file=stdout)
        return 0
    '''  # main_header

imports: [vl [if generator_options.main
                 [vl 'import argparse'
                     'import json'
                     'import os'
                     'import sys']]
             [if grammar.re_needed 'import re']
             'from typing import Any, Dict, NamedTuple, Optional'
             [if grammar.unicodedata_needed 'import unicodedata']]

result_class: d'''
    class Result(NamedTuple):
        """The result returned from a `parse()` call.

        If the parse is successful, `val` will contain the returned value, if any
        and `pos` will indicate the point in the text where the parser stopped.
        If the parse is unsuccessful, `err` will contain a string describing
        any errors that occurred during the parse and `pos` will indicate
        the location of the farthest error in the text.
        """

        val: Any = None
        err: Optional[str] = None
        pos: Optional[int] = None
        
    '''  # result_class

parsing_runtime_exception_class: d'
    class _ParsingRuntimeError(Exception):
        pass

    '

operator_state_class: d'
    class _OperatorState:
        def __init__(self):
            self.current_depth = 0
            self.current_prec = 0
            self.prec_ops = {}
            self.precs = []
            self.rassoc = set()
            self.choices = {}


    '  # operator_state_class

parse_function: d'''
    def parse(
        text: str, path: str = '<string>', externs: Externs = None, start: int = 0
    ) -> Result:
        """Parse a given text and return the result.

        If the parse was successful, `result.val` will be the returned value
        from the parse, and `result.pos` will indicate where the parser
        stopped when it was done parsing.

        If the parse is unsuccessful, `result.err` will be a string describing
        any errors found in the text, and `result.pos` will indicate the
        furthest point reached during the parse.

        If the optional `path` is provided it will be used in any error
        messages to indicate the path to the filename containing the given
        text.
        """
        return _Parser(text, path).parse(externs, start)

    '''  # parse_function

parser_class: @'
    class _Parser:
        @parser_constructor[]
        @parser_methods[]
    '

default_footer: null

main_footer: d'''


    if __name__ == '__main__':
        sys.exit(main())
    '''

#
# Templates for methods in the generated parser class.
#

parser_constructor: @'''
    def __init__(self, text, path):
        self._text = text
        self._end = len(self._text)
        self._errpos = 0
        self._failed = False
        self._path = path
        self._pos = 0
        self._val = None
        @if[[is_empty grammar.externs] [vl 'self._externs = {}'] [externs]]
        @if[generator_options.memoize 'self._cache = {}']
        @if[grammar.seeds_needed 'self._seeds = {}']
        @if[grammar.leftrec_needed 'self._blocked = set()']
        @if[grammar.re_needed 'self._regexps = {}']
        @if[grammar.lookup_needed 'self._scopes = []']
        @if[grammar.operator_needed
            [vl 'self._operators = {}'
                [vl_l [map_items operator_state grammar.operators]]]]
            

    '''  # parser_constructor

externs: [fn [] [vl 'self._externs = {'
                     [ind_l [map_items [fn [k v]
                                           [strcat "'"
                                                   k
                                                   "': "
                                                   [to_string v]
                                                   ","]]
                                       grammar.externs]]
                     '}']]

operator_state: [fn [rule o]
                    [vl 'o = _OperatorState()'
                        'o.prec_ops = {'
                        [operator_prec o]
                        '}'
                        'o.precs = sorted(o.prec_ops, reverse=True)'
                        [operator_rassoc o]
                        'o.choices = {'
                        [ind_l [operator_choices o]]
                        '}'
                        [strcat "self._operators['" rule "'] = o"]]]

operator_prec: [fn [o]
                   [ind_l [map [fn [prec]
                                 [hl [to_string prec]
                                     ': ['
                                     [hl_l [map [fn [op] [strcat "'" op "'"]]
                                                [getitem o.prec_ops prec]
                                                ', ']]
                                     '],']]
                             [sort [keys o.prec_ops]]]]]

operator_rassoc: [fn [o]
                     [hl 'o.rassoc = set(['
                         [comma  [map [fn [op] [strcat "'" op "'"]]
                                      o.rassoc]]
                         '])']]

operator_choices: [fn [o] [map_items [fn [op meth]
                                         [strcat "'" op "': self._" meth ","]]
                                     o.choices]]

parse_with_exception: @'''
    def parse(self, externs: Externs = None, start: int = 0):
        self._pos = start
        errors = ''
        if externs:
            for k, v in externs.items():
                if k in self._externs:
                    self._externs[k] = v
                else:
                    errors += f'Unexpected extern "{k}"\n'
        if errors:
            return Result(None, errors, 0)
        try:
            self._r_@grammar.starting_rule()

            if self._failed:
                return Result(None, self._o_error(), self._errpos)
            return Result(self._val, None, self._pos)
        except _ParsingRuntimeError as e:  # pragma: no cover
            lineno, _ = self._o_offsets(self._errpos)
            return Result(
                None,
                self._path + ':' + str(lineno) + ' ' + str(e),
                self._errpos,
            )
    '''

parse_without_exception: @'''
    def parse(self, externs: Externs = None, start: int = 0):
        self._pos = start
        if externs:
            for k, v in externs.items():
                self._externs[k] = v

        self._r_@grammar.starting_rule()

        if self._failed:
            return Result(None, self._o_error(), self._errpos)
        return Result(@f_val, None, @f_pos)
    '''

#
# Rules for each node in the AST
#

n_choice: [fn [node] [vl [t_assign 'pos' f_pos]
                         [vl_l [map [fn [c] [vl [stmts c]
                                                [return_if_not_failed c]
                                                [rewind 'pos']]]
                                    [slice node.ch 0 -1]]]
                         [stmts [getitem node.ch -1]]]]

n_count: [fn [node] [vl [t_assign 'vs' '[]']
                        [t_assign 'i' '0']
                        [t_assign 'cmin' [to_string [getitem node.v 0]]]
                        [t_assign 'cmax' [to_string [getitem node.v 1]]]
                        [t_while 'i < cmax'
                                 [vl [stmts node.child]
                                     [t_if failed
                                           [vl [t_if 'i >= cmin' [succeed 'vs']]
                                               t_return]]
                                     [t_append 'vs' f_val]
                                     [hl 'i += 1' c_end]]]
                        [succeed 'vs']]]


n_ends_in: [fn [node] [t_while c_true
                          [vl [stmts node.child]
                              [break_if_not_failed node]
                              [call_rule 'r_any' q[]]
                              [t_if failed t_break]]]]

n_label: [fn [node] [vl [stmts node.child]
                        [return_if_failed node.child]
                        [if node.outer_scope
                            [vl [t_assign_outer node.name f_val]]
                            [vl [t_assign [local_var node.name] f_val]]]]]

n_not: [fn [node] [vl [t_assign 'pos' f_pos]
                      [t_assign 'errpos' [fld 'errpos']]
                      [stmts node.child]
                      [t_ifelse failed
                                [vl [succeed c_null 'pos']]
                                [vl [rewind 'pos']
                                    [t_assign [fld 'errpos'] 'errpos']
                                    [fail]]]]]

n_not_one: [fn [node] [vl [n_not node]
                          [t_if [hl c_not failed] [call_rule 'r_any' q[]]]]]

n_opt: [fn [node] [vl [t_assign 'pos' f_pos]
                      [stmts node.child]
                      [t_ifelse failed
                                [vl [succeed '[]']]
                                [vl [succeed [hl '[' f_val ']']]]]]]

n_plus: [fn [node]
            [vl [t_assign 'vs' '[]']
                [stmts node.child]
                [return_if_failed node.child]
                [t_append 'vs' f_val]
                [t_while c_true
                    [vl [t_assign 'pos' f_pos]
                        [stmts node.child]
                        [t_if [t_or failed [t_eq f_pos 'pos']]
                              [vl [rewind 'pos']
                                  t_break]]
                        [t_append 'vs' f_val]]]
                [succeed 'vs']]]

n_pred: [fn [node]
            [vl [t_assign 'v' [expr node.child]]
                [t_ifelifelse [t_istrue 'v'] [succeed 'v']
                              [t_isfalse 'v'] [fail]
                              [t_throw [lit 'Bad predicate value']]]]]

n_regexp: [fn [node]
              [vl [t_assign 'rexp' [lit node.v]]
                  'if rexp not in self._regexps:'
                  '    self._regexps[rexp] = re.compile(rexp)'
                  'm = self._regexps[rexp].match(self._text, self._pos)'
                  'if m:'
                  '    self._o_succeed(m.group(0), m.end())'
                  '    return'
                  [fail]]]

n_run: [fn [node]
           [vl [t_assign 'start' f_pos]
               [stmts node.child]
               [return_if_failed node.child]
               [t_assign 'end' f_pos]
               [t_assign f_val [t_substr [fld 'text'] 'start' 'end']]]]

n_scope: [fn [node] [vl [t_append [fld 'scopes'] '{}']
                        [stmts node.child]
                        [t_pop [fld 'scopes']]]]

n_seq: [fn [node]
           [vl [stmts [getitem node.ch 0]]
               [return_if_failed [getitem node.ch 0]]
               [vl_l [map [fn [c] [vl [stmts c]
                                      [return_if_failed c]]]
                          [slice node.ch 1 -1]]]
               [stmts [getitem node.ch -1]]]]

n_set: [fn [node]
           [vl [t_assign 'rexp' [lit [strcat '[' node.v ']']]]
               [t_if 'rexp not in self._regexps'
                     'self._regexps[rexp] = re.compile(rexp)']
               'm = self._regexps[rexp].match(self._text, self._pos)'
               [t_if 'm'
                     [vl [succeed 'm.group(0)' 'm.end()']
                         t_return]]
               [fail]]]

n_star: [fn [node]
            [vl [t_assign 'vs' '[]']
                [t_while c_true
                      [vl [t_assign 'pos' f_pos]
                          [stmts node.child]
                          [t_if [t_or failed [t_eq f_pos 'pos']]
                                [vl [rewind 'pos']
                                    t_break]]
                          [t_append 'vs' f_val]]]
                [succeed 'vs']]]

#
# Built-in operators and rules
#

o_ch: [meth 'ch' d"
           pos = self._pos
           if pos < self._end and self._text[pos] == ch:
               self._o_succeed(ch, self._pos + 1)
           else:
               self._o_fail()
           "]

o_offsets: [meth 'pos' d'''
                lineno = 1
                colno = 1
                for i in range(pos):
                    if self._text[i] == '\\n':
                        lineno += 1
                        colno = 1
                    else:
                        colno += 1
                return lineno, colno
                ''']

o_error: [meth d'''
              lineno, colno = self._o_offsets(self._errpos)
              if self._errpos == len(self._text):
                  thing = 'end of input'
              else:
                  thing = repr(self._text[self._errpos]).replace("'", '"')
              path = self._path
              return f'{path}:{lineno} Unexpected {thing} at column {colno}'
              ''']

o_fail: [meth d'''
              self._val = None
              self._failed = True
              self._errpos = max(self._errpos, self._pos)
              ''']

o_leftrec: [meth 'rule, rule_name, left_assoc' d'''
                  pos = self._pos
                  key = (rule_name, pos)
                  seed = self._seeds.get(key)
                  if seed:
                      self._val, self._failed, self._pos = seed
                      return
                  if rule_name in self._blocked:
                      self._val = None
                      self._failed = True
                      return
                  current = (None, True, self._pos)
                  self._seeds[key] = current
                  if left_assoc:
                      self._blocked.add(rule_name)
                  while True:
                      rule()
                      if self._pos > current[2]:
                          current = (self._val, self._failed, self._pos)
                          self._seeds[key] = current
                          self._pos = pos
                      else:
                          del self._seeds[key]
                          self._val, self._failed, self._pos = current
                          if left_assoc:
                              self._blocked.remove(rule_name)
                          return
                  ''']

o_lookup: [meth 'var' d'''
                i = len(self._scopes) - 1
                while i >= 0:
                    if var in self._scopes[i]:
                        return self._scopes[i][var]
                    i -= 1
                if var in self._externs:
                    return self._externs[var]
                assert False, f'unknown var {var}'
                ''']

o_memoize: [meth 'rule_name, fn' d'''
        pos = self._pos
        result = self._cache.setdefault(pos, {}).get(rule_name)
        if result:
            self._val, self._failed, self._pos = result
            return
        fn()
        self._cache[pos][rule_name] = (self._val, self._failed, self._pos)
        ''']

o_operator: [meth 'rule_name' d'''
        o = self._operators[rule_name]
        pos = self._pos
        key = (rule_name, self._pos)
        seed = self._seeds.get(key)
        if seed:
            self._val, self._failed, self._pos = seed
            return
        o.current_depth += 1
        current = (None, True, self._pos)
        self._seeds[key] = current
        min_prec = o.current_prec
        i = 0
        while i < len(o.precs):
            repeat = False
            prec = o.precs[i]
            prec_ops = o.prec_ops[prec]
            if prec < min_prec:
                break
            o.current_prec = prec
            if prec_ops[0] not in o.rassoc:
                o.current_prec += 1
            for j, _ in enumerate(prec_ops):
                op = prec_ops[j]
                o.choices[op]()
                if not self._failed and self._pos > pos:
                    current = (self._val, self._failed, self._pos)
                    self._seeds[key] = current
                    repeat = True
                    break
                self._o_rewind(pos)
            if not repeat:
                i += 1

        del self._seeds[key]
        o.current_depth -= 1
        if o.current_depth == 0:
            o.current_prec = 0
        self._val, self._failed, self._pos = current
        ''']

o_range: [meth 'i, j' d'''
               pos = self._pos
               if pos != self._end and ord(i) <= ord(self._text[pos]) <= ord(j):
                   self._o_succeed(self._text[pos], self._pos + 1)
               else:
                   self._o_fail()
               ''']

o_rewind: [meth 'newpos' 'self._o_succeed(None, newpos)']

o_str: [meth 's' d'''
             for ch in s:
                 self._o_ch(ch)
                 if self._failed:
                     return
             self._val = s
             ''']

o_succeed: [meth 'v, newpos=None' d"
                self._val = v
                self._failed = False
                if newpos is not None:
                    self._pos = newpos
                "]

o_unicat: [
    meth 'cat' d"
         pos = self._pos
         if pos < self._end and unicodedata.category(self._text[pos]) == cat:
             self._o_succeed(self._text[pos], self._pos + 1)
         else:
             self._o_fail()
         "]

r_any: [
    meth d"
        if self._pos < self._end:
            self._o_succeed(self._text[self._pos], self._pos + 1)
        else:
            self._o_fail()
        "]

r_end: [meth d"
             if self._pos == self._end:
                 self._o_succeed(None)
             else:
                 self._o_fail()
             "]

fn_atof: [meth 's' d"
               if '.' in s or 'e' in s or 'E' in s:
                   return float(s)
               return int(s)
               "]

fn_atoi: [meth 'a, base' 'return int(a, base)']

fn_atou: [meth 'a, base' 'return chr(int(a, base))']

fn_cat: [meth 'strs' "return ''.join(strs)"]

fn_concat: [meth 'xs, ys' 'return xs + ys']

fn_cons: [meth 'hd, tl' 'return [hd] + tl']

fn_dedent: [meth 's' 'return s']

fn_dict: [meth 'pairs' 'return dict(pairs)']

fn_itou: [meth 'n' 'return chr(n)']

fn_join: [meth 's, vs' 'return s.join(vs)']

fn_otou: [meth 's' 'return chr(int(s, base=8))']

fn_scat: [meth 'hd, tl' 'return self._fn_cat(self._fn_cons(hd, tl))']

fn_scons: [meth 'hd, tl' 'return [hd] + tl']

fn_strcat: [meth 'a, b' 'return a + b']

fn_unicode_lookup: [meth 's' 'return unicodedata.lookup(s)']

fn_utoi: [meth 's' 'return ord(s)']

fn_xtoi: [meth 's' 'return int(s, base=16)']

fn_xtou: [meth 's' 'return chr(int(s, base=16))']

}