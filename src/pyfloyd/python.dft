generate: '''
@if[generator_options.main main_header default_header]
@if[grammar.exception_needed parsing_runtime_exception_class '']
@if[grammar.operators operator_state_class '']
@result_class
@parse_function
@parser_class
@if[generator_options.main main_footer default_footer]
'''

#
# Basic block structure of the file
#

default_header: '''
# Generated by pyfloyd version @generator_options.version
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`

@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines
'''

main_header: '''
#!/usr/bin/env python3
#
# Generated by pyfloyd version {version}
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`

@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


def main(
    argv=sys.argv[1:],
    stdin=sys.stdin,
    stdout=sys.stdout,
    stderr=sys.stderr,
    exists=os.path.exists,
    opener=open,
) -> int:
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument(
        '-D',
        '--define',
        action='append',
        metavar='var=val',
        default=[],
        help='define an external var=value (may use multiple times)'
    )
    arg_parser.add_argument('file', nargs='?')
    args = arg_parser.parse_args(argv)

    if not args.file or args.file[1] == '-':
        path = '<stdin>'
        fp = stdin
    elif not exists(args.file):
        print('Error: file "%s" not found.' % args.file, file=stderr)
        return 1
    else:
        path = args.file
        fp = opener(path)

    externs = {}
    for d in args.define:
        k, v = d.split('=', 1)
        externs[k] = json.loads(v)

    msg = fp.read()
    result = parse(msg, path, externs)
    if result.err:
        print(result.err, file=stderr)
        return 1
    print(json.dumps(result.val, indent=2), file=stdout)
    return 0
'''  # main header

imports: '''
@if[generator_options.main 'import argparse\nimport json\nimport os\n' '']
@if[grammar.re_needed 'import re' '']
# TODO: handle unicodedata_needed
'''

result_class: '''
class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if any
    and `pos` will indicate the point in the text where the parser stopped.
    If the parse is unsuccessful, `err` will contain a string describing
    any errors that occurred during the parse and `pos` will indicate
    the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None
'''

parsing_runtime_exception_class: '''

# parsing runtime exception class
'''

operator_state_class: '''
# operator state class
'''

parse_function: '''
def parse(
    text: str, path: str = '<string>', externs: Externs = None
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs)
'''

parser_class: '''
class _Parser:
    @parser_constructor
    @parser_methods
'''

default_footer: '# default footer'
main_footer: '''

# main footer
'''

#
# rules for methods in the parser class
#

parser_constructor: '''
def __init__(self, text, path):
    self._text = text
    self._end = len(self._text)
    self._errpos = 0
    self._failed = False
    self._path = path
    self._pos = 0
    self._val = None
    # TODO: Handle self._externs
    self._externs = {}

    @if[generator_options.memoize 'self._cache = {}' '']
    # should be [or grammar.leftrec_needed grammar.operator_needed]
    @if[true
        'self._seeds = {}'
        ''
       ]
    @if[grammar.leftrec_needed 'self._blocked = set()' '']
    @if[grammar.re_needed 'self._regexps = {}' '']
    @if[grammar.lookup_needed 'self._scopes = []' '']
    @if[grammar.operator_needed operator_state '']
'''

operator_state: '# operator state'

parser_methods: '# parser methods'

parse_method: '# parse method'

rule_methods: '# rule methods'

needed_methods: '# needed methods'

needed_builtin_functions: '# needed builtin functions'

#
# Rules for each node in the AST
#

n_action: ''

n_apply: ''

n_e_arr: ''

n_e_call: ''

n_e_const: ''

n_e_getitem: ''

n_e_lit: ''

n_e_minus: ''

n_e_not: ''

n_e_num: ''

n_e_plus: ''

n_e_qual: ''

n_e_var: ''

n_empty: ''

n_equals: ''

n_label: ''

n_leftrec: ''

n_lit: ''

n_not: ''

n_not_one: ''

n_operator: ''

n_opt: ''

n_paren: ''

n_plus: ''

n_pred: ''

n_range: ''

n_regexp: ''

n_run: ''

n_scope: ''

n_set: ''

n_seq: ''

n_star: ''

n_unicat: ''

#
# Built-in operators and rules
#

o_ch: ''

o_error: ''

o_fail: ''

o_leftrec: ''

o_lookup: ''

o_memoize: ''

o_offsets: ''

o_operator: ''

o_range: ''

o_rewind: ''

o_str: ''

o_succeed: ''

o_unicat: ''

r_any: ''

r_end: ''

#
# Built-in functions
#

f_atof: ''

f_atoi: ''

f_atou: ''

f_cat: ''

f_concat: ''

f_cons: ''

f_dedent: ''

f_dict: ''

f_itou: ''

f_join: ''

f_otou: ''

f_scat: ''

f_scons: ''

f_strcat: ''

f_unicode_lookup: ''

f_utoi: ''

f_xtoi: ''

f_xtou: ''

#
# Miscellaneous rules for simple expansions
#

thisvar: ''

rulename: ''

extern: ''

invoke: ''

lit: ''

end: ''

#
# Miscellaneous rules for constants
#

false: 'False'

indent: '    '

infinity: "float('inf')"

nan: "float('NaN')"

not: 'not '

null: 'None'

true: 'True'








