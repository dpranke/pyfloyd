
generate: '''
@if[generator_options.main [main_header] [default_header]]
@if[grammar.exception_needed [parsing_runtime_exception_class] '']
@if[grammar.operators [operator_state_class] '']
@result_class
@parse_function
@parser_class
@if[generator_options.main [main_footer] [default_footer]]
'''

#
# Basic block structure of the file
#

default_header: '''
# Generated by pyfloyd version @generator_options.version
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`
@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines
'''

main_header: '''
#!/usr/bin/env python3
#
# Generated by pyfloyd version {version}
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`

@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


def main(
    argv=sys.argv[1:],
    stdin=sys.stdin,
    stdout=sys.stdout,
    stderr=sys.stderr,
    exists=os.path.exists,
    opener=open,
) -> int:
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument(
        '-D',
        '--define',
        action='append',
        metavar='var=val',
        default=[],
        help='define an external var=value (may use multiple times)'
    )
    arg_parser.add_argument('file', nargs='?')
    args = arg_parser.parse_args(argv)

    if not args.file or args.file[1] == '-':
        path = '<stdin>'
        fp = stdin
    elif not exists(args.file):
        print('Error: file "%s" not found.' % args.file, file=stderr)
        return 1
    else:
        path = args.file
        fp = opener(path)

    externs = {}
    for d in args.define:
        k, v = d.split('=', 1)
        externs[k] = json.loads(v)

    msg = fp.read()
    result = parse(msg, path, externs)
    if result.err:
        print(result.err, file=stderr)
        return 1
    print(json.dumps(result.val, indent=2), file=stdout)
    return 0
'''  # main_header

imports: '''
@if[generator_options.main '
import argparse
import json
import os
import sys
' '']
@if[grammar.re_needed 'import re' '']
from typing import Any, Dict, NamedTuple, Optional
@if[grammar.unicodedata_needed 'import unicodedata' '']
'''  # imports

result_class: '''


class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if any
    and `pos` will indicate the point in the text where the parser stopped.
    If the parse is unsuccessful, `err` will contain a string describing
    any errors that occurred during the parse and `pos` will indicate
    the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None
'''

parsing_runtime_exception_class: '''


class _ParsingRuntimeError(Exception):
    pass
'''


operator_state_class: '''


class _OperatorState:
    def __init__(self):
        self.current_depth = 0
        self.current_prec = 0
        self.prec_ops = {}
        self.precs = []
        self.rassoc = set()
        self.choices = {}
'''

parse_function: '''


def parse(
    text: str, path: str = '<string>', externs: Externs = None
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs)
'''  # parse_function

parser_class: '''


class _Parser:
    @parser_constructor
    @parser_methods
'''

default_footer: ''

main_footer: '''


if __name__ == '__main__':
    sys.exit(main())
'''

#
# Rules for methods in the parser class
#

# TODO: Handle self._externs properly.
parser_constructor: '''
def __init__(self, text, path):
    self._text = text
    self._end = len(self._text)
    self._errpos = 0
    self._failed = False
    self._path = path
    self._pos = 0
    self._val = None
    self._externs = {}

    @if[generator_options.memoize 'self._cache = {}' '']
    @if[grammar.seeds_needed 'self._seeds = {}' '']
    @if[grammar.leftrec_needed 'self._blocked = set()' '']
    @if[grammar.re_needed 'self._regexps = {}' '']
    @if[grammar.lookup_needed 'self._scopes = []' '']
    @if[grammar.operator_needed operator_state '']
'''

operator_state: '# operator state'

parser_methods: '''
@parse_method
@map[[fn [name] [invoke [strcat 'o_' name]]] grammar.needed_operators '\n']
@map[[fn [rule node] [rule_method rule node]] grammar.rules '\n']
@if[generator_options.memoize o_operator '']
@if[grammar.needed_builtin_functions '\n' '']
@map[[fn [name] [invoke [strcat 'fn_' name]]]
     grammar.needed_builtin_functions
     '\n']
'''

parse_method: '''
@if[grammar.exception_needed parse_with_exception parse_without_exception]

'''

parse_with_exception: '''
def parse(self, externs: Externs = None):
    errors = ''
    if externs:
        for k, v in externs.items():
            if k in self._externs:
                self._externs[k] = v
            else:
                errors += f'Unexpected extern "{k}"\\n'
    if errors:
        return Result(None, errors, 0)
    try:
        self._r_@grammar.starting_rule()

        if self._failed:
            return Result(None, self._error(), self._errpos)
        return Result(self._val, None, self._pos)
    except _ParsingRuntimeError as e:  # pragma: no cover
        lineno, _ = self._offsets(self._errpos)
        return Result(
            None,
            self._path + ':' + str(lineno) + ' ' + str(e),
            self._errpos,
        )
'''

parse_without_exception: '''
def parse(self, externs: Externs = None):
    if externs:
        for k, v in externs.items():
            self._externs[k] = v

    self._r_@grammar.starting_rule()

    if self._failed:
        return Result(None, self._error(), self._errpos)
    return Result(self._val, None, self._pos)
'''

#
# helper methods
#

expr: [fn [node] [invoke [strcat 'n_' node.t] [node]]

stmts: [fn [node] [invoke [strcat 'n_' node.t] [node]]]

rule_method: [fn [rule node] [at_exp '''
def _@rule(self):
    @invoke[[strcat 'n_' node.t]]
''']]

rulename: [fn [name] [at_exp 'self._@name']]

invoke_rule: [fn [name args]
                 [saw [join ['self._' name '(']] [comma args] ')']]

end: ''

#
# Rules for each node in the AST
#

n_action: [fn [node]
              [hlist ['o_succeed(' [expr node.child]] ')' [end]]]
   
n_apply: [fn [node] [hlist [[invoke_rule node.rule_name []]] end]]

n_choice: [fn [node] [vlist [['p = self._pos'] 
                             [map [c] [vlist [[stmts c]
                                              'if not self._failed:'
                                              '    return'
                                              'self._o_rewind(p)']]]
                             [stmts [index -1 node.ch]]]]]

n_count: [fn [node] [vlist [['vs = []'
                             'i = 0'
                             [strcat 'cmin, cmax = ' node.v]
                             'while i < cmax:'
                             [indent [vlist [[stmts node.child]
                                             'if self._failed:'
                                             '    if i > cmin:'
                                             '        self._o_succeed(vs)'
                                             '        return'
                                             '    return'
                                             'vs.append(self.val)'
                                             'i += 1']]]
                             'self._o_succeed(vs)']]]]


n_e_arr: [fn [node] [if [equal node.ch []]
                        [lit '[]]
                        [saw '[' [comma [map [fn [c] [expr c]] node.ch]]]]]]


n_e_call: [fn [node] [saw '(' [comma [map [fn [c] [expr c]] node.ch]] ')']]

n_e_const: [fn [node] [lit [invoke node.v]]]

n_e_getitem: [fn [node] [saw '[' [expr node.ch] ']']

n_e_lit: [fn [node] [lit node.v]]

n_e_minus: [fn [node] [tree [expr node.left] '-' [expr node.right]]]

n_e_not: [fn [node] [tree none [invoke 'not'] [expr node.child]]]

n_e_num: [fn [node] [lit node.v]]

n_e_paren: [fn [node] [expr node.child]]

n_e_plus: [fn [node] [tree [expr node.left] '+' [expr node.right]]]

n_e_qual: "# TODO: e_qual"

n_e_var: [fn [node] [if node.outer_scope
                        [invoke_rule 'o_lookup' [join ["'" node.v "'"]]]
                        [if [in node.v grammar.externs]
                            [lit [extern node.v]]
                            [lit [varname node.v]]]]]


n_empty: [fn [node] [hlist [invoke_rule 'o_succeed' [null]] end]]

n_equals: [fn [node] [hlist [invoke_rule 'o_str' [expr node.child]] end]]

n_label: [fn [node] [vlist [[stmts node.child]
                            [@if node.child.can_fail
                                 [vlist [['if self._failed:' '    return']]]
                                 [vlist []]]
                            [@if node.outer_scope
                                 [vlist [[join '' ['self._scopes[-1]['
                                                   node.name
                                                   '] = self._val']]]]
                                 [vlist [[strcat [varname node.name]
                                                 ' = self._val']]]]]]]
                                                  
n_ends_in: '# TODO: ends_in'

n_leftrec: [fn [node] [hlist [invoke_rule 'o_leftrec'
                                          [rulename node.child.v]
                                          [join ["'" node.v "'"]]
                                          [@if node.left_assoc [true] [false]]]
                             [end]]]

n_lit: [fn [node] [hlist [[invoke_rule 'o_str' [lit node.v]] end]

n_not: [fn [node] [vlist ['p = self._pos'
                          'errpos = self._errpos'
                          [stmts node.child]
                          'if self._failed:'
                          '    self._o_succeed(None, p)'
                          'else:'
                          '    self._o_rewind(p)'
                          '    self._errpos = errpos'
                          '    self._o_fail()']]]

n_not_one: '# TODO: not_one'

n_operator: [fn [node] [hlist [[invoke_rule 'o_operator'
                                            [join ["'" node.v "'"]]]]]]

n_opt: [fn [node] [vlist ['p = self._pos'
                          [stmts node.child]
                          'if self._failed:'
                          '    self._succeed([], p)'
                          'else:'
                          '    self._succeed([self._val])']]]


n_paren: [fn [node] [stmts node.child]]

n_plus: [fn [node]
            [vlist ['vs = []'
                    [stmts node.child]
                    'if self._failed:'
                    '    return'
                    'vs.append(self._val)'
                    'while True:'
                    [indent [vlist ['p = self._pos'
                                    [stmts node.child]
                                    'if self._failed or self._pos == p:'
                                    '    self._rewind(p)'
                                    '        break'
                                    '    vs.append(self._val)']]]
                    'self._succeed(vs)']]]

n_pred: [fn [node]
            [vlist [[hlist ['v = ', [expr node.child]]]
                    'if v is True:'
                    '    self._o_succeed(v)'
                    'elif v is False:'
                    '    self._o_fail()'
                    'else:'
                    "    raise _ParsingRuntimeError("Bad predicate value')"]]]

n_range: [fn [node] [hlist [[invoke_rule 'o_range' 
                                         [[lit node.start] [lit node.stop]]]
                            end]]]

n_regexp: [fn [node] 
              [vlist [[strcat 'p =' [lit node.v]]
                      'if p not in self._regexps'
                      '    self._regexps[p] = re.compile(p)'
                      'm = self._regexps[p].match(self._text, self._pos)' 
                      'if m:'
                      '    self._o_succeed(m.group(o), m.end())'
                      '    return'
                      'self._o_fail()']]]

n_run: [fn [node] 
           [vlist ['start = self._pos'
                   [stmts node.child]
                   [@if node.child.can_fail
                        [vlist ['if self._failed:' 
                                '    return']]
                        [vlist []]]
                   'end = self._pos'
                   'self._val = self._text[start:end]']]]

n_scope: [fn [node] [hlist [invoke_rule 'o_unicat', [[lit node.v]]] end]

n_set: [fn [node] 
           [vlist [[strcat 'p =' [lit node.v]]
                   'if p not in self._regexps'
                   '    self._regexps[p] = re.compile(p)'
                   'm = self._regexps[p].match(self._text, self._pos)' 
                   'if m:'
                   '    self._o_succeed(m.group(o), m.end())'
                   '    return'
                   'self._o_fail()']]]

n_seq: [fn [node] 
           [vlist [[stmts [index node.ch 0]]
                   [if [get [index node.ch 0] 'can_fail']
                       [vlist [['if self._failed:'
                                '    return']]
                       []]]
                   [vlist [map [fn [c] [vlist [[stmts c]
                                               [if c.can_fail
                                                   [vlist ['if self.failed:'
                                                           '    return']]
                                                   []]]]]
                               [slice node.ch 1 -1]]]
                   [stmts [index node.ch -1]]]]]
                                   
                          
n_star: [fn [node]
            [vlist [[stmts node.child]
                    'vs = []'
                    'while True:'
                    '    p = self._pos'
                    [indent [vlist [[stmts node.child]]
                                    'if self._failed or self._pos == p:'
                                    '    self._o_rewind(p)'
                                    '    break'
                                    'vs.append(self._val)']]
                    'self._o_succeed(self._val)']]]

n_unicat: [fn [node] [hlist [[invoke_rule 'o_unicat' [[lit node.v]]] end]]

#
# Built-in operators and rules
#

o_ch: '''
def _ch(self, ch):
    p = self._pos
    if p < self._end and self._text[p] == ch:
        self._succeed(ch, self._pos + 1)
    else:
        self._fail()
'''

o_offsets: '''
def _offsets(self, pos):
    lineno = 1
    colno = 1
    for i in range(pos):
        if self._text[i] == '\\n':
            lineno += 1
            colno = 1
        else:
            colno += 1
    return lineno, colno
'''

o_error: '''
def _error(self):
    lineno, colno = self._offsets(self._errpos)
    if self._errpos == len(self._text):
        thing = 'end of input'
    else:
        thing = repr(self._text[self._errpos]).replace("'", '"')
    return '%s:%d Unexpected %s at column %d' % (
        self._path,
        lineno,
        thing,
        colno,
    )
'''

o_fail: '''
def _fail(self):
    self._val = None
    self._failed = True
    self._errpos = max(self._errpos, self._pos)
'''

o_leftrec: '''
def _leftrec(self, rule, rule_name, left_assoc):
    pos = self._pos
    key = (rule_name, pos)
    seed = self._seeds.get(key)
    if seed:
        self._val, self._failed, self._pos = seed
        return
    if rule_name in self._blocked:
        self._val = None
        self._failed = True
        return
    current = (None, True, self._pos)
    self._seeds[key] = current
    if left_assoc:
        self._blocked.add(rule_name)
    while True:
        rule()
        if self._pos > current[2]:
            current = (self._val, self._failed, self._pos)
            self._seeds[key] = current
            self._pos = pos
        else:
            del self._seeds[key]
            self._val, self._failed, self._pos = current
            if left_assoc:
                self._blocked.remove(rule_name)
            return
'''

o_lookup: '''
def _lookup(self, var):
    i = len(self._scopes) - 1
    while i >= 0:
        if var in self._scopes[i]:
            return self._scopes[i][var]
        i -= 1
    if var in self._externs:
        return self._externs[var]
    assert False, f'unknown var {var}'
'''

o_memoize: '''
def _memoize(self, rule_name, fn):
    p = self._pos
    r = self._cache.setdefault(p, {}).get(rule_name)
    if r:
        self._val, self._failed, self._pos = r
        return
    fn()
    self._cache[p][rule_name] = (self._val, self._failed, self._pos)
'''

o_operator: '''
def _operator(self, rule_name):
    o = self._operators[rule_name]
    pos = self._pos
    key = (rule_name, self._pos)
    seed = self._seeds.get(key)
    if seed:
        self._val, self._failed, self._pos = seed
        return
    o.current_depth += 1
    current = (None, True, self._pos)
    self._seeds[key] = current
    min_prec = o.current_prec
    i = 0
    while i < len(o.precs):
        repeat = False
        prec = o.precs[i]
        prec_ops = o.prec_ops[prec]
        if prec < min_prec:
            break
        o.current_prec = prec
        if prec_ops[0] not in o.rassoc:
            o.current_prec += 1
        for j, _ in enumerate(prec_ops):
            op = prec_ops[j]
            o.choices[op]()
            if not self._failed and self._pos > pos:
                current = (self._val, self._failed, self._pos)
                self._seeds[key] = current
                repeat = True
                break
            self._rewind(pos)
        if not repeat:
            i += 1

    del self._seeds[key]
    o.current_depth -= 1
    if o.current_depth == 0:
        o.current_prec = 0
    self._val, self._failed, self._pos = current
'''

o_range: '''
def _range(self, i, j):
    p = self._pos
    if p != self._end and ord(i) <= ord(self._text[p]) <= ord(j):
        self._succeed(self._text[p], self._pos + 1)
    else:
        self._fail()
'''

o_rewind: '''
def _rewind(self, newpos):
    self._succeed(None, newpos)
'''

o_str: '''
def _str(self, s):
    for ch in s:
        self._ch(ch)
        if self._failed:
            return
    self._val = s
'''

o_succeed: '''
def _succeed(self, v, newpos=None):
    self._val = v
    self._failed = False
    if newpos is not None:
        self._pos = newpos
'''

o_unicat: '''
def _unicat(self, cat):
    p = self._pos
    if p < self._end and unicodedata.category(self._text[p]) == cat:
        self._succeed(self._text[p], self._pos + 1)
    else:
        self._fail()
'''

r_any: '''
def _r_any(self):
    if self._pos < self._end:
        self._succeed(self._text[self._pos], self._pos + 1)
    else:
        self._fail()
'''

r_end: '''
def _r_end(self):
    if self._pos == self._end:
        self._succeed(None)
    else:
        self._fail()
'''

#
# Built-in functions
#

fn_atof: '''
def _fn_atof(self, s):
    if '.' in s or 'e' in s or 'E' in s:
        return float(s)
    return int(s)
'''

fn_atoi: '''
def _fn_atoi(self, a, base):
    return int(a, base)
'''

fn_atou: '''
def _fn_atou(self, a, base):
    return chr(int(a, base))
'''

fn_cat: '''
def _fn_cat(self, strs):
    return ''.join(strs)
'''

fn_concat: '''
def _fn_concat(self, xs, ys):
    return xs + ys
'''

fn_cons: '''
def _fn_cons(self, hd, tl):
    return [hd] + tl
'''

fn_dedent: '''
def _fn_dedent(self, s):
    return s
'''

fn_dict: ''' 
def _fn_dict(self, pairs):
    return dict(pairs)
'''

fn_itou: '''
def _fn_itou(self, n):
    return chr(n)
'''

fn_join: '''
def _fn_join(self, s, vs):
    return s.join(vs)
'''

fn_otou: '''
def _fn_otou(self, s):
    return chr(int(s, base=8))
'''

fn_scat: '''
def _fn_scat(self, hd, tl):
    return self._fn_cat(self._fn_cons(hd, tl))
'''

fn_scons: '''
def _fn_scons(self, hd, tl):
    return [hd] + tl
'''

fn_strcat: '''
def _fn_strcat(self, a, b):
    return a + b
'''

fn_unicode_lookup: '''
def _fn_unicode_lookup(self, s):
    return unicodedata.lookup(s)
'''

fn_utoi: '''
def _fn_utoi(self, s):
    return ord(s)
'''

fn_xtoi: '''
def _fn_xtoi(self, s):
    return int(s, base=16)
'''

fn_xtou: '''
def _fn_xtou(self, s):
    return chr(int(s, base=16))
'''
