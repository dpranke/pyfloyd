# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This file contains the code generation templates for Python3.
# It depends on a base set of templates used by fairly similar languages.

name = 'Python'
ext = '.py'
indent = 4
line_length = 79

starting_template: 'generate'

inherit: ['base.dft']

# Python doesn't need to declare local vars
declare_local_vars: false

templates: {

#
# Helper rules
#

block: [fn [head body] [vl [hl head ':'] [ind body]]]


# Reference different kinds of variable names.

fld: [fn [name] [strcat 'self._' name]]

method_name: [fn [name] [fld name]]

extern: [fn [name] [strcat 'self._externs[' [lit name] ']']]

# Returns a field or method on the generated parse object.
f_pos: [fld 'pos']
f_errpos: [fld 'errpos']
f_val: [fld 'val']
failed: [fld 'failed']

#
# Helpers for generating text portably
#

t_assign: [fn [var val] [hl var ' = ' val t_end]]
t_assign_outer: [fn [var val]
                    [hl "self._scopes[-1]['" var "'] = " val]]
t_append: [fn [lst val] [hl lst '.append(' val ')' t_end]]
t_break:   'break'
t_end: ''  # statement terminator (not used in Python)
t_false: 'False'
t_meth_def: 'def _'
t_meth_self: 'self'
t_meth_params: [fn [params]
                   [if [equal params ''] 'self' [strcat 'self, ' params]]]
t_newmap: '{}'
t_null: 'None'
t_not: 'not '  # the logical operator
t_true: 'True'
t_eq: [fn [x y] [hl x ' == ' y]]
t_if: [fn [cond body] [block [hl 'if ' cond] body]]
t_ifelse: [fn [cond if_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block 'else' e_body]]]
t_ifelifelse: [fn [cond if_body elif_cond elif_body e_body]
              [vl [block [hl 'if ' cond] if_body]
                  [block [hl 'elif ' elif_cond] elif_body]
                  [block 'else' e_body]]]
t_istrue: [fn [v] [hl v ' is True']]
t_isfalse: [fn [v] [hl v ' is False']]
t_declare_local_vars: [fn [node] [vl]]
t_declare_vars: [fn [v] [vl]]
t_or: [fn [x y] [hl x ' or ' y]]
t_pop: [fn [lst] [hl lst '.pop()']]
t_return:  'return'
t_substr: [fn [s start end] [hl s '[' start ':' end ']']]
t_throw: [fn [msg] [hl 'raise _ParsingRuntimeError(' msg ')' t_end]]
t_toplevel_extra_sep: ''
t_while: [fn [cond body] [block [hl 'while ' cond] body]]

#
# The basic block structure of the file is given in the `generate` template
# in base. This section defines the templates `generate` references.
#

default_header: @"""
    # Generated by pyfloyd version @generator_options.version
    #    https://github.com/dpranke/pyfloyd
    #
    @wrap_argv['#    `' '#    ']
    #

    @imports

    Externs = Optional[Dict[str, Any]]

    # pylint: disable=too-many-lines
    """

main_header: @"""
    #!/usr/bin/env python3
    @default_header[]
    """

imports: [vl [if generator_options.main
                 [vl 'import argparse'
                     'import json'
                     'import os'
                     'import sys']]
             [if grammar.re_needed 'import re']
             'from typing import Any, Dict, NamedTuple, Optional'
             [if grammar.unicodedata_needed 'import unicodedata']]

parsing_runtime_exception_class: d"""
    class _ParsingRuntimeError(Exception):
        pass
    """

operator_state_class: d"""
    class _OperatorState:
        def __init__(self):
            self.current_depth: int = 0
            self.current_prec: int = 0
            self.prec_ops: dict[int, str] = {}
            self.precs: list[int] = []
            self.rassoc: set[str] = set()
            self.choices: dict[str, Any] = {}  # really dict[str, grammar.Rule]
    """  # operator_state_class

result_class: d'''
    class Result(NamedTuple):
        """The result returned from a `parse()` call.

        If the parse is successful, `val` will contain the returned value, if
        any and `pos` will indicate the point in the text where the parser
        stopped.  If the parse is unsuccessful, `err` will contain a string
        describing any errors that occurred during the parse and `pos` will
        indicate the location of the farthest error in the text.
        """

        val: Any = None
        err: Optional[str] = None
        pos: Optional[int] = None
    '''  # result_class


parse_function: d'''
    def parse(
        text: str, path: str = '<string>', externs: Externs = None, start: int = 0
    ) -> Result:
        """Parse a given text and return the result.

        If the parse was successful, `result.val` will be the returned value
        from the parse, and `result.pos` will indicate where the parser
        stopped when it was done parsing.

        If the parse is unsuccessful, `result.err` will be a string describing
        any errors found in the text, and `result.pos` will indicate the
        furthest point reached during the parse.

        If the optional `path` is provided it will be used in any error
        messages to indicate the path to the filename containing the given
        text.
        """
        return _Parser(text, path).parse(externs, start)
    '''  # parse_function

parser_class: @"""
    class _Parser:
        @parser_methods[]
    """

parser_constructor: @"""
    def __init__(self, text, path):
        self._text = text
        self._end = len(self._text)
        self._errpos = 0
        self._failed = False
        self._path = path
        self._pos = 0
        self._val = None
        @externs[]
        @if[generator_options.memoize 'self._cache = {}']
        @if[grammar.seeds_needed 'self._seeds = {}']
        @if[grammar.leftrec_needed 'self._blocked = set()']
        @if[grammar.re_needed 'self._regexps = {}']
        @if[grammar.lookup_needed 'self._scopes = []']
        @if[grammar.operator_needed
            [vl 'self._operators = {}'
                [map_items operator_state grammar.operators]]]

    """  # parser_constructor

externs: [fn [] [if [dict_is_empty grammar.externs]
                    [vl 'self._externs = {}']
                    [vl 'self._externs = {'
                        [ind [map_items [fn [k v]
                                            [hl [lit k]
                                                ": "
                                                [if v 'True' 'False']
                                                ","]]
                                        grammar.externs]]
                        '}']]]

operator_state: [fn [rule o]
                    [vl 'o = _OperatorState()'
                        [operator_prec_ops o]
                        'o.precs = sorted(o.prec_ops, reverse=True)'
                        [operator_rassoc o]
                        [operator_choices o]
                        [hl 'self._operators[' [lit rule] '] = o']]]

operator_prec_ops: [fn [o]
                       [vl 'o.prec_ops = {'
                           [ind [map [fn [prec]
                                       [hl [itoa prec]
                                           ': ['
                                           [map [fn [op] [lit op]]
                                                [get o.prec_ops prec]
                                                ', ']
                                           '],']]
                                     [sort [keys o.prec_ops]]]]
                           '}']]

operator_rassoc: [fn [o]
                     [hl 'o.rassoc = set(['
                         [comma  [map [fn [op] [strcat "'" op "'"]]
                                      o.rassoc]]
                         '])']]

operator_choices: [fn [o] [vl 'o.choices = {'
                              [ind [map_items [fn [op meth]
                                                  [hl [lit op]
                                                      ': self._'
                                                      meth
                                                      ',']]
                                              o.choices]]
                              '}']]

parse_with_exception: @"""
    def parse(self, externs: Externs = None, start: int = 0):
        self._pos = start
        errors = ''
        if externs:
            for k, v in externs.items():
                if k in self._externs:
                    self._externs[k] = v
                else:
                    errors += f'Unexpected extern "{k}"\n'
        if errors:
            return Result(None, errors, 0)
        try:
            self._r_@grammar.starting_rule()

            if self._failed:
                return Result(None, self._o_error(), self._errpos)
            return Result(self._val, None, self._pos)
        except _ParsingRuntimeError as e:  # pragma: no cover
            lineno, _ = self._o_offsets(self._errpos)
            return Result(
                None,
                self._path + ':' + str(lineno) + ' ' + str(e),
                self._errpos,
            )
    """

parse_without_exception: @"""
    def parse(self, externs: Externs = None, start: int = 0):
        self._pos = start
        if externs:
            for k, v in externs.items():
                self._externs[k] = v

        self._r_@grammar.starting_rule()

        if self._failed:
            return Result(None, self._o_error(), self._errpos)
        return Result(@f_val, None, @f_pos)
    """

builtin_fn: [fn [name]
                [if [and [has functions name]
                         [has [get functions name] 'body']]
                    [vl ''
                        [def_method [fn_name name]
                                    [function_param_names name]
                                    [get [get functions name] 'body']]]
                    [vl '' [invoke [fn_name name]]]]]

function_param_names: [fn [name] [map [fn [p] [item p 0]]
                                 [get [get functions name] 'params']]]

default_footer: null

main_footer: d"""


    def main(
        argv=sys.argv[1:],
        stdin=sys.stdin,
        stdout=sys.stdout,
        stderr=sys.stderr,
        exists=os.path.exists,
        opener=open,
    ) -> int:
        arg_parser = argparse.ArgumentParser()
        arg_parser.add_argument('-c', '--code')
        arg_parser.add_argument(
            '-D',
            '--define',
            action='append',
            metavar='var=val',
            default=[],
            help='define an external var=value (may use multiple times)'
        )
        arg_parser.add_argument('file', nargs='?')
        args = arg_parser.parse_args(argv)

        if args.code is not None:
            msg = args.code
            path = '<code>'
        elif not args.file or args.file[1] == '-':
            path = '<stdin>'
            fp = stdin
        elif not exists(args.file):
            print('Error: file "%s" not found.' % args.file, file=stderr)
            return 1
        else:
            path = args.file
            fp = opener(path)

        externs = {}
        for d in args.define:
            k, v = d.split('=', 1)
            externs[k] = json.loads(v)

        if args.code is None:
            msg = fp.read()
        result = parse(msg, path, externs)
        if result.err:
            print(result.err, file=stderr)
            return 1
        print(json.dumps(result.val, indent=2), file=stdout)
        return 0


    if __name__ == '__main__':
        sys.exit(main())
    """  # main_footer

#
# Language-specific rules for nodes in the AST.
#

n_regexp: [fn [node]
              [vl [t_assign 'rexp' [lit node.v]]
                  'if rexp not in self._regexps:'
                  '    self._regexps[rexp] = re.compile(rexp)'
                  'm = self._regexps[rexp].match(self._text, self._pos)'
                  'if m:'
                  '    self._o_succeed(m.group(0), m.end())'
                  '    return'
                  [fail]]]

n_set: [fn [node]
           [vl [t_assign 'rexp' [lit [strcat '[' node.v ']']]]
               [t_if 'rexp not in self._regexps'
                     'self._regexps[rexp] = re.compile(rexp)']
               'm = self._regexps[rexp].match(self._text, self._pos)'
               [t_if 'm'
                     [vl [succeed 'm.group(0)' 'm.end()']
                         t_return]]
               [fail]]]

#
# Built-in operators and rules
#

r_any: [
    meth q[] d"
        if self._pos < self._end:
            self._o_succeed(self._text[self._pos], self._pos + 1)
        else:
            self._o_fail()
        "]

r_end: [meth q[] d"
             if self._pos == self._end:
                 self._o_succeed(None, self._pos)
             else:
                 self._o_fail()
             "]

o_ch: [meth q['ch'] d"
           pos = self._pos
           if pos < self._end and self._text[pos] == ch:
               self._o_succeed(ch, self._pos + 1)
           else:
               self._o_fail()
           "]

o_offsets: [meth q['pos'] d'''
                lineno = 1
                colno = 1
                for i in range(pos):
                    if self._text[i] == '\\n':
                        lineno += 1
                        colno = 1
                    else:
                        colno += 1
                return lineno, colno
                ''']

o_error: [meth q[] d'''
              lineno, colno = self._o_offsets(self._errpos)
              if self._errpos == len(self._text):
                  thing = 'end of input'
              else:
                  thing = repr(self._text[self._errpos]).replace("'", '"')
              path = self._path
              return f'{path}:{lineno} Unexpected {thing} at column {colno}'
              ''']

o_fail: [meth q[] d'''
              self._val = None
              self._failed = True
              self._errpos = max(self._errpos, self._pos)
              ''']

o_leftrec: [meth q['rule' 'rule_name' 'left_assoc'] d'''
                  pos = self._pos
                  key = (rule_name, pos)
                  seed = self._seeds.get(key)
                  if seed:
                      self._val, self._failed, self._pos = seed
                      return
                  if rule_name in self._blocked:
                      self._val = None
                      self._failed = True
                      return
                  current = (None, True, self._pos)
                  self._seeds[key] = current
                  if left_assoc:
                      self._blocked.add(rule_name)
                  while True:
                      rule()
                      if self._pos > current[2]:
                          current = (self._val, self._failed, self._pos)
                          self._seeds[key] = current
                          self._pos = pos
                      else:
                          del self._seeds[key]
                          self._val, self._failed, self._pos = current
                          if left_assoc:
                              self._blocked.remove(rule_name)
                          return
                  ''']

o_lookup: [meth q['var'] d'''
                i = len(self._scopes) - 1
                while i >= 0:
                    if var in self._scopes[i]:
                        return self._scopes[i][var]
                    i -= 1
                if var in self._externs:
                    return self._externs[var]
                assert False, f'unknown var {var}'
                ''']

o_memoize: [meth q['rule_name' 'fn'] d'''
        pos = self._pos
        if pos not in self._cache:
            self._cache[pos] = {}
        c = self._cache[pos]
        if rule_name in c:
            self._val, self._failed, self._pos = c[rule_name]
            return
        fn()
        c[rule_name] = (self._val, self._failed, self._pos)
        ''']

o_operator: [meth q['rule_name'] d'''
        o = self._operators[rule_name]
        pos = self._pos
        key = (rule_name, self._pos)
        seed = self._seeds.get(key)
        if seed:
            self._val, self._failed, self._pos = seed
            return
        o.current_depth += 1
        current = (None, True, self._pos)
        self._seeds[key] = current
        min_prec = o.current_prec
        i = 0
        while i < len(o.precs):
            repeat = False
            prec = o.precs[i]
            prec_ops = o.prec_ops[prec]
            if prec < min_prec:
                break
            o.current_prec = prec
            if prec_ops[0] not in o.rassoc:
                o.current_prec += 1
            for j, _ in enumerate(prec_ops):
                op = prec_ops[j]
                o.choices[op]()
                if not self._failed and self._pos > pos:
                    current = (self._val, self._failed, self._pos)
                    self._seeds[key] = current
                    repeat = True
                    break
                self._o_rewind(pos)
            if not repeat:
                i += 1

        del self._seeds[key]
        o.current_depth -= 1
        if o.current_depth == 0:
            o.current_prec = 0
        self._val, self._failed, self._pos = current
        ''']

o_range: [meth q['i' 'j'] d'''
               pos = self._pos
               if pos != self._end and ord(i) <= ord(self._text[pos]) <= ord(j):
                   self._o_succeed(self._text[pos], self._pos + 1)
               else:
                   self._o_fail()
               ''']

o_rewind: [meth q['newpos'] 'self._o_succeed(None, newpos)']

o_str: [meth q['s'] d'''
             for ch in s:
                 self._o_ch(ch)
                 if self._failed:
                     return
             self._val = s
             ''']

o_succeed: [meth q['v' 'newpos'] d"
                self._val = v
                self._failed = False
                self._pos = newpos
                "]

o_unicat: [
    meth q['cat'] d"
         pos = self._pos
         if pos < self._end and unicodedata.category(self._text[pos]) == cat:
             self._o_succeed(self._text[pos], self._pos + 1)
         else:
             self._o_fail()
         "]

fn_colno: [
    meth q[] d"""
            colno = 0
            if self._pos == self._end:
                colno += 1
            while self._pos >= colno and self._text[self._pos - colno] != '\\n':
                colno += 1
            return colno
            """]

}
