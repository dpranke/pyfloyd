generate: '''
@if[generator_options.main main_header default_header]
@if[grammar.exception_needed parsing_runtime_exception_class '']
@if[grammar.operators operator_state_class '']
@result_class
@parse_function
@parser_class
@if[generator_options.main main_footer default_footer]
'''

#
# Basic block structure of the file
#

default_header: '''
# Generated by pyfloyd version @generator_options.version
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`
@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines
'''

main_header: '''
#!/usr/bin/env python3
#
# Generated by pyfloyd version {version}
#    https://github.com/dpranke/pyfloyd
#    `pyfloyd @generator_options.args`

@imports

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


def main(
    argv=sys.argv[1:],
    stdin=sys.stdin,
    stdout=sys.stdout,
    stderr=sys.stderr,
    exists=os.path.exists,
    opener=open,
) -> int:
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument(
        '-D',
        '--define',
        action='append',
        metavar='var=val',
        default=[],
        help='define an external var=value (may use multiple times)'
    )
    arg_parser.add_argument('file', nargs='?')
    args = arg_parser.parse_args(argv)

    if not args.file or args.file[1] == '-':
        path = '<stdin>'
        fp = stdin
    elif not exists(args.file):
        print('Error: file "%s" not found.' % args.file, file=stderr)
        return 1
    else:
        path = args.file
        fp = opener(path)

    externs = {}
    for d in args.define:
        k, v = d.split('=', 1)
        externs[k] = json.loads(v)

    msg = fp.read()
    result = parse(msg, path, externs)
    if result.err:
        print(result.err, file=stderr)
        return 1
    print(json.dumps(result.val, indent=2), file=stdout)
    return 0
'''  # main_header

imports: '''
@if[generator_options.main 'import argparse\nimport json\nimport os\nimport sys\n' '']
@if[grammar.re_needed 'import re' '']
from typing import Any, Dict, NamedTuple, Optional
@if[grammar.unicodedata_needed 'import unicodedata' '']
'''  # imports

result_class: '''


class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if any
    and `pos` will indicate the point in the text where the parser stopped.
    If the parse is unsuccessful, `err` will contain a string describing
    any errors that occurred during the parse and `pos` will indicate
    the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None
'''

parsing_runtime_exception_class: '''


class _ParsingRuntimeError(Exception):
    pass
'''


operator_state_class: '''


class _OperatorState:
    def __init__(self):
        self.current_depth = 0
        self.current_prec = 0
        self.prec_ops = {}
        self.precs = []
        self.rassoc = set()
        self.choices = {}
'''

parse_function: '''


def parse(
    text: str, path: str = '<string>', externs: Externs = None
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs)
'''  # parse_function

parser_class: '''


class _Parser:
    @parser_constructor
    @parser_methods
'''

default_footer: ''

main_footer: '''


if __name__ == '__main__':
    sys.exit(main())
'''

#
# rules for methods in the parser class
#

# TODO: Handle self._externs properly.
parser_constructor: '''
def __init__(self, text, path):
    self._text = text
    self._end = len(self._text)
    self._errpos = 0
    self._failed = False
    self._path = path
    self._pos = 0
    self._val = None
    self._externs = {}

    @if[generator_options.memoize 'self._cache = {}' '']
    @if[grammar.seeds_needed 'self._seeds = {}' '']
    @if[grammar.leftrec_needed 'self._blocked = set()' '']
    @if[grammar.re_needed 'self._regexps = {}' '']
    @if[grammar.lookup_needed 'self._scopes = []' '']
    @if[grammar.operator_needed operator_state '']
'''

operator_state: '# operator state'

parser_methods: '''
@parse_method

@map[[method]
     [invoke [strcat 'o_' method]]
     grammar.needed_operators
     '\n']
@map[[rule node] [rule_method rule node] grammar.rules '\n']

@if[generator_options.memoize o_operator '']
@if[grammar.needed_builtin_functions '\n' '']
@map[[method]
     [invoke [strcat 'fn_' method]]
     grammar.needed_builtin_functions
     '\n'
    ]
'''

parse_method: '''
@if[grammar.exception_needed parse_with_exception parse_without_exception]
'''

parse_with_exception: '''
def parse(self, externs: Externs = None):
    errors = ''
    if externs:
        for k, v in externs.items():
            if k in self._externs:
                self._externs[k] = v
            else:
                errors += f'Unexpected extern "{k}"\\n'
    if errors:
        return Result(None, errors, 0)
    try:
        self._r_@grammar.starting_rule()

        if self._failed:
            return Result(None, self._error(), self._errpos)
        return Result(self._val, None, self._pos)
    except _ParsingRuntimeError as e:  # pragma: no cover
        lineno, _ = self._offsets(self._errpos)
        return Result(
            None,
            self._path + ':' + str(lineno) + ' ' + str(e),
            self._errpos,
        )
'''

parse_without_exception: '''
def parse(self, externs: Externs = None):
    if externs:
        for k, v in externs.items():
            self._externs[k] = v

    self._r_@grammar.starting_rule()

    if self._failed:
        return Result(None, self._error(), self._errpos)
    return Result(self._val, None, self._pos)
'''

# params 'rule', 'node'
rule_method: '''

def _@rule(self):
    @invoke[[strcat 'n_' node.t]]
'''

# params 'arg_1'
rulename: 'self._@arg_1'

end: ''

#
# Rules for each node in the AST
#

n_action: '''
@hlist[[saw [strcat [rulename 'succeed'] '(']
            'True'
            ')']
       end]
'''
   

n_apply: ''

n_e_arr: ''

n_e_call: ''

n_e_const: ''

n_e_getitem: ''

n_e_lit: ''

n_e_minus: ''

n_e_not: ''

n_e_num: ''

n_e_plus: ''

n_e_qual: ''

n_e_var: ''

n_empty: ''

n_equals: ''

n_label: ''

n_leftrec: ''

n_lit: ''

n_not: ''

n_not_one: ''

n_operator: ''

n_opt: ''

n_paren: ''

n_plus: ''

n_pred: ''

n_range: ''

n_regexp: ''

n_run: ''

n_scope: ''

n_set: ''

n_seq: ''

n_star: ''

n_unicat: ''

#
# Built-in operators and rules
#

o_ch: '''
def _ch(self, ch):
    p = self._pos
    if p < self._end and self._text[p] == ch:
        self._succeed(ch, self._pos + 1)
    else:
        self._fail()
'''

o_offsets: '''
def _offsets(self, pos):
    lineno = 1
    colno = 1
    for i in range(pos):
        if self._text[i] == '\\n':
            lineno += 1
            colno = 1
        else:
            colno += 1
    return lineno, colno
'''

o_error: '''
def _error(self):
    lineno, colno = self._offsets(self._errpos)
    if self._errpos == len(self._text):
        thing = 'end of input'
    else:
        thing = repr(self._text[self._errpos]).replace("'", '"')
    return '%s:%d Unexpected %s at column %d' % (
        self._path,
        lineno,
        thing,
        colno,
    )
'''

o_fail: '''
def _fail(self):
    self._val = None
    self._failed = True
    self._errpos = max(self._errpos, self._pos)
'''

o_leftrec: '''
def _leftrec(self, rule, rule_name, left_assoc):
    pos = self._pos
    key = (rule_name, pos)
    seed = self._seeds.get(key)
    if seed:
        self._val, self._failed, self._pos = seed
        return
    if rule_name in self._blocked:
        self._val = None
        self._failed = True
        return
    current = (None, True, self._pos)
    self._seeds[key] = current
    if left_assoc:
        self._blocked.add(rule_name)
    while True:
        rule()
        if self._pos > current[2]:
            current = (self._val, self._failed, self._pos)
            self._seeds[key] = current
            self._pos = pos
        else:
            del self._seeds[key]
            self._val, self._failed, self._pos = current
            if left_assoc:
                self._blocked.remove(rule_name)
            return
'''

o_lookup: '''
def _lookup(self, var):
    i = len(self._scopes) - 1
    while i >= 0:
        if var in self._scopes[i]:
            return self._scopes[i][var]
        i -= 1
    if var in self._externs:
        return self._externs[var]
    assert False, f'unknown var {var}'
'''

o_memoize: '''
def _memoize(self, rule_name, fn):
    p = self._pos
    r = self._cache.setdefault(p, {}).get(rule_name)
    if r:
        self._val, self._failed, self._pos = r
        return
    fn()
    self._cache[p][rule_name] = (self._val, self._failed, self._pos)
'''

o_operator: '''
def _operator(self, rule_name):
    o = self._operators[rule_name]
    pos = self._pos
    key = (rule_name, self._pos)
    seed = self._seeds.get(key)
    if seed:
        self._val, self._failed, self._pos = seed
        return
    o.current_depth += 1
    current = (None, True, self._pos)
    self._seeds[key] = current
    min_prec = o.current_prec
    i = 0
    while i < len(o.precs):
        repeat = False
        prec = o.precs[i]
        prec_ops = o.prec_ops[prec]
        if prec < min_prec:
            break
        o.current_prec = prec
        if prec_ops[0] not in o.rassoc:
            o.current_prec += 1
        for j, _ in enumerate(prec_ops):
            op = prec_ops[j]
            o.choices[op]()
            if not self._failed and self._pos > pos:
                current = (self._val, self._failed, self._pos)
                self._seeds[key] = current
                repeat = True
                break
            self._rewind(pos)
        if not repeat:
            i += 1

    del self._seeds[key]
    o.current_depth -= 1
    if o.current_depth == 0:
        o.current_prec = 0
    self._val, self._failed, self._pos = current
'''

o_range: '''
def _range(self, i, j):
    p = self._pos
    if p != self._end and ord(i) <= ord(self._text[p]) <= ord(j):
        self._succeed(self._text[p], self._pos + 1)
    else:
        self._fail()
'''

o_rewind: '''
def _rewind(self, newpos):
    self._succeed(None, newpos)
'''

o_str: '''
def _str(self, s):
    for ch in s:
        self._ch(ch)
        if self._failed:
            return
    self._val = s
'''

o_succeed: '''
def _succeed(self, v, newpos=None):
    self._val = v
    self._failed = False
    if newpos is not None:
        self._pos = newpos
'''

o_unicat: '''
def _unicat(self, cat):
    p = self._pos
    if p < self._end and unicodedata.category(self._text[p]) == cat:
        self._succeed(self._text[p], self._pos + 1)
    else:
        self._fail()
'''

r_any: '''
def _r_any(self):
    if self._pos < self._end:
        self._succeed(self._text[self._pos], self._pos + 1)
    else:
        self._fail()
'''

r_end: '''
def _r_end(self):
    if self._pos == self._end:
        self._succeed(None)
    else:
        self._fail()
'''

#
# Built-in functions
#

fn_atof: '''
def _fn_atof(self, s):
    if '.' in s or 'e' in s or 'E' in s:
        return float(s)
    return int(s)
'''

fn_atoi: '''
def _fn_atoi(self, a, base):
    return int(a, base)
'''

fn_atou: '''
def _fn_atou(self, a, base):
    return chr(int(a, base))
'''

fn_cat: '''
def _fn_cat(self, strs):
    return ''.join(strs)
'''

fn_concat: '''
def _fn_concat(self, xs, ys):
    return xs + ys
'''

fn_cons: '''
def _fn_cons(self, hd, tl):
    return [hd] + tl
'''

fn_dedent: '''
def _fn_dedent(self, s):
    return s
'''

fn_dict: ''' 
def _fn_dict(self, pairs):
    return dict(pairs)
'''

fn_itou: '''
def _fn_itou(self, n):
    return chr(n)
'''

fn_join: '''
def _fn_join(self, s, vs):
    return s.join(vs)
'''

fn_otou: '''
def _fn_otou(self, s):
    return chr(int(s, base=8))
'''

fn_scat: '''
def _fn_scat(self, hd, tl):
    return self._fn_cat(self._fn_cons(hd, tl))
'''

fn_scons: '''
def _fn_scons(self, hd, tl):
    return [hd] + tl
'''

fn_strcat: '''
def _fn_strcat(self, a, b):
    return a + b
'''

fn_unicode_lookup: '''
def _fn_unicode_lookup(self, s):
    return unicodedata.lookup(s)
'''

fn_utoi: '''
def _fn_utoi(self, s):
    return ord(s)
'''

fn_xtoi: '''
def _fn_xtoi(self, s):
    return int(s, base=16)
'''

fn_xtou: '''
def _fn_xtou(self, s):
    return chr(int(s, base=16))
'''
