# Generated by pyfloyd version 0.28.0.dev0
#    https://github.com/dpranke/pyfloyd
#
#    `flc -o src/pyfloyd/lisp_parser.py grammars/lisp.g`
#

import re
from typing import Any, Dict, NamedTuple, Optional

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if
    any and `pos` will indicate the point in the text where the parser
    stopped.  If the parse is unsuccessful, `err` will contain a string
    describing any errors that occurred during the parse and `pos` will
    indicate the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None


def parse(
    text: str, path: str = '<string>', externs: Externs = None, start: int = 0
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs, start)


class _State:
    def __init__(self, pos: int = 0, failed: bool = False, val: Any = None):
        self.pos = pos
        self.failed = failed
        self.val = val

    def __repr__(self):
        return f'_State(pos={self.pos}, failed={self.failed})'

    def copy(self):
        r = _State()
        r.pos = self.pos
        r.failed = self.failed
        r.val = self.val
        return r


class _ParsingRuntimeError(Exception):
    pass


class _Parser:
    def __init__(self, text, path):
        self._text = text
        self._end = len(self._text)
        self._errpos = 0
        self._path = path
        self._state = _State()
        self._externs = {
            'allow_trailing': False,
        }
        self._regexps = {}

    def pos(self):
        return self._state.pos

    def parse(self, externs: Externs = None, start: int = 0):
        self._state = _State(pos=start)
        errors = ''
        if externs:
            for k, v in externs.items():
                if k in self._externs:
                    self._externs[k] = v
                else:
                    errors += f'Unexpected extern "{k}"\n'
        for k, v in self._externs.items():
            if v is None:
                errors += f'Missing required extern "{k}"'
        if errors:
            return Result(None, errors, 0)

        try:
            self._r_grammar()

            if self._state.failed:
                return Result(None, self._o_error(), self._errpos)
            return Result(self._state.val, None, self._state.pos)
        except _ParsingRuntimeError as e:  # pragma: no cover
            lineno, _ = self._o_offsets(self._errpos)
            return Result(
                None,
                self._path + ':' + str(lineno) + ' ' + str(e),
                self._errpos,
            )

    def _r_grammar(self):
        self._s_grammar_1()
        v__1 = self._state.val
        self._r_opt_end()
        if self._state.failed:
            return
        self._o_succeed(v__1, self._state.pos)

    def _s_grammar_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_grammar_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_grammar_2(self):
        state = self._state.copy()
        self._s_grammar_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r_list()

    def _s_grammar_3(self):
        self._r__filler()
        self._r_atom()

    def _r_ws(self):
        self._r__filler()
        self._s_ws_1()

    def _s_ws_1(self):
        rexp = '[ \t\n]+'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_atom(self):
        state = self._state.copy()
        self._s_atom_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_atom_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_atom_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_atom_4()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r_number()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r_string()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r_symbol()

    def _s_atom_1(self):
        self._o_str('#t')
        if self._state.failed:
            return
        self._o_succeed(True, self._state.pos)

    def _s_atom_2(self):
        self._o_str('true')
        if self._state.failed:
            return
        self._o_succeed(True, self._state.pos)

    def _s_atom_3(self):
        self._o_str('#f')
        if self._state.failed:
            return
        self._o_succeed(False, self._state.pos)

    def _s_atom_4(self):
        self._o_str('false')
        if self._state.failed:
            return
        self._o_succeed(False, self._state.pos)

    def _r_number(self):
        state = self._state.copy()
        self._s_number_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_number_2()

    def _s_number_1(self):
        self._o_ch('0')
        if self._state.failed:
            return
        self._o_succeed(0, self._state.pos)

    def _s_number_2(self):
        self._s_number_3()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(self._fn_atoi(v__1, 10), self._state.pos)

    def _s_number_3(self):
        rexp = '[1-9][0-9]*'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_string(self):
        self._o_ch('"')
        if self._state.failed:
            return
        self._s_string_1()
        v__2 = self._state.val
        self._o_ch('"')
        if self._state.failed:
            return
        self._o_succeed(self._fn_join('', v__2), self._state.pos)

    def _s_string_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._r_ch()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _r_ch(self):
        state = self._state.copy()
        self._s_ch_1()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_ch_2()
        if not self._state.failed:
            return
        self._o_restore(state)
        state = self._state.copy()
        errpos = self._errpos
        self._o_ch('"')
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()
        if not self._state.failed:
            self._r_any()

    def _s_ch_1(self):
        self._o_str('\\\\')
        if self._state.failed:
            return
        self._o_succeed('\\', self._state.pos)

    def _s_ch_2(self):
        self._o_str('\\\n')
        if self._state.failed:
            return
        self._o_succeed('\n', self._state.pos)

    def _r_symbol(self):
        self._s_symbol_1()
        if self._state.failed:
            return
        v__1 = self._state.val
        if self._state.failed:
            return
        self._o_succeed(['symbol', v__1], self._state.pos)

    def _s_symbol_1(self):
        rexp = '[a-zA-Z][a-zA-Z0-9_]*'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r_list(self):
        self._r__filler()
        self._o_ch('(')
        if self._state.failed:
            return
        self._s_list_1()
        v__2 = self._state.val
        self._r__filler()
        self._o_ch(')')
        if self._state.failed:
            return
        self._o_succeed(v__2, self._state.pos)

    def _s_list_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s_list_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s_list_2(self):
        state = self._state.copy()
        self._s_list_3()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r_list()

    def _s_list_3(self):
        self._r__filler()
        self._r_atom()

    def _r_opt_end(self):
        state = self._state.copy()
        v = self._externs['allow_trailing']
        if v is True:
            self._o_succeed(v, self._state.pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if not self._state.failed:
            return
        self._o_restore(state)
        self._s_opt_end_1()

    def _s_opt_end_1(self):
        self._r__filler()
        self._r_end()

    def _r__whitespace(self):
        rexp = '[ \t\n]+'
        pos = self.pos()
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            return
        self._o_fail()

    def _r__comment(self):
        self._o_ch(';')
        if self._state.failed:
            return
        self._s__comment_1()

    def _s__comment_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s__comment_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s__comment_2(self):
        state = self._state.copy()
        errpos = self._errpos
        self._o_ch('\n')
        if self._state.failed:
            self._o_succeed(None, state.pos)
        else:
            self._o_restore(state)
            self._errpos = errpos
            self._o_fail()
        if not self._state.failed:
            self._r_any()

    def _r__filler(self):
        start = self._state.pos
        self._s__filler_1()
        end = self._state.pos
        self._state.val = self._text[start:end]

    def _s__filler_1(self):
        vs = []
        while True:
            state = self._state.copy()
            self._s__filler_2()
            if self._state.failed or self._state.pos == state.pos:
                self._o_restore(state)
                break
            vs.append(self._state.val)
        self._o_succeed(vs, self._state.pos)

    def _s__filler_2(self):
        state = self._state.copy()
        self._r__whitespace()
        if not self._state.failed:
            return
        self._o_restore(state)
        self._r__comment()

    def _r_any(self):
        pos = self.pos()
        if pos < self._end:
            self._o_succeed(self._text[pos], pos + 1)
        else:
            self._o_fail()

    def _r_end(self):
        if self.pos() == self._end:
            self._o_succeed(None, self.pos())
        else:
            self._o_fail()

    def _o_ch(self, ch):
        pos = self.pos()
        if pos < self._end and self._text[pos] == ch:
            self._o_succeed(ch, pos + 1)
        else:
            self._o_fail()

    def _o_error(self):
        lineno, colno = self._o_offsets(self._errpos)
        if self._errpos == len(self._text):
            thing = 'end of input'
        else:
            thing = repr(self._text[self._errpos]).replace("'", '"')
        path = self._path
        return f'{path}:{lineno} Unexpected {thing} at column {colno}'

    def _o_fail(self):
        self._state.val = None
        self._state.failed = True
        self._errpos = max(self._errpos, self._state.pos)

    def _o_offsets(self, pos):
        lineno = 1
        colno = 1
        for i in range(pos):
            if self._text[i] == '\n':
                lineno += 1
                colno = 1
            else:
                colno += 1
        return lineno, colno

    def _o_restore(self, state):
        self._state = state.copy()

    def _o_str(self, s):
        for ch in s:
            self._o_ch(ch)
            if self._state.failed:
                return
        self._state.val = s

    def _o_succeed(self, v, newpos):
        self._state.val = v
        self._state.failed = False
        self._state.pos = newpos

    def _fn_atoi(self, s, base):
        return int(s, base)

    def _fn_join(self, sep, strs):
        return sep.join(strs)
