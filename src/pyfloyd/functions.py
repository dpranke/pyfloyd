# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Generated by pyfloyd version 0.25.0.dev0
#    https://github.com/dpranke/pyfloyd
#
#    `pyfloyd -o src/pyfloyd/functions.py -t -T \
#             src/pyfloyd/functions.py.dft src/pyfloyd/functions.df`
#

from typing import Any
import unicodedata

from pyfloyd import type_desc


class UserError(Exception):
    """An exception raised from inside the host language (in user code)."""


class HostError(Exception):
    """An exception raised by the host environment internally."""


def f_atob(s: str) -> bool:
    if s == 'true':
        return True
    if s == 'false':
        return False
    raise HostError(f'Illegal value `{s}` passed to `atob()`')


def f_atof(s: str) -> float:
    return float(s)


def f_atoi(s: str, base: int) -> float:
    return int(s, base)


def f_atou(s: str, base: int = 10) -> str:
    return chr(int(s, base))


def f_btoa(b: bool) -> str:
    return 'true' if b else 'false'


def f_car(lis: list[Any]) -> Any:
    return lis[0]


def f_cat(strs: list[str]) -> str:
    return ''.join(strs)


def f_cdr(lis: list[Any]) -> list[Any]:
    return lis[1:]


def f_concat(xs: list[Any], ys: list[Any]) -> list[Any]:
    return xs + ys


def f_cons(hd: Any, tl: list[Any]) -> list[Any]:
    return [hd] + tl


def f_dedent(s: str, colno: int = -1) -> str:
    # TODO: Figure out what to do with tabs and other non-space
    # whitespace.
    def _indent(s):
        i = 0
        while i < len(s) and s[i] == ' ':
            i += 1
        return i

    lines = s.splitlines()
    if len(lines) < 2:
        return s.strip()

    min_indent = min(_indent(line) for line in lines[1:] if line)
    if lines[0] and not lines[0].isspace():
        if colno == -1:
            raise ValueError(
                "Can't dedent text on the first line properly if "
                "we don't know the column number"
            )
        if colno == -2 or colno is None:
            # Act as if the first line is lined up with all the
            # other lines.
            r = lines[0].strip() + '\n'
        else:
            first_indent = colno - 1 + _indent(lines[0])
            min_indent = min(min_indent, first_indent)
            if min_indent < first_indent:
                offset = ' ' * (first_indent - min_indent)
                r = offset + lines[0].strip() + '\n'
            else:
                r = lines[0][_indent(lines[0]) :].rstrip() + '\n'
    else:
        r = ''
    for line in lines[1:-1]:
        r += line[min_indent:].rstrip() + '\n'
    if not lines[-1].isspace():
        r += lines[-1][min_indent:]
        if s.endswith('\n'):
            r += '\n'

    return r


def f_dict(pairs: list[Any]) -> dict[str, Any]:
    return dict(pairs)


def f_dict_is_empty(d: dict[str, Any]) -> bool:
    return len(d) == 0


def f_equal(x: Any, y: Any) -> bool:
    return x == y


def f_ftoa(f: float) -> str:
    return str(f)


def f_ftoi(f: float) -> int:
    return int(f)


def f_get(d: dict[str, Any], attr: Any) -> Any:
    return d[attr]


def f_has(d: dict[str, Any], key: str) -> bool:
    return key in d


def f_in(lis: list[Any], v: Any) -> bool:
    return v in lis


def f_is_atom(el: Any) -> bool:
    return isinstance(el, (bool, int, float, str)) or el is None


def f_is_bool(el: Any) -> bool:
    return isinstance(el, bool)


def f_is_dict(el: Any) -> bool:
    return isinstance(el, dict)


def f_is_empty(lis: list[Any]) -> bool:
    return len(lis) == 0


def f_is_float(el: Any) -> bool:
    return isinstance(el, float)


def f_is_int(el: Any) -> bool:
    return isinstance(el, int)


def f_is_list(el: Any) -> bool:
    return isinstance(el, list)


def f_is_number(el: Any) -> bool:
    return isinstance(el, (int, float))


def f_is_null(el: Any) -> bool:
    return el is None


def f_is_str(el: Any) -> bool:
    return isinstance(el, str)


def f_item(lis: list[Any], index: int) -> Any:
    return lis[index]


def f_itoa(i: int, base: int = 10) -> str:
    if base == 10:
        return f'{i:d}'
    if base == 16:
        return f'0x{i:x}'
    if base == 8:
        return f'0o{i:o}'
    if base == 2:
        return f'0b{i:b}'
    raise HostError(f'Unsupported base `{base}` passed to `itoa()`')


def f_itof(i: int) -> float:
    return float(i)


def f_itou(i: int) -> str:
    return chr(i)


def f_join(sep: str, strs: list[str]) -> str:
    return sep.join(strs)


def f_keys(d: dict[str, Any]) -> list[str]:
    return list(d.keys())


def f_len(lis: list[Any]) -> int:
    return len(lis)


def f_list(*args: Any) -> list[Any]:
    return list(args)


def f_otou(s: str) -> str:
    return chr(int(s, base=8))


def f_pairs(d: dict[str, Any]) -> list[Any]:
    return list(d.items())


def f_replace(s: str, old: str, new: str) -> str:
    return s.replace(old, new)


def f_scat(hd: str, tl: list[str]) -> str:
    return hd + ''.join(tl)


def f_scons(hd: str, tl: list[str]) -> list[str]:
    return [hd] + tl


def f_slice(vs: list[Any], start: int, end: int) -> list[Any]:
    return vs[start:] if end == 0 else vs[start:end]


def f_sort(strs: list[str]) -> list[str]:
    return sorted(strs)


def f_split(s: str, sep: str = '') -> list[str]:
    return s.split(sep)


def f_str2td(s: str) -> dict[str, Any]:
    return type_desc.str2d(s)


def f_strcat(*args: str) -> str:
    return ''.join(args)


def f_strin(s: str, sub: str) -> bool:
    return sub in s


def f_strlen(s: str) -> int:
    return len(s)


def f_substr(s: str, start: int, end: int) -> str:
    return s[start:] if end == 0 else s[start:end]


def f_td2str(d: dict[str, Any]) -> str:
    return type_desc.d2str(d)


def f_throw(msg: str) -> str:
    raise UserError(msg)


def f_ucategory(s: str) -> str:
    return unicodedata.category(s[0])


def f_ulookup(s: str) -> str:
    return unicodedata.lookup(s)


def f_uname(s: str) -> str:
    return unicodedata.name(s[0])


def f_utoi(u: str) -> int:
    return ord(u[0])


def f_values(d: dict[str, Any]) -> list[Any]:
    return list(d.values())


def f_xtoi(s: str) -> int:
    return int(s, base=16)


def f_xtou(s: str) -> str:
    return chr(int(s, base=16))


ALL: dict[str, dict[str, Any]] = {
    'atob': {
        'func': f_atob,
        'params': [['s', 'str']],
        'ret': 'bool',
    },
    'atof': {
        'func': f_atof,
        'params': [['s', 'str']],
        'ret': 'float',
    },
    'atoi': {
        'func': f_atoi,
        'params': [['s', 'str'], ['base', 'int']],
        'ret': 'float',
    },
    'atou': {
        'func': f_atou,
        'params': [['s', 'str'], ['base', 'int']],
        'ret': 'str',
    },
    'btoa': {
        'func': f_btoa,
        'params': [['b', 'bool']],
        'ret': 'str',
    },
    'car': {
        'func': f_car,
        'params': [['lis', 'list[any]']],
        'ret': 'any',
    },
    'cat': {
        'func': f_cat,
        'params': [['strs', 'list[str]']],
        'ret': 'str',
    },
    'cdr': {
        'func': f_cdr,
        'params': [['lis', 'list[any]']],
        'ret': 'list[any]',
    },
    'colno': {
        'func': None,
        'params': [],
        'ret': 'int',
    },
    'concat': {
        'func': f_concat,
        'params': [['xs', 'list[any]'], ['ys', 'list[any]']],
        'ret': 'list[any]',
    },
    'cons': {
        'func': f_cons,
        'params': [['hd', 'any'], ['tl', 'list[any]']],
        'ret': 'list[any]',
    },
    'dedent': {
        'func': f_dedent,
        'params': [['s', 'str'], ['colno', 'int']],
        'ret': 'str',
    },
    'dict': {
        'func': f_dict,
        'params': [['pairs', 'list[any]']],
        'ret': 'dict[str, any]',
    },
    'dict_is_empty': {
        'func': f_dict_is_empty,
        'params': [['d', 'dict[str, any]']],
        'ret': 'bool',
    },
    'equal': {
        'func': f_equal,
        'params': [['x', 'any'], ['y', 'any']],
        'ret': 'bool',
    },
    'ftoa': {
        'func': f_ftoa,
        'params': [['f', 'float']],
        'ret': 'str',
    },
    'ftoi': {
        'func': f_ftoi,
        'params': [['f', 'float']],
        'ret': 'int',
    },
    'get': {
        'func': f_get,
        'params': [['d', 'dict[str, any]'], ['attr', 'any']],
        'ret': 'any',
    },
    'has': {
        'func': f_has,
        'params': [['d', 'dict[str, any]'], ['key', 'str']],
        'ret': 'bool',
    },
    'in': {
        'func': f_in,
        'params': [['lis', 'list[any]'], ['v', 'any']],
        'ret': 'bool',
    },
    'is_atom': {
        'func': f_is_atom,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_bool': {
        'func': f_is_bool,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_dict': {
        'func': f_is_dict,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_empty': {
        'func': f_is_empty,
        'params': [['lis', 'list[any]']],
        'ret': 'bool',
    },
    'is_float': {
        'func': f_is_float,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_int': {
        'func': f_is_int,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_list': {
        'func': f_is_list,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_number': {
        'func': f_is_number,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_null': {
        'func': f_is_null,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'is_str': {
        'func': f_is_str,
        'params': [['el', 'any']],
        'ret': 'bool',
    },
    'item': {
        'func': f_item,
        'params': [['lis', 'list[any]'], ['index', 'int']],
        'ret': 'any',
    },
    'itoa': {
        'func': f_itoa,
        'params': [['i', 'int'], ['base', 'int']],
        'ret': 'str',
    },
    'itof': {
        'func': f_itof,
        'params': [['i', 'int']],
        'ret': 'float',
    },
    'itou': {
        'func': f_itou,
        'params': [['i', 'int']],
        'ret': 'str',
    },
    'join': {
        'func': f_join,
        'params': [['sep', 'str'], ['strs', 'list[str]']],
        'ret': 'str',
    },
    'keys': {
        'func': f_keys,
        'params': [['d', 'dict[str, any]']],
        'ret': 'list[str]',
    },
    'len': {
        'func': f_len,
        'params': [['lis', 'list[any]']],
        'ret': 'int',
    },
    'list': {
        'func': f_list,
        'params': [['*args', 'any']],
        'ret': 'list[any]',
    },
    'map': {
        'func': None,
        'params': [['fn', 'func[[any], any]'], ['lis', 'list[any]']],
        'ret': 'list[any]',
    },
    'map_items': {
        'func': None,
        'params': [['fn', 'func[[str, any], any]'], ['lis', 'list[any]']],
        'ret': 'list[any]',
    },
    'otou': {
        'func': f_otou,
        'params': [['s', 'str']],
        'ret': 'str',
    },
    'pairs': {
        'func': f_pairs,
        'params': [['d', 'dict[str, any]']],
        'ret': 'list[any]',
    },
    'replace': {
        'func': f_replace,
        'params': [['s', 'str'], ['old', 'str'], ['new', 'str']],
        'ret': 'str',
    },
    'scat': {
        'func': f_scat,
        'params': [['hd', 'str'], ['tl', 'list[str]']],
        'ret': 'str',
    },
    'scons': {
        'func': f_scons,
        'params': [['hd', 'str'], ['tl', 'list[str]']],
        'ret': 'list[str]',
    },
    'slice': {
        'func': f_slice,
        'params': [['vs', 'list[any]'], ['start', 'int'], ['end', 'int']],
        'ret': 'list[any]',
    },
    'sort': {
        'func': f_sort,
        'params': [['strs', 'list[str]']],
        'ret': 'list[str]',
    },
    'split': {
        'func': f_split,
        'params': [['s', 'str'], ['sep', 'str']],
        'ret': 'list[str]',
    },
    'str2td': {
        'func': f_str2td,
        'params': [['s', 'str']],
        'ret': 'dict[str, any]',
    },
    'strcat': {
        'func': f_strcat,
        'params': [['*args', 'str']],
        'ret': 'str',
    },
    'strin': {
        'func': f_strin,
        'params': [['s', 'str'], ['sub', 'str']],
        'ret': 'bool',
    },
    'strlen': {
        'func': f_strlen,
        'params': [['s', 'str']],
        'ret': 'int',
    },
    'substr': {
        'func': f_substr,
        'params': [['s', 'str'], ['start', 'int'], ['end', 'int']],
        'ret': 'str',
    },
    'td2str': {
        'func': f_td2str,
        'params': [['d', 'dict[str, any]']],
        'ret': 'str',
    },
    'throw': {
        'func': f_throw,
        'params': [['msg', 'str']],
        'ret': 'str',
    },
    'ucategory': {
        'func': f_ucategory,
        'params': [['s', 'str']],
        'ret': 'str',
    },
    'ulookup': {
        'func': f_ulookup,
        'params': [['s', 'str']],
        'ret': 'str',
    },
    'uname': {
        'func': f_uname,
        'params': [['s', 'str']],
        'ret': 'str',
    },
    'utoi': {
        'func': f_utoi,
        'params': [['u', 'str']],
        'ret': 'int',
    },
    'values': {
        'func': f_values,
        'params': [['d', 'dict[str, any]']],
        'ret': 'list[any]',
    },
    'xtoi': {
        'func': f_xtoi,
        'params': [['s', 'str']],
        'ret': 'int',
    },
    'xtou': {
        'func': f_xtou,
        'params': [['s', 'str']],
        'ret': 'str',
    },
}


UNDEFINED = (
    'colno',
    'map',
    'map_items',
)
