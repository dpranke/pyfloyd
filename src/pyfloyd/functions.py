# Copyright 2025 Dirk Pranke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Generated by pyfloyd version 0.22.0.dev0
#    https://github.com/dpranke/pyfloyd
#
#    `pyfloyd -o src/pyfloyd/functions.py -T src/pyfloyd/functions.py.dft src/pyfloyd/functions.df`

from typing import Any
import unicodedata


class UserError(Exception):
    """An exception raised from inside the host language (in user code)."""


class HostError(Exception):
    """An exception raised by the host environment internally."""


def f_atob(s: str) -> bool:
    if s == 'true':
        return True
    if s == 'false':
        return False
    raise HostError(f'Illegal value `{s}` passed to `atob()`')


def f_atof(s: str) -> float:
    return float(s)


def f_atoi(s: str, base: int) -> float:
    return int(s, base)


def f_atou(s: str, base: int = 10) -> str:
    return chr(int(s, base))


def f_btoa(b: bool) -> str:
    return 'true' if b else 'false'


def f_car(lis: list[Any]) -> Any:
    return lis[0]


def f_cat(strs: list[str]) -> str:
    return ''.join(strs)


def f_cdr(lis: list[Any]) -> list[Any]:
    return lis[1:]


def f_concat(xs: list[Any], ys: list[Any]) -> list[Any]:
    return xs + ys


def f_cons(hd: Any, tl: list[Any]) -> list[Any]:
    return [hd] + tl


def f_dedent(s: str, colno: int = -1) -> str:
    # TODO: Figure out what to do with tabs and other non-space
    # whitespace.
    def _indent(s):
        i = 0
        while i < len(s) and s[i] == ' ':
            i += 1
        return i

    lines = s.splitlines()
    if len(lines) < 2:
        return s.strip()

    min_indent = min(_indent(line) for line in lines[1:] if line)
    if lines[0] and not lines[0].isspace():
        if colno == -1:
            raise ValueError(
                "Can't dedent text on the first line properly if "
                "we don't know the column number"
            )
        if colno == -2 or colno is None:
            # Act as if the first line is lined up with all the
            # other lines.
            r = lines[0].strip() + '\n'
        else:
            first_indent = colno - 1 + _indent(lines[0])
            min_indent = min(min_indent, first_indent)
            if min_indent < first_indent:
                offset = ' ' * (first_indent - min_indent)
                r = offset + lines[0].strip() + '\n'
            else:
                r = lines[0][_indent(lines[0]) :].rstrip() + '\n'
    else:
        r = ''
    for line in lines[1:-1]:
        r += line[min_indent:].rstrip() + '\n'
    if not lines[-1].isspace():
        r += lines[-1][min_indent:]
        if s.endswith('\n'):
            r += '\n'

    return r


def f_dict(pairs: list[Any]) -> dict[str, Any]:
    return dict(pairs)


def f_dict_is_empty(d: dict[str, Any]) -> bool:
    return len(d) == 0


def f_equal(x: Any, y: Any) -> bool:
    return x == y


def f_ftoi(f: float) -> int:
    return int(f)


def f_get(d: dict[Any, Any], attr: Any) -> Any:
    return d[attr]


def f_has(d: dict[str, Any], key: str) -> bool:
    return key in d


def f_is_atom(el: Any) -> bool:
    return isinstance(el, (bool, int, float, str)) or el is None


def f_is_bool(el: Any) -> bool:
    return isinstance(el, bool)


def f_is_dict(el: Any) -> bool:
    return isinstance(el, dict)


def f_is_empty(lis: list[Any]) -> bool:
    return len(lis) == 0


def f_is_float(el: Any) -> bool:
    return isinstance(el, float)


def f_is_int(el: Any) -> bool:
    return isinstance(el, int)


def f_is_list(el: Any) -> bool:
    return isinstance(el, list)


def f_is_number(el: Any) -> bool:
    return isinstance(el, (int, float))


def f_is_null(el: Any) -> bool:
    return el is None


def f_is_str(el: Any) -> bool:
    return isinstance(el, str)


def f_item(lis: list[Any], index: int) -> Any:
    return lis[index]


def f_itoa(i: int, base: int = 10) -> str:
    if base == 10:
        return f'{i:d}'
    if base == 16:
        return f'0x{i:x}'
    if base == 8:
        return f'0o{i:o}'
    if base == 2:
        return f'0b{i:b}'
    raise HostError(f'Unsupported base `{base}` passed to `itoa()`')


def f_itof(i: int) -> float:
    return float(i)


def f_itou(i: int) -> str:
    return chr(i)


def f_join(sep: str, strs: list[str]) -> str:
    return sep.join(strs)


def f_keys(d: dict[str, Any]) -> list[str]:
    return list(d.keys())


def f_len(lis: list[Any]) -> int:
    return len(lis)


def f_list(*args: Any) -> list[Any]:
    return list(args)


def f_otou(s: str) -> str:
    return chr(int(s, base=8))


def f_pairs(d: dict[str, Any]) -> list[Any]:
    return list(d.items())


def f_replace(s: str, old: str, new: str) -> str:
    return s.replace(old, new)


def f_scat(hd: str, tl: list[str]) -> str:
    return hd + ''.join(tl)


def f_scons(hd: str, tl: list[str]) -> list[str]:
    return [hd] + tl


def f_slice(vs: list[Any], start: int, end: int) -> list[Any]:
    return vs[start:] if end == 0 else vs[start:end]


def f_sort(strs: list[str]) -> list[str]:
    return sorted(strs)


def f_split(s: str, sep: str = '') -> list[str]:
    return s.split(sep)


def f_strcat(*args: str) -> str:
    return ''.join(args)


def f_strlen(s: str) -> int:
    return len(s)


def f_substr(s: str, start: int, end: int) -> str:
    return s[start:] if end == 0 else s[start:end]


def f_throw(msg: str) -> str:
    raise UserError(msg)


def f_ucategory(s: str) -> str:
    return unicodedata.category(s[0])


def f_ulookup(s: str) -> str:
    return unicodedata.lookup(s)


def f_uname(s: str) -> str:
    return unicodedata.name(s[0])


def f_utoi(u: str) -> int:
    return ord(u[0])


def f_values(d: dict[str, Any]) -> list[Any]:
    return list(d.values())


def f_xtoi(s: str) -> int:
    return int(s, base=16)


def f_xtou(s: str) -> str:
    return chr(int(s, base=16))


ALL = {
    'atob': f_atob,
    'atof': f_atof,
    'atoi': f_atoi,
    'atou': f_atou,
    'btoa': f_btoa,
    'car': f_car,
    'cat': f_cat,
    'cdr': f_cdr,
    'colno': None,
    'concat': f_concat,
    'cons': f_cons,
    'dedent': f_dedent,
    'dict': f_dict,
    'dict_is_empty': f_dict_is_empty,
    'equal': f_equal,
    'ftoi': f_ftoi,
    'get': f_get,
    'has': f_has,
    'is_atom': f_is_atom,
    'is_bool': f_is_bool,
    'is_dict': f_is_dict,
    'is_empty': f_is_empty,
    'is_float': f_is_float,
    'is_int': f_is_int,
    'is_list': f_is_list,
    'is_number': f_is_number,
    'is_null': f_is_null,
    'is_str': f_is_str,
    'item': f_item,
    'itoa': f_itoa,
    'itof': f_itof,
    'itou': f_itou,
    'join': f_join,
    'keys': f_keys,
    'len': f_len,
    'list': f_list,
    'map': None,
    'map_items': None,
    'otou': f_otou,
    'pairs': f_pairs,
    'replace': f_replace,
    'scat': f_scat,
    'scons': f_scons,
    'slice': f_slice,
    'sort': f_sort,
    'split': f_split,
    'strcat': f_strcat,
    'strlen': f_strlen,
    'substr': f_substr,
    'throw': f_throw,
    'ucategory': f_ucategory,
    'ulookup': f_ulookup,
    'uname': f_uname,
    'utoi': f_utoi,
    'values': f_values,
    'xtoi': f_xtoi,
    'xtou': f_xtou,
}


UNDEFINED = (
    'colno',
    'map',
    'map_items',
)
