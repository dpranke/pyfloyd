# Generated by pyfloyd version 0.28.0.dev0
#    https://github.com/dpranke/pyfloyd
#
#    `flc -o ./json5_cst.py --tokenize ./json5.g`
#

import re
from typing import Any, Dict, NamedTuple, Optional
import unicodedata

Externs = Optional[Dict[str, Any]]

# pylint: disable=too-many-lines


class _ParsingRuntimeError(Exception):
    pass


class Result(NamedTuple):
    """The result returned from a `parse()` call.

    If the parse is successful, `val` will contain the returned value, if
    any and `pos` will indicate the point in the text where the parser
    stopped.  If the parse is unsuccessful, `err` will contain a string
    describing any errors that occurred during the parse and `pos` will
    indicate the location of the farthest error in the text.
    """

    val: Any = None
    err: Optional[str] = None
    pos: Optional[int] = None


def parse(
    text: str, path: str = '<string>', externs: Externs = None, start: int = 0
) -> Result:
    """Parse a given text and return the result.

    If the parse was successful, `result.val` will be the returned value
    from the parse, and `result.pos` will indicate where the parser
    stopped when it was done parsing.

    If the parse is unsuccessful, `result.err` will be a string describing
    any errors found in the text, and `result.pos` will indicate the
    furthest point reached during the parse.

    If the optional `path` is provided it will be used in any error
    messages to indicate the path to the filename containing the given
    text.
    """
    return _Parser(text, path).parse(externs, start)


class _Parser:
    def __init__(self, text, path):
        self._text = text
        self._end = len(self._text)
        self._errpos = 0
        self._failed = False
        self._path = path
        self._pos = 0
        self._val = None
        self._externs = {
            'strict': True,
            'node': self._fn_node,
            'dict': self._fn_dict,
        }
        self._regexps = {}
        self._nodes = []
        self._tokens = []
        self._in_token = False

    def parse(self, externs: Externs = None, start: int = 0):
        self._pos = start

        errors = ''
        if externs:
            for k, v in externs.items():
                if k in self._externs:
                    self._externs[k] = v
                else:
                    errors += f'Unexpected extern "{k}"\n'
        for k, v in self._externs.items():
            if v is None:
                errors += f'Missing required extern "{k}"'
        if errors:
            return Result(None, errors, 0)

        try:
            self._r_grammar()

            if self._failed:
                return Result(None, self._o_error(), self._errpos)
            return Result(self._val, None, self._pos)
        except _ParsingRuntimeError as e:  # pragma: no cover
            lineno, _ = self._o_offsets(self._errpos)
            return Result(
                None,
                self._path + ':' + str(lineno) + ' ' + str(e),
                self._errpos,
            )

    def _r_grammar(self):
        self._nodes.append((self._pos, 'grammar'))
        self._s_grammar_1()
        self._nodes.pop()

    def _s_grammar_1(self):
        self._r_value()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._r__filler()
        self._r_end()
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__1), self._pos)

    def _r_value(self):
        self._nodes.append((self._pos, 'value'))
        self._s_value_1()
        self._nodes.pop()

    def _s_value_1(self):
        pos = self._pos
        self._s_value_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_value_3()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_value_4()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_object()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_array()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_value_5()

    def _s_value_2(self):
        self._r__filler()
        self._r_null()

    def _s_value_3(self):
        self._r__filler()
        self._r_bool()

    def _s_value_4(self):
        self._r__filler()
        self._r_num_literal()

    def _s_value_5(self):
        self._r__filler()
        self._r_string()

    def _r_null(self):
        self._nodes.append((self._pos, 'null'))
        self._in_token = True
        self._s_null_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s_null_1(self):
        self._o_str('null')
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, None), self._pos)

    def _r_bool(self):
        self._nodes.append((self._pos, 'bool'))
        self._in_token = True
        self._s_bool_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s_bool_1(self):
        pos = self._pos
        self._s_bool_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_bool_3()

    def _s_bool_2(self):
        self._o_str('true')
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, True), self._pos)

    def _s_bool_3(self):
        self._o_str('false')
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, False), self._pos)

    def _r_object(self):
        self._nodes.append((self._pos, 'object'))
        self._s_object_1()
        self._nodes.pop()

    def _s_object_1(self):
        pos = self._pos
        self._s_object_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_object_5()

    def _s_object_2(self):
        self._s_object_3()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._r_member_list()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._s_object_4()
        if self._failed:
            return
        v__3 = self._val
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](
                self, self._externs['dict'](v__2), v__1, v__3
            ),
            self._pos,
        )

    def _s_object_3(self):
        self._r__filler()
        self._o_ch('{')

    def _s_object_4(self):
        self._r__filler()
        self._o_ch('}')

    def _s_object_5(self):
        self._s_object_6()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._s_object_7()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](
                self, self._externs['dict']([]), v__1, v__2
            ),
            self._pos,
        )

    def _s_object_6(self):
        self._r__filler()
        self._o_ch('{')

    def _s_object_7(self):
        self._r__filler()
        self._o_ch('}')

    def _r_array(self):
        self._nodes.append((self._pos, 'array'))
        self._s_array_1()
        self._nodes.pop()

    def _s_array_1(self):
        pos = self._pos
        self._s_array_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_array_5()

    def _s_array_2(self):
        self._s_array_3()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._r_element_list()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._s_array_4()
        if self._failed:
            return
        v__3 = self._val
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](self, v__2, v__1, v__3), self._pos
        )

    def _s_array_3(self):
        self._r__filler()
        self._o_ch('[')

    def _s_array_4(self):
        self._r__filler()
        self._o_ch(']')

    def _s_array_5(self):
        self._s_array_6()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._s_array_7()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, [], v__1, v__2), self._pos)

    def _s_array_6(self):
        self._r__filler()
        self._o_ch('[')

    def _s_array_7(self):
        self._r__filler()
        self._o_ch(']')

    def _r_string(self):
        self._nodes.append((self._pos, 'string'))
        self._in_token = True
        self._s_string_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s_string_1(self):
        pos = self._pos
        self._s_string_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_string_4()

    def _s_string_2(self):
        self._r_squote()
        if self._failed:
            return
        self._s_string_3()
        v__2 = self._val
        self._r_squote()
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](self, self._fn_cat(v__2)), self._pos
        )

    def _s_string_3(self):
        vs = []
        while True:
            pos = self._pos
            self._r_sqchar()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s_string_4(self):
        self._r_dquote()
        if self._failed:
            return
        self._s_string_5()
        v__2 = self._val
        self._r_dquote()
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](self, self._fn_cat(v__2)), self._pos
        )

    def _s_string_5(self):
        vs = []
        while True:
            pos = self._pos
            self._r_dqchar()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r_sqchar(self):
        self._nodes.append((self._pos, 'sqchar'))
        self._s_sqchar_1()
        self._nodes.pop()

    def _s_sqchar_1(self):
        pos = self._pos
        self._s_sqchar_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_sqchar_3()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_sqchar_4()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_sqchar_8()

    def _s_sqchar_2(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_esc_char()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(v__2, self._pos)

    def _s_sqchar_3(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_eol()
        if self._failed:
            return
        self._o_succeed('', self._pos)

    def _s_sqchar_4(self):
        self._s_sqchar_5()
        if self._failed:
            return
        self._s_sqchar_6()
        if self._failed:
            return
        self._s_sqchar_7()
        if self._failed:
            return
        self._r_any()
        if self._failed:
            return
        v__4 = self._val
        if self._failed:
            return
        self._o_succeed(v__4, self._pos)

    def _s_sqchar_5(self):
        pos = self._pos
        errpos = self._errpos
        self._r_bslash()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_sqchar_6(self):
        pos = self._pos
        errpos = self._errpos
        self._r_squote()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_sqchar_7(self):
        pos = self._pos
        errpos = self._errpos
        self._r_eol()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_sqchar_8(self):
        v = not self._externs['strict']
        if v is True:
            self._o_succeed(v, self._pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if self._failed:
            return
        self._o_range('\x00', '\x1f')

    def _r_dqchar(self):
        self._nodes.append((self._pos, 'dqchar'))
        self._s_dqchar_1()
        self._nodes.pop()

    def _s_dqchar_1(self):
        pos = self._pos
        self._s_dqchar_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_dqchar_3()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_dqchar_4()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_dqchar_8()

    def _s_dqchar_2(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_esc_char()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(v__2, self._pos)

    def _s_dqchar_3(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_eol()
        if self._failed:
            return
        self._o_succeed('', self._pos)

    def _s_dqchar_4(self):
        self._s_dqchar_5()
        if self._failed:
            return
        self._s_dqchar_6()
        if self._failed:
            return
        self._s_dqchar_7()
        if self._failed:
            return
        self._r_any()
        if self._failed:
            return
        v__4 = self._val
        if self._failed:
            return
        self._o_succeed(v__4, self._pos)

    def _s_dqchar_5(self):
        pos = self._pos
        errpos = self._errpos
        self._r_bslash()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_dqchar_6(self):
        pos = self._pos
        errpos = self._errpos
        self._r_dquote()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_dqchar_7(self):
        pos = self._pos
        errpos = self._errpos
        self._r_eol()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_dqchar_8(self):
        v = not self._externs['strict']
        if v is True:
            self._o_succeed(v, self._pos)
        elif v is False:
            self._o_fail()
        else:
            raise _ParsingRuntimeError('Bad predicate value')
        if self._failed:
            return
        self._o_range('\x00', '\x1f')

    def _r_bslash(self):
        self._nodes.append((self._pos, 'bslash'))
        self._o_ch('\\')
        self._nodes.pop()

    def _r_squote(self):
        self._nodes.append((self._pos, 'squote'))
        self._o_ch("'")
        self._nodes.pop()

    def _r_dquote(self):
        self._nodes.append((self._pos, 'dquote'))
        self._o_ch('"')
        self._nodes.pop()

    def _r_eol(self):
        self._nodes.append((self._pos, 'eol'))
        self._s_eol_1()
        self._nodes.pop()

    def _s_eol_1(self):
        pos = self._pos
        self._s_eol_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\r')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\n')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u2028')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u2029')

    def _s_eol_2(self):
        self._o_ch('\r')
        if self._failed:
            return
        self._o_ch('\n')

    def _r_esc_char(self):
        self._nodes.append((self._pos, 'esc_char'))
        self._s_esc_char_1()
        self._nodes.pop()

    def _s_esc_char_1(self):
        pos = self._pos
        self._s_esc_char_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_3()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_4()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_5()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_6()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_7()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_8()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_9()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_10()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_11()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_esc_char_14()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_hex_esc()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_unicode_esc()

    def _s_esc_char_2(self):
        self._o_ch('b')
        if self._failed:
            return
        self._o_succeed('\b', self._pos)

    def _s_esc_char_3(self):
        self._o_ch('f')
        if self._failed:
            return
        self._o_succeed('\f', self._pos)

    def _s_esc_char_4(self):
        self._o_ch('n')
        if self._failed:
            return
        self._o_succeed('\n', self._pos)

    def _s_esc_char_5(self):
        self._o_ch('r')
        if self._failed:
            return
        self._o_succeed('\r', self._pos)

    def _s_esc_char_6(self):
        self._o_ch('t')
        if self._failed:
            return
        self._o_succeed('\t', self._pos)

    def _s_esc_char_7(self):
        self._o_ch('v')
        if self._failed:
            return
        self._o_succeed('\v', self._pos)

    def _s_esc_char_8(self):
        self._r_squote()
        if self._failed:
            return
        self._o_succeed("'", self._pos)

    def _s_esc_char_9(self):
        self._r_dquote()
        if self._failed:
            return
        self._o_succeed('"', self._pos)

    def _s_esc_char_10(self):
        self._r_bslash()
        if self._failed:
            return
        self._o_succeed('\\', self._pos)

    def _s_esc_char_11(self):
        self._s_esc_char_12()
        if self._failed:
            return
        self._r_any()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(v__2, self._pos)

    def _s_esc_char_12(self):
        pos = self._pos
        errpos = self._errpos
        self._s_esc_char_13()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_esc_char_13(self):
        pos = self._pos
        self._o_ch('x')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('u')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_digit()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_eol()

    def _s_esc_char_14(self):
        self._o_ch('0')
        if self._failed:
            return
        self._s_esc_char_15()
        if self._failed:
            return
        self._o_succeed('\x00', self._pos)

    def _s_esc_char_15(self):
        pos = self._pos
        errpos = self._errpos
        self._r_digit()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _r_hex_esc(self):
        self._nodes.append((self._pos, 'hex_esc'))
        self._s_hex_esc_1()
        self._nodes.pop()

    def _s_hex_esc_1(self):
        self._o_ch('x')
        if self._failed:
            return
        self._s_hex_esc_2()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._fn_xtou(self._fn_cat(v__2)), self._pos)

    def _s_hex_esc_2(self):
        vs = []
        i = 0
        cmin = 2
        cmax = 2
        while i < cmax:
            self._r_hex()
            if self._failed:
                if i >= cmin:
                    self._o_succeed(vs, self._pos)
                return
            vs.append(self._val)
            i += 1
        self._o_succeed(vs, self._pos)

    def _r_unicode_esc(self):
        self._nodes.append((self._pos, 'unicode_esc'))
        self._s_unicode_esc_1()
        self._nodes.pop()

    def _s_unicode_esc_1(self):
        self._o_ch('u')
        if self._failed:
            return
        self._s_unicode_esc_2()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._fn_xtou(self._fn_cat(v__2)), self._pos)

    def _s_unicode_esc_2(self):
        vs = []
        i = 0
        cmin = 4
        cmax = 4
        while i < cmax:
            self._r_hex()
            if self._failed:
                if i >= cmin:
                    self._o_succeed(vs, self._pos)
                return
            vs.append(self._val)
            i += 1
        self._o_succeed(vs, self._pos)

    def _r_element_list(self):
        self._nodes.append((self._pos, 'element_list'))
        self._s_element_list_1()
        self._nodes.pop()

    def _s_element_list_1(self):
        self._r_value()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._s_element_list_2()
        v__2 = self._val
        self._s_element_list_4()
        self._o_succeed(self._fn_cons(v__1, v__2), self._pos)

    def _s_element_list_2(self):
        vs = []
        while True:
            pos = self._pos
            self._s_element_list_3()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s_element_list_3(self):
        self._r__filler()
        self._o_ch(',')
        if self._failed:
            return
        self._r_value()

    def _s_element_list_4(self):
        pos = self._pos
        self._s_element_list_5()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _s_element_list_5(self):
        self._r__filler()
        self._o_ch(',')

    def _r_member_list(self):
        self._nodes.append((self._pos, 'member_list'))
        self._s_member_list_1()
        self._nodes.pop()

    def _s_member_list_1(self):
        self._r_member()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._s_member_list_2()
        v__2 = self._val
        self._s_member_list_4()
        self._o_succeed(self._fn_cons(v__1, v__2), self._pos)

    def _s_member_list_2(self):
        vs = []
        while True:
            pos = self._pos
            self._s_member_list_3()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s_member_list_3(self):
        self._r__filler()
        self._o_ch(',')
        if self._failed:
            return
        self._r_member()

    def _s_member_list_4(self):
        pos = self._pos
        self._s_member_list_5()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _s_member_list_5(self):
        self._r__filler()
        self._o_ch(',')

    def _r_member(self):
        self._nodes.append((self._pos, 'member'))
        self._s_member_1()
        self._nodes.pop()

    def _s_member_1(self):
        pos = self._pos
        self._s_member_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_member_4()

    def _s_member_2(self):
        self._s_member_3()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._r__filler()
        self._o_ch(':')
        if self._failed:
            return
        self._r_value()
        if self._failed:
            return
        v__3 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, [v__1, v__3]), self._pos)

    def _s_member_3(self):
        self._r__filler()
        self._r_string()

    def _s_member_4(self):
        self._s_member_5()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._r__filler()
        self._o_ch(':')
        if self._failed:
            return
        self._r_value()
        if self._failed:
            return
        v__3 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, [v__1, v__3]), self._pos)

    def _s_member_5(self):
        self._r__filler()
        self._r_ident()

    def _r_ident(self):
        self._nodes.append((self._pos, 'ident'))
        self._in_token = True
        self._s_ident_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s_ident_1(self):
        self._s_ident_2()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__1), self._pos)

    def _s_ident_2(self):
        start = self._pos
        self._s_ident_3()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s_ident_3(self):
        self._r_id_start()
        if self._failed:
            return
        self._s_ident_4()

    def _s_ident_4(self):
        vs = []
        while True:
            pos = self._pos
            self._r_id_continue()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r_id_start(self):
        self._nodes.append((self._pos, 'id_start'))
        self._s_id_start_1()
        self._nodes.pop()

    def _s_id_start_1(self):
        pos = self._pos
        self._r_ascii_id_start()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_other_id_start()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_id_start_2()

    def _s_id_start_2(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_unicode_esc()

    def _r_ascii_id_start(self):
        self._nodes.append((self._pos, 'ascii_id_start'))
        self._s_ascii_id_start_1()
        self._nodes.pop()

    def _s_ascii_id_start_1(self):
        pos = self._pos
        self._o_range('a', 'z')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_range('A', 'Z')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('$')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('_')

    def _r_other_id_start(self):
        self._nodes.append((self._pos, 'other_id_start'))
        self._s_other_id_start_1()
        self._nodes.pop()

    def _s_other_id_start_1(self):
        pos = self._pos
        self._o_unicat('Ll')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Lm')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Lo')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Lt')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Lu')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Nl')

    def _r_id_continue(self):
        self._nodes.append((self._pos, 'id_continue'))
        self._s_id_continue_1()
        self._nodes.pop()

    def _s_id_continue_1(self):
        pos = self._pos
        self._r_ascii_id_start()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_digit()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_other_id_start()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Mn')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Mc')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Nd')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Pc')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_id_continue_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u200c')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u200d')

    def _s_id_continue_2(self):
        self._r_bslash()
        if self._failed:
            return
        self._r_unicode_esc()

    def _r_num_literal(self):
        self._nodes.append((self._pos, 'num_literal'))
        self._in_token = True
        self._s_num_literal_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s_num_literal_1(self):
        pos = self._pos
        self._s_num_literal_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_num_literal_3()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_num_literal_4()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_num_literal_6()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_num_literal_7()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_num_literal_8()

    def _s_num_literal_2(self):
        self._o_ch('-')
        if self._failed:
            return
        self._r_num_literal()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, 0 - v__2), self._pos)

    def _s_num_literal_3(self):
        self._o_ch('+')
        if self._failed:
            return
        self._r_num_literal()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__2), self._pos)

    def _s_num_literal_4(self):
        self._r_dec_literal()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._s_num_literal_5()
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](self, self._fn_atof(v__1)), self._pos
        )

    def _s_num_literal_5(self):
        pos = self._pos
        errpos = self._errpos
        self._r_id_start()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_num_literal_6(self):
        self._r_hex_literal()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._o_succeed(
            self._externs['node'](self, self._fn_atoi(v__1, 16)), self._pos
        )

    def _s_num_literal_7(self):
        self._o_str('Infinity')
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, 'Infinity'), self._pos)

    def _s_num_literal_8(self):
        self._o_str('NaN')
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, 'NaN'), self._pos)

    def _r_dec_literal(self):
        self._nodes.append((self._pos, 'dec_literal'))
        self._s_dec_literal_1()
        self._nodes.pop()

    def _s_dec_literal_1(self):
        pos = self._pos
        self._s_dec_literal_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_dec_literal_6()

    def _s_dec_literal_2(self):
        start = self._pos
        self._s_dec_literal_3()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s_dec_literal_3(self):
        self._r_dec_int_lit()
        if self._failed:
            return
        self._s_dec_literal_4()
        self._s_dec_literal_5()

    def _s_dec_literal_4(self):
        pos = self._pos
        self._r_frac()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _s_dec_literal_5(self):
        pos = self._pos
        self._r_exp()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _s_dec_literal_6(self):
        start = self._pos
        self._s_dec_literal_7()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s_dec_literal_7(self):
        self._r_frac()
        if self._failed:
            return
        self._s_dec_literal_8()

    def _s_dec_literal_8(self):
        pos = self._pos
        self._r_exp()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _r_dec_int_lit(self):
        self._nodes.append((self._pos, 'dec_int_lit'))
        self._s_dec_int_lit_1()
        self._nodes.pop()

    def _s_dec_int_lit_1(self):
        pos = self._pos
        self._s_dec_int_lit_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s_dec_int_lit_4()

    def _s_dec_int_lit_2(self):
        self._o_ch('0')
        if self._failed:
            return
        self._s_dec_int_lit_3()

    def _s_dec_int_lit_3(self):
        pos = self._pos
        errpos = self._errpos
        self._r_digit()
        if self._failed:
            self._o_succeed(None, pos)
        else:
            self._o_rewind(pos)
            self._errpos = errpos
            self._o_fail()

    def _s_dec_int_lit_4(self):
        self._r_nonzerodigit()
        if self._failed:
            return
        self._s_dec_int_lit_5()

    def _s_dec_int_lit_5(self):
        vs = []
        while True:
            pos = self._pos
            self._r_digit()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r_digit(self):
        self._nodes.append((self._pos, 'digit'))
        self._o_range('0', '9')
        self._nodes.pop()

    def _r_nonzerodigit(self):
        self._nodes.append((self._pos, 'nonzerodigit'))
        self._o_range('1', '9')
        self._nodes.pop()

    def _r_hex_literal(self):
        self._nodes.append((self._pos, 'hex_literal'))
        self._s_hex_literal_1()
        self._nodes.pop()

    def _s_hex_literal_1(self):
        self._s_hex_literal_2()
        if self._failed:
            return
        self._s_hex_literal_3()
        if self._failed:
            return
        v__2 = self._val
        if self._failed:
            return
        self._o_succeed(self._fn_strcat('0x', self._fn_cat(v__2)), self._pos)

    def _s_hex_literal_2(self):
        pos = self._pos
        self._o_str('0x')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_str('0X')

    def _s_hex_literal_3(self):
        vs = []
        self._r_hex()
        if self._failed:
            return
        vs.append(self._val)
        while True:
            pos = self._pos
            self._r_hex()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r_hex(self):
        self._nodes.append((self._pos, 'hex'))
        self._s_hex_1()
        self._nodes.pop()

    def _s_hex_1(self):
        pos = self._pos
        self._o_range('a', 'f')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_range('A', 'F')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r_digit()

    def _r_frac(self):
        self._nodes.append((self._pos, 'frac'))
        self._s_frac_1()
        self._nodes.pop()

    def _s_frac_1(self):
        self._o_ch('.')
        if self._failed:
            return
        self._s_frac_2()

    def _s_frac_2(self):
        vs = []
        self._r_digit()
        if self._failed:
            return
        vs.append(self._val)
        while True:
            pos = self._pos
            self._r_digit()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r_exp(self):
        self._nodes.append((self._pos, 'exp'))
        self._s_exp_1()
        self._nodes.pop()

    def _s_exp_1(self):
        self._s_exp_2()
        if self._failed:
            return
        self._s_exp_3()
        self._s_exp_5()

    def _s_exp_2(self):
        pos = self._pos
        self._o_ch('e')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('E')

    def _s_exp_3(self):
        pos = self._pos
        self._s_exp_4()
        if self._failed:
            self._o_succeed([], pos)
        else:
            self._o_succeed([self._val], self._pos)

    def _s_exp_4(self):
        pos = self._pos
        self._o_ch('+')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('-')

    def _s_exp_5(self):
        vs = []
        self._r_digit()
        if self._failed:
            return
        vs.append(self._val)
        while True:
            pos = self._pos
            self._r_digit()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _r__whitespace(self):
        self._nodes.append((self._pos, '%whitespace'))
        self._in_token = True
        self._s__whitespace_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s__whitespace_1(self):
        self._s__whitespace_2()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__1), self._pos)

    def _s__whitespace_2(self):
        start = self._pos
        self._s__whitespace_3()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s__whitespace_3(self):
        vs = []
        self._s__whitespace_4()
        if self._failed:
            return
        vs.append(self._val)
        while True:
            pos = self._pos
            self._s__whitespace_4()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s__whitespace_4(self):
        pos = self._pos
        self._o_ch(' ')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\t')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\n')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\r')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\v')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\f')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\xa0')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u2028')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\u2029')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_ch('\ufeff')
        if not self._failed:
            return
        self._o_rewind(pos)
        self._o_unicat('Zs')

    def _r__comment(self):
        self._nodes.append((self._pos, '%comment'))
        self._in_token = True
        self._s__comment_1()
        self._o_tok(self._nodes[-1][0], self._nodes[-1][1], True)
        self._nodes.pop()

    def _s__comment_1(self):
        pos = self._pos
        self._s__comment_2()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._s__comment_7()

    def _s__comment_2(self):
        self._s__comment_3()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__1), self._pos)

    def _s__comment_3(self):
        start = self._pos
        self._s__comment_4()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s__comment_4(self):
        self._o_str('//')
        if self._failed:
            return
        self._s__comment_5()

    def _s__comment_5(self):
        vs = []
        while True:
            pos = self._pos
            self._s__comment_6()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s__comment_6(self):
        rexp = '[^\r\n]'
        pos = self._pos
        if rexp not in self._regexps:
            self._regexps[rexp] = re.compile(rexp)
        m = self._regexps[rexp].match(self._text, self._pos)
        if m:
            self._o_succeed(m.group(0), m.end())
            self._o_tok(pos, 'set', False)
            return
        self._o_fail()

    def _s__comment_7(self):
        self._s__comment_8()
        if self._failed:
            return
        v__1 = self._val
        if self._failed:
            return
        self._o_succeed(self._externs['node'](self, v__1), self._pos)

    def _s__comment_8(self):
        start = self._pos
        self._s__comment_9()
        if self._failed:
            return
        end = self._pos
        self._val = self._text[start:end]

    def _s__comment_9(self):
        self._o_str('/*')
        if self._failed:
            return
        while True:
            self._o_str('*/')
            if not self._failed:
                break
            self._r_any()
            if self._failed:
                break

    def _r__filler(self):
        start = self._pos
        self._s__filler_1()
        end = self._pos
        self._val = self._text[start:end]

    def _s__filler_1(self):
        vs = []
        while True:
            pos = self._pos
            self._s__filler_2()
            if self._failed or self._pos == pos:
                self._o_rewind(pos)
                break
            vs.append(self._val)
        self._o_succeed(vs, self._pos)

    def _s__filler_2(self):
        pos = self._pos
        self._r__whitespace()
        if not self._failed:
            return
        self._o_rewind(pos)
        self._r__comment()

    def _r_any(self):
        if self._pos < self._end:
            self._o_succeed(self._text[self._pos], self._pos + 1)
            self._o_tok(self._pos - 1, 'any', False)
        else:
            self._o_fail()

    def _r_end(self):
        if self._pos == self._end:
            self._o_succeed(None, self._pos)
        else:
            self._o_fail()

    def _o_ch(self, ch):
        pos = self._pos
        if pos < self._end and self._text[pos] == ch:
            self._o_succeed(ch, self._pos + 1)
            self._o_tok(pos, 'lit', False)
        else:
            self._o_fail()

    def _o_error(self):
        lineno, colno = self._o_offsets(self._errpos)
        if self._errpos == len(self._text):
            thing = 'end of input'
        else:
            thing = repr(self._text[self._errpos]).replace("'", '"')
        path = self._path
        return f'{path}:{lineno} Unexpected {thing} at column {colno}'

    def _o_fail(self):
        self._val = None
        self._failed = True
        self._errpos = max(self._errpos, self._pos)

    def _o_offsets(self, pos):
        lineno = 1
        colno = 1
        for i in range(pos):
            if self._text[i] == '\n':
                lineno += 1
                colno = 1
            else:
                colno += 1
        return lineno, colno

    def _o_range(self, i, j):
        pos = self._pos
        if pos != self._end and ord(i) <= ord(self._text[pos]) <= ord(j):
            self._o_succeed(self._text[pos], self._pos + 1)
        else:
            self._o_fail()

    def _o_rewind(self, newpos):
        self._o_succeed(None, newpos)
        while self._tokens and self._tokens[-1][0] > newpos:
            self._tokens.pop()

    def _o_str(self, s):
        in_token = self._in_token
        self._in_token = True
        pos = self._pos
        for ch in s:
            self._o_ch(ch)
            if self._failed:
                return
        self._val = s
        self._in_token = in_token
        self._o_tok(pos, 'lit', False)

    def _o_succeed(self, v, newpos):
        self._val = v
        self._failed = False
        self._pos = newpos

    def _o_tok(self, pos, tag, in_token):
        if not in_token and self._in_token:
            return
        if not self._failed and self._pos > pos:
            val = (pos, tag, self._text[pos:self._pos])
            if self._tokens and self._tokens[-1][0] == pos:
                assert self._tokens[-1] == val
            else:
                self._tokens.append((pos, tag, self._text[pos:self._pos]))
        if in_token:
            self._in_token = False

    def _o_unicat(self, cat):
        pos = self._pos
        if pos < self._end and unicodedata.category(self._text[pos]) == cat:
            self._o_succeed(self._text[pos], self._pos + 1)
        else:
            self._o_fail()

    def _fn_atof(self, s):
        return float(s)

    def _fn_atoi(self, s, base):
        return int(s, base)

    def _fn_cat(self, strs):
        return ''.join(strs)

    def _fn_cons(self, hd, tl):
        return [hd] + tl

    def _fn_dict(self, pairs):
        return dict(pairs)

    def _fn_node(self, parser, *args):
        del parser
        return args[0]

    def _fn_strcat(self, *args):
        return ''.join(args)

    def _fn_xtou(self, s):
        return chr(int(s, base=16))
